pattern_name,text
abstract_factory,Design Patterns Creational patterns Provide an interface for creating families of related or dependent objects without specifying their concrete classes. A hierarchy that encapsulates: many possible "platforms" and the construction of a suite of "products". The  new  operator considered harmful. #ifdef new Decide if "platform independence" and creation services are the current source of pain. Map out a matrix of "platforms" versus "products". Define a factory interface that consists of a factory method per product. Define a factory derived class for each platform that encapsulates all references to the  new  operator. The client should retire all references to  new  and use the factory methods to create the product objects. Sometimes creational patterns are competitors: there are cases when either Prototype or Abstract Factory could be used profitably.  At other times they are complementary: Abstract Factory might store a set of Prototypes from which to clone and return product objects Builder can use one of the other patterns to implement which components get built. Abstract Factory Builder and Prototype can use Singleton in their implementation. Abstract Factory Builder and Prototype define a factory object that's responsible for knowing and creating the class of product objects and make it a parameter of the system.  Abstract Factory has the factory object producing objects of several classes.  Builder has the factory object building a complex product incrementally using a correspondingly complex protocol.  Prototype has the factory object (aka prototype) building a product by copying a prototype object. Abstract Factory classes are often implemented with Factory Methods but they can also be implemented using Prototype. Abstract Factory can be used as an alternative to Facade to hide platform-specific classes. Builder focuses on constructing a complex object step by step. Abstract Factory emphasizes a family of product objects (either simple or complex). Builder returns the product as a final step but as far as the Abstract Factory is concerned the product gets returned immediately. Often designs start out using Factory Method (less complicated more customizable subclasses proliferate) and evolve toward Abstract Factory Prototype or Builder (more flexible more complex) as the designer discovers where more flexibility is needed.
mediator,Design Patterns Behavioral patterns Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly and it lets you vary their interaction independently. Design an intermediary to decouple many peers. Promote the many-to-many relationships between interacting peers to "full object status". Identify a collection of interacting objects that would benefit from mutual decoupling. Encapsulate those interactions in the abstraction of a new class. Create an instance of that new class and rework all "peer" objects to interact with the Mediator only. Balance the principle of decoupling with the principle of distributing responsibility evenly. Be careful not to create a "controller" or "god" object. Chain of Responsibility Command Mediator and Observer address how you can decouple senders and receivers but with different trade-offs. Chain of Responsibility passes a sender request along a chain of potential receivers.  Command normally specifies a sender-receiver connection with a subclass. Mediator has senders and receivers reference each other indirectly.  Observer defines a very decoupled interface that allows for multiple receivers to be configured at run-time. Mediator and Observer are competing patterns.  The difference between them is that Observer distributes communication by introducing "observer" and "subject" objects whereas a Mediator object encapsulates the communication between other objects.  We've found it easier to make reusable Observers and Subjects than to make reusable Mediators. On the other hand Mediator can leverage Observer for dynamically registering colleagues and communicating with them. Mediator is similar to Facade in that it abstracts functionality of existing classes. Mediator abstracts/centralizes arbitrary communication between colleague objects it routinely "adds value" and it is known/referenced by the colleague objects (i.e. it defines a multidirectional protocol).  In contrast Facade defines a simpler interface to a subsystem it doesn't add new functionality and it is not known by the subsystem classes (i.e. it defines a unidirectional protocol where it makes requests of the subsystem classes but not vice versa).
template_method,Design Patterns Behavioral patterns Define the skeleton of an algorithm in an operation deferring some steps to client subclasses.  Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure. Base class declares algorithm 'placeholders' and derived classes implement the placeholders. template_method() step_one() step_two() step_three() step_two() Examine the algorithm and decide which steps are standard and which steps are peculiar to each of the current classes. Define a new abstract base class to host the "don't call us we'll call you" framework. Move the shell of the algorithm (now called the "template method") and the definition of all standard steps to the new base class. Define a placeholder or "hook" method in the base class for each step that requires many different implementations.  This method can host a default implementation – or – it can be defined as abstract (Java) or pure virtual (C++). Invoke the hook method(s) from the template method. Each of the existing classes declares an "is-a" relationship to the new abstract base class. Remove from the existing classes all the implementation details that have been moved to the base class. The only details that will remain in the existing classes will be the implementation details peculiar to each derived class. Strategy is like Template Method except in its granularity. Template Method uses inheritance to vary part of an algorithm. Strategy uses delegation to vary the entire algorithm. Strategy modifies the logic of individual objects.  Template Method modifies the logic of an entire class. Factory Method is a specialization of Template Method.
observer,Design Patterns Behavioral patterns Define a one-to-many dependency between objects so that when one object changes state all its dependents are notified and updated automatically. Encapsulate the core (or common or engine) components in a Subject abstraction and the variable (or optional or user interface) components in an Observer hierarchy. The "View" part of Model-View-Controller. Differentiate between the core (or independent) functionality and the optional (or dependent) functionality. Model the independent functionality with a "subject" abstraction. Model the dependent functionality with an "observer" hierarchy. The Subject is coupled only to the Observer base class. The client configures the number and type of Observers. Observers register themselves with the Subject. The Subject broadcasts events to all registered Observers. The Subject may "push" information at the Observers or the Observers may "pull" the information they need from the Subject. Chain of Responsibility Command Mediator and Observer address how you can decouple senders and receivers but with different trade-offs. Chain of Responsibility passes a sender request along a chain of potential receivers.  Command normally specifies a sender-receiver connection with a subclass.  Mediator has senders and receivers reference each other indirectly.  Observer defines a very decoupled interface that allows for multiple receivers to be configured at run-time. Mediator and Observer are competing patterns.  The difference between them is that Observer distributes communication by introducing "observer" and "subject" objects whereas a Mediator object encapsulates the communication between other objects.  We've found it easier to make reusable Observers and Subjects than to make reusable Mediators. On the other hand Mediator can leverage Observer for dynamically registering colleagues and communicating with them.
visitor,Design Patterns Behavioral patterns Represent an operation to be performed on the elements of an object structure.  Visitor lets you define a new operation without changing the classes of the elements on which it operates. The classic technique for recovering lost type information. Do the right thing based on the type of two objects. Double dispatch visit() visit() visit() visit() accept() accept() accept() visit() accept() accept() visit() accept() visit() accept() this firstDispatch() First secondDispatch() Second Confirm that the current hierarchy (known as the Element hierarchy) will be fairly stable and that the public interface of these classes is sufficient for the access the Visitor classes will require.  If these conditions are not met then the Visitor pattern is not a good match. Create a Visitor base class with a  visit(ElementXxx)  method for each Element derived type. Add an  accept(Visitor)  method to the Element hierarchy. The implementation in each Element derived class is always the same –  accept( Visitor v ) { v.visit( this ); } .  Because of cyclic dependencies the declaration of the Element and Visitor classes will need to be interleaved. The Element hierarchy is coupled only to the Visitor base class but the Visitor hierarchy is coupled to each Element derived class.  If the stability of the Element hierarchy is low and the stability of the Visitor hierarchy is high; consider swapping the 'roles' of the two hierarchies. Create a Visitor derived class for each "operation" to be performed on Element objects.   visit()  implementations will rely on the Element's public interface. The client creates Visitor objects and passes each to Element objects by calling  accept() . The abstract syntax tree of Interpreter is a Composite (therefore Iterator and Visitor are also applicable). Iterator can traverse a Composite. Visitor can apply an operation over a Composite. The Visitor pattern is like a more powerful Command pattern because the visitor may initiate whatever is appropriate for the kind of object it encounters. The Visitor pattern is the classic technique for recovering lost type information without resorting to dynamic casts. JavaPro Add functions to class libraries for which you either do not have the source or cannot change the source Obtain data from a disparate collection of unrelated classes and use it to present the results of a global calculation to the user program Gather related operations into a single class rather than force you to change or derive classes to add these operations Collaborate with the Composite pattern
iterator,Design Patterns Behavioral patterns Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. The C++ and Java standard library abstraction that makes it possible to decouple collection classes and algorithms. Promote to "full object status" the traversal of a collection. Polymorphic traversal Add a  create_iterator()  method to the "collection" class and grant the "iterator" class privileged access. Design an "iterator" class that can encapsulate traversal of the "collection" class. Clients ask the collection object to create an iterator object. Clients use the  first()   is_done()   next()  and  current_item()  protocol to access the elements of the collection class. The abstract syntax tree of Interpreter is a Composite (therefore Iterator and Visitor are also applicable). Iterator can traverse a Composite. Visitor can apply an operation over a Composite. Polymorphic Iterators rely on Factory Methods to instantiate the appropriate Iterator subclass. Memento is often used in conjunction with Iterator. An Iterator can use a Memento to capture the state of an iteration. The Iterator stores the Memento internally.
strategy,Design Patterns Behavioral patterns Define a family of algorithms encapsulate each one and make them interchangeable. Strategy lets the algorithm vary independently from the clients that use it. Capture the abstraction in an interface bury implementation details in derived classes. Identify an algorithm (i.e. a behavior) that the client would prefer to access through a "flex point". Specify the signature for that algorithm in an interface. Bury the alternative implementation details in derived classes. Clients of the algorithm couple themselves to the interface. Strategy is like Template Method except in its granularity. State is like Strategy except in its intent. Strategy lets you change the guts of an object. Decorator lets you change the skin. State Strategy Bridge (and to some degree Adapter) have similar solution structures. They all share elements of the 'handle/body' idiom.  They differ in intent - that is they solve different problems. Strategy has 2 different implementations the first is similar to State. The difference is in binding times (Strategy is a bind-once pattern whereas State is more dynamic). Strategy objects often make good Flyweights.
state,Design Patterns Behavioral patterns Allow an object to alter its behavior when its internal state changes. The object will appear to change its class. An object-oriented state machine wrapper + polymorphic wrappee + collaboration Define a "context" class to present a single interface to the outside world. Define a State abstract base class. Represent the different "states" of the state machine as derived classes of the State base class. Define state-specific behavior in the appropriate State derived classes. Maintain a pointer to the current "state" in the "context" class. To change the state of the state machine change the current "state" pointer. Identify an existing class or create a new class that will serve as the "state machine" from the client's perspective. That class is the "wrapper" class. Create a State base class that replicates the methods of the state machine interface.  Each method takes one additional parameter: an instance of the wrapper class.  The State base class specifies any useful "default" behavior. Create a State derived class for each domain state.  These derived classes only override the methods they need to override. The wrapper class maintains a "current" State object. All client requests to the wrapper class are simply delegated to the current State object and the wrapper object's  this  pointer is passed. The State methods change the "current" state in the wrapper object as appropriate. State objects are often Singletons. Flyweight explains when and how State objects can be shared. Interpreter can use State to define parsing contexts. Strategy has 2 different implementations the first is similar to State.  The difference is in binding times (Strategy is a bind-once pattern whereas State is more dynamic). The structure of State and Bridge are identical (except that Bridge admits hierarchies of envelope classes whereas State allows only one).  The two patterns use the same structure to solve different problems: State allows an object's behavior to change along with its state while Bridge's intent is to decouple an abstraction from its implementation so that the two can vary independently. The implementation of the State pattern builds on the Strategy pattern.  The difference between State and Strategy is in the intent.  With Strategy the choice of algorithm is fairly stable. With State a change in the state of the "context" object causes it to select from its "palette" of Strategy objects.
null_object,Design Patterns Behavioral patterns an object requires a collaborator. The Null Object pattern does not introduce this collaboration--it makes use of a collaboration that already exists some collaborator instances should do nothing you want to abstract the handling of null away from the client Client  -  requires a collaborator.   AbstractObject  -  declares the interface for Client's collaborator    implements default behavior for the interface common to all classes as appropriate   RealObject  -     defines a concrete subclass of AbstractObject whose instances provide useful behavior that Client expects   NullObject  -     provides an interface identical to AbstractObject's so that a null object can be substituted for a real object    implements its interface to do nothing. What exactly it means to do nothing depends on what sort of behavior Client is expecting    when there is more than one way to do nothing more than one NullObject class may be required     The Null Object class is often implemented as a Singleton. Since a null object usually does not have any state its state can't change so multiple instances are identical. Rather than use multiple identical instances the system can just use a single instance repeatedly. If some clients expect the null object to do nothing one way and some another multiple NullObject classes will be required. If the do nothing behavior must be customized at run time the  NullObject  class will require pluggable variables so that the client can specify how the null object should do nothing (see the discussion of pluggable adaptors in the Adapter pattern). This may generally be a symptom of the  AbstractObject  not having a well defined (semantic) interface. A Null Object does not transform to become a Real Object. If the object may decide to stop providing do nothing behavior and start providing real behavior it is not a null object. It may be a real object with a do nothing mode such as a controller which can switch in and out of read-only mode. If it is a single object which must mutate from a do nothing object to a real one it should be implemented with the State pattern or perhaps the Proxy pattern. In this case a Null State may be used or the proxy may hold a Null Object. The use of a null object can be similar to that of a Proxy but the two patterns have different purposes. A proxy provides a level of indirection when accessing a real subject thus controlling access to the subject. A null collaborator does not hide a real object and control access to it it replaces the real object. A proxy may eventually mutate to start acting like a real subject. A null object will not mutate to start providing real behavior it will always provide do nothing behavior. A Null Object can be a special case of the Strategy pattern. Strategy specifies several ConcreteStrategy classes as different approaches for accomplishing a task. If one of those approaches is to consistently do nothing that  ConcreteStrategy  is a  NullObject . For example a Controller is a View's Strategy for handling input and NoController is the Strategy that ignores all input. A Null Object can be a special case of the State pattern. Normally each ConcreteState has some do nothing methods because they're not appropriate for that state. In fact a given method is often implemented to do something useful in most states but to do nothing in at least one state. If a particular ConcreteState implements most of its methods to do nothing or at least give null results it becomes a do nothing state and as such is a null state. A Null Object can be used to allow a Visitor  to safely visit a hierarchy and handle the null situation. Null Object is a concrete collaborator class that acts as the collaborator for a client which needs one. The null behavior is not designed to be mixed into an object that needs some do nothing behavior. It is designed for a class which delegates to a collaborator all of the behavior that may or may not be do nothing behavior.
interpreter,Design Patterns Behavioral patterns Given a language define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language. Map a domain to a language the language to a grammar and the grammar to a hierarchical object-oriented design. interpret() interpret() Decide if a "little language" offers a justifiable return on investment. Define a grammar for the language. Map each production in the grammar to a class. Organize the suite of classes into the structure of the Composite pattern. Define an  interpret(Context)  method in the Composite hierarchy. The  Context  object encapsulates the current state of the input and output as the former is parsed and the latter is accumulated.  It is manipulated by each grammar class as the "interpreting" process transforms the input into the output. Considered in its most general form (i.e. an operation distributed over a class hierarchy based on the Composite pattern) nearly every use of the Composite pattern will also contain the Interpreter pattern.  But the Interpreter pattern should be reserved for those cases in which you want to think of this class hierarchy as defining a language. Interpreter can use State to define parsing contexts. The abstract syntax tree of Interpreter is a Composite (therefore Iterator and Visitor are also applicable). Terminal symbols within Interpreter's abstract syntax tree can be shared with Flyweight. The pattern doesn't address parsing.  When the grammar is very complex other techniques (such as a parser) are more appropriate.
command,Design Patterns Behavioral patterns Encapsulate a request as an object thereby letting you parametrize clients with different requests queue or log requests and support undoable operations. Promote "invocation of a method on an object" to full object status An object-oriented callback execute() execute() Define a Command interface with a method signature like  execute() . Create one or more derived classes that encapsulate some subset of the following: a "receiver" object the method to invoke the arguments to pass. Instantiate a Command object for each deferred execution request. Pass the Command object from the creator (aka sender) to the invoker (aka receiver). The invoker decides when to  execute() . Chain of Responsibility Command Mediator and Observer address how you can decouple senders and receivers but with different trade-offs. Command normally specifies a sender-receiver connection with a subclass. Chain of Responsibility can use Command to represent requests as objects. Command and Memento act as magic tokens to be passed around and invoked at a later time. In Command the token represents a request; in Memento it represents the internal state of an object at a particular time. Polymorphism is important to Command but not to Memento because its interface is so narrow that a memento can only be passed as a value. Command can use Memento to maintain the state required for an undo operation. MacroCommands can be implemented with Composite. A Command that must be copied before being placed on a history list acts as a Prototype. Two important aspects of the Command pattern: interface separation (the invoker is isolated from the receiver) time separation (stores a ready-to-go processing request that's to be stated later).
facade,Design Patterns Structural patterns Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use. Wrap a complicated subsystem with a simpler interface. SubsystemOne SubsystemThree SubsystemTwo SubsystemTwoWrapper Identify a simpler unified interface for the subsystem or component. Design a 'wrapper' class that encapsulates the subsystem. The facade/wrapper captures the complexity and collaborations of the component and delegates to the appropriate methods. The client uses (is coupled to) the Facade only. Consider whether additional Facades would add value. Facade defines a new interface whereas Adapter uses an old interface. Remember that Adapter makes two existing interfaces work together as opposed to defining an entirely new one. Whereas Flyweight shows how to make lots of little objects Facade shows how to make a single object represent an entire subsystem. Mediator is similar to Facade in that it abstracts functionality of existing classes. Mediator abstracts/centralizes arbitrary communications between colleague objects. It routinely "adds value" and it is known/referenced by the colleague objects. In contrast Facade defines a simpler interface to a subsystem it doesn't add new functionality and it is not known by the subsystem classes. Abstract Factory can be used as an alternative to Facade to hide platform-specific classes. Facade objects are often Singletons because only one Facade object is required. Adapter and Facade are both wrappers; but they are different kinds of wrappers.  The intent of Facade is to produce a simpler interface and the intent of Adapter is to design to an existing interface. While Facade routinely wraps multiple objects and Adapter wraps a single object; Facade could front-end a single complex object and Adapter could wrap several legacy objects. Question: Answer:
chain_of_responsibility,Design Patterns Behavioral patterns Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.  Chain the receiving objects and pass the request along the chain until an object handles it. Launch-and-leave requests with a single processing pipeline that contains many possible handlers. An object-oriented linked list with recursive traversal. The base class maintains a "next" pointer. Each derived class implements its contribution for handling the request. If the request needs to be "passed on" then the derived class "calls back" to the base class which delegates to the "next" pointer. The client (or some third party) creates and links the chain (which may include a link from the last node to the root node). The client "launches and leaves" each request with the root of the chain. Recursive delegation produces the illusion of magic. Chain of Responsibility Command Mediator and Observer address how you can decouple senders and receivers but with different trade-offs. Chain of Responsibility passes a sender request along a chain of potential receivers. Chain of Responsibility can use Command to represent requests as objects. Chain of Responsibility is often applied in conjunction with Composite.  There a component's parent can act as its successor.
flyweight,Design Patterns Structural patterns Use sharing to support large numbers of fine-grained objects efficiently. The Motif GUI strategy of replacing heavy-weight widgets with light-weight gadgets. Ant Locust Cockroach Ensure that object overhead is an issue needing attention and the client of the class is able and willing to absorb responsibility realignment. Divide the target class's state into: shareable (intrinsic) state and non-shareable (extrinsic) state. Remove the non-shareable state from the class attributes and add it the calling argument list of affected methods. Create a Factory that can cache and reuse existing class instances. The client must use the Factory instead of the new operator to request objects. The client (or a third party) must look-up or compute the non-shareable state and supply that state to class methods. Whereas Flyweight shows how to make lots of little objects Facade shows how to make a single object represent an entire subsystem. Flyweight is often combined with Composite to implement shared leaf nodes. Terminal symbols within Interpreter's abstract syntax tree can be shared with Flyweight. Flyweight explains when and how State objects can be shared.
proxy,Design Patterns Structural patterns Provide a surrogate or placeholder for another object to control access to it. Use an extra level of indirection to support distributed controlled or intelligent access. Add a wrapper and delegation to protect the real component from undue complexity. A virtual proxy is a placeholder for "expensive to create" objects. The real object is only created when a client first requests/accesses the object. A remote proxy provides a local representative for an object that resides in a different address space.  This is what the "stub" code in RPC and CORBA provides. A protective proxy controls access to a sensitive master object.  The "surrogate" object checks that the caller has the access permissions required prior to forwarding the request. A smart proxy interposes additional actions when an object is accessed.  Typical uses include:      Counting the number of references to the real object so that it can be freed automatically when there are no more references (aka smart pointer)   Loading a persistent object into memory when it's first referenced   Checking that the real object is locked before it is accessed to ensure that no other object can change it.     Identify the leverage or "aspect" that is best implemented as a wrapper or surrogate. Define an interface that will make the proxy and the original component interchangeable. Consider defining a Factory that can encapsulate the decision of whether a proxy or original object is desirable. The wrapper class holds a pointer to the real class and implements the interface. The pointer may be initialized at construction or on first use. Each wrapper method contributes its leverage and delegates to the wrappee object. Adapter provides a different interface to its subject.  Proxy provides the same interface.  Decorator provides an enhanced interface. Decorator and Proxy have different purposes but similar structures. Both describe how to provide a level of indirection to another object and the implementations keep a reference to the object to which they forward requests.
memento,Design Patterns Behavioral patterns Without violating encapsulation capture and externalize an object's internal state so that the object can be returned to this state later. A magic cookie that encapsulates a "check point" capability.  Promote undo or rollback to full object status. Originator  - the object that knows how to save itself.  Caretaker  - the object that knows why and when the Originator needs to save and restore itself.  Memento  - the lock box that is written and read by the Originator and shepherded by the Caretaker. Identify the roles of “caretaker” and “originator”. Create a Memento class and declare the originator a friend. Caretaker knows when to "check point" the originator. Originator creates a Memento and copies its state to that Memento. Caretaker holds on to (but cannot peek into) the Memento. Caretaker knows when to "roll back" the originator. Originator reinstates itself using the saved state in the Memento. Command and Memento act as magic tokens to be passed around and invoked at a later time. In Command the token represents a request; in Memento it represents the internal state of an object at a particular time. Polymorphism is important to Command but not to Memento because its interface is so narrow that a memento can only be passed as a value. Command can use Memento to maintain the state required for an undo operation. Memento is often used in conjunction with Iterator. An Iterator can use a Memento to capture the state of an iteration. The Iterator stores the Memento internally.
decorator,Design Patterns Structural patterns Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. Client-specified embellishment of a core object by recursively wrapping it. Wrapping a gift putting it in a box and wrapping the box. CoreFunctionality.doThis() OptionalOne.doThis() OptionalTwo.doThis() Ensure the context is: a single core (or non-optional) component several optional embellishments or wrappers and an interface that is common to all. Create a "Lowest Common Denominator" interface that makes all classes interchangeable. Create a second level base class (Decorator) to support the optional wrapper classes. The Core class and Decorator class inherit from the LCD interface. The Decorator class declares a composition relationship to the LCD interface and this data member is initialized in its constructor. The Decorator class delegates to the LCD object. Define a Decorator derived class for each optional embellishment. Decorator derived classes implement their wrapper functionality - and - delegate to the Decorator base class. The client configures the type and ordering of Core and Decorator objects. Adapter provides a different interface to its subject. Proxy provides the same interface. Decorator provides an enhanced interface. Adapter changes an object's interface Decorator enhances an object's responsibilities. Decorator is thus more transparent to the client. As a consequence Decorator supports recursive composition which isn't possible with pure Adapters. Composite and Decorator have similar structure diagrams reflecting the fact that both rely on recursive composition to organize an open-ended number of objects. A Decorator can be viewed as a degenerate Composite with only one component.  However a Decorator adds additional responsibilities - it isn't intended for object aggregation. Decorator is designed to let you add responsibilities to objects without subclassing. Composite's focus is not on embellishment but on representation. These intents are distinct but complementary. Consequently Composite and Decorator are often used in concert. Composite could use Chain of Responsibility to let components access global properties through their parent. It could also use Decorator to override these properties on parts of the composition. Decorator and Proxy have different purposes but similar structures. Both describe how to provide a level of indirection to another object and the implementations keep a reference to the object to which they forward requests. Decorator lets you change the skin of an object. Strategy lets you change the guts.
composite,Design Patterns Structural patterns Compose objects into tree structures to represent whole-part hierarchies.  Composite lets clients treat individual objects and compositions of objects uniformly. Recursive composition "Directories contain entries each of which could be a directory." 1-to-many "has a" up the "is a" hierarchy addChild() removeChild() Ensure that your problem is about representing "whole-part" hierarchical relationships. Consider the heuristic "Containers that contain containees each of which could be a container."  For example "Assemblies that contain components each of which could be an assembly." Divide your domain concepts into container classes and containee classes. Create a "lowest common denominator" interface that makes your containers and containees interchangeable.  It should specify the behavior that needs to be exercised uniformly across all containee and container objects. All container and containee classes declare an "is a" relationship to the interface. All container classes declare a one-to-many "has a" relationship to the interface. Container classes leverage polymorphism to delegate to their containee objects. Child management methods [e.g.  addChild()   removeChild() ] should normally be defined in the Composite class. Unfortunately the desire to treat Leaf and Composite objects uniformly may require that these methods be promoted to the abstract Component class. See the Gang of Four for a discussion of these "safety" versus "transparency" trade-offs. Composite and Decorator have similar structure diagrams reflecting the fact that both rely on recursive composition to organize an open-ended number of objects. Composite can be traversed with Iterator.  Visitor can apply an operation over a Composite.  Composite could use Chain of Responsibility to let components access global properties through their parent.  It could also use Decorator to override these properties on parts of the composition.  It could use Observer to tie one object structure to another and State to let a component change its behavior as its state changes. Composite can let you compose a Mediator out of smaller pieces through recursive composition. Decorator is designed to let you add responsibilities to objects without subclassing.  Composite's focus is not on embellishment but on representation.  These intents are distinct but complementary. Consequently Composite and Decorator are often used in concert. Flyweight is often combined with Composite to implement shared leaf nodes. dynamic_cast dynamic_cast
bridge,Design Patterns Structural patterns Decouple an abstraction from its implementation so that the two can vary independently. Publish interface in an inheritance hierarchy and bury implementation in its own inheritance hierarchy. Beyond encapsulation to insulation you want run-time binding of the implementation you have a proliferation of classes resulting from a coupled interface and numerous implementations you want to share an implementation among multiple objects you need to map orthogonal class hierarchies. decoupling the object's interface improved extensibility (you can extend (i.e. subclass) the abstraction and implementation hierarchies independently) hiding details from clients. Decide if two orthogonal dimensions exist in the domain.  These independent concepts could be: abstraction/platform or domain/infrastructure or front-end/back-end or interface/implementation. Design the separation of concerns: what does the client want and what do the platforms provide. Design a platform-oriented interface that is minimal necessary and sufficient.  Its goal is to decouple the abstraction from the platform. Define a derived class of that interface for each platform. Create the abstraction base class that "has a" platform object and delegates the platform-oriented functionality to it. Define specializations of the abstraction class if desired. Adapter makes things work after they're designed; Bridge makes them work before they are. Bridge is designed up-front to let the abstraction and the implementation vary independently. Adapter is retrofitted to make unrelated classes work together. State Strategy Bridge (and to some degree Adapter) have similar solution structures.  They all share elements of the "handle/body" idiom. They differ in intent - that is they solve different problems. The structure of State and Bridge are identical (except that Bridge admits hierarchies of envelope classes whereas State allows only one).  The two patterns use the same structure to solve different problems: State allows an object's behavior to change along with its state while Bridge's intent is to decouple an abstraction from its implementation so that the two can vary independently. If interface classes delegate the creation of their implementation classes (instead of creating/coupling themselves directly) then the design usually uses the Abstract Factory pattern to create the implementation objects.
prototype,Design Patterns Creational patterns Specify the kinds of objects to create using a prototypical instance and create new objects by copying this prototype. Co-opt one instance of a class for use as a breeder of all future instances. The  new  operator considered harmful. clone() Add a  clone()  method to the existing "product" hierarchy. Design a "registry" that maintains a cache of prototypical objects. The registry could be encapsulated in a new  Factory  class or in the base class of the "product" hierarchy. Design a factory method that: may (or may not) accept arguments finds the correct prototype object calls  clone()  on that object and returns the result. The client replaces all references to the  new  operator with calls to the factory method. Sometimes creational patterns are competitors: there are cases when either Prototype or Abstract Factory could be used properly. At other times they are complementary: Abstract Factory might store a set of Prototypes from which to clone and return product objects. Abstract Factory Builder and Prototype can use Singleton in their implementations. Abstract Factory classes are often implemented with Factory Methods but they can be implemented using Prototype. Factory Method: creation through inheritance. Prototype: creation through delegation. Often designs start out using Factory Method (less complicated more customizable subclasses proliferate) and evolve toward Abstract Factory Prototype or Builder (more flexible more complex) as the designer discovers where more flexibility is needed. Prototype doesn't require subclassing but it does require an "initialize" operation. Factory Method requires subclassing but doesn't require Initialize. Designs that make heavy use of the Composite and Decorator patterns often can benefit from Prototype as well. Prototype co-opts one instance of a class for use as a breeder of all future instances. Prototypes are useful when object initialization is expensive and you anticipate few variations on the initialization parameters. In this context Prototype can avoid expensive "creation from scratch" and support cheap cloning of a pre-initialized prototype. Prototype is unique among the other creational patterns in that it doesn't require a class – only an object.  Object-oriented languages like Self and Omega that do away with classes completely rely on prototypes for creating new objects.
adapter,Design Patterns Structural patterns Convert the interface of a class into another interface clients expect.  Adapter lets classes work together that couldn't otherwise because of incompatible interfaces. Wrap an existing class with a new interface. Impedance match an old component to a new system display() Identify the players: the component(s) that want to be accommodated (i.e. the client) and the component that needs to adapt (i.e. the adaptee). Identify the interface that the client requires. Design a "wrapper" class that can "impedance match" the adaptee to the client. The adapter/wrapper class "has a" instance of the adaptee class. The adapter/wrapper class "maps" the client interface to the adaptee interface. The client uses (is coupled to) the new interface Adapter makes things work after they're designed; Bridge makes them work before they are. Bridge is designed up-front to let the abstraction and the implementation vary independently. Adapter is retrofitted to make unrelated classes work together. Adapter provides a different interface to its subject. Proxy provides the same interface. Decorator provides an enhanced interface. Adapter is meant to change the interface of an existing object. Decorator enhances another object without changing its interface. Decorator is thus more transparent to the application than an adapter is.  As a consequence Decorator supports recursive composition which isn't possible with pure Adapters. Facade defines a new interface whereas Adapter reuses an old interface. Remember that Adapter makes two existing interfaces work together as opposed to defining an entirely new one.
private_class_data,Design Patterns Structural patterns Control write access to class attributes Separate data from methods that use it Encapsulate class data initialization Providing new type of  final  -  final after constructor Create data class. Move to data class all attributes that need hiding. Create in main class instance of data class. Main class must initialize data class through the data class's constructor. Expose each attribute (variable or property) of data class through a getter. Expose each attribute that will change in further through a setter.
builder,Design Patterns Creational patterns Separate the construction of a complex object from its representation so that the same construction process can create different representations. Parse a complex representation create one of several targets. Decide if a common input and many possible representations (or outputs) is the problem at hand. Encapsulate the parsing of the common input in a Reader class. Design a standard protocol for creating all possible output representations.  Capture the steps of this protocol in a Builder interface. Define a Builder derived class for each target representation. The client creates a Reader object and a Builder object and registers the latter with the former. The client asks the Reader to "construct". The client asks the Builder to return the result. Sometimes creational patterns are complementary: Builder can use one of the other patterns to implement which components get built. Abstract Factory Builder and Prototype can use Singleton in their implementations. Builder focuses on constructing a complex object step by step. Abstract Factory emphasizes a family of product objects (either simple or complex). Builder returns the product as a final step but as far as the Abstract Factory is concerned the product gets returned immediately. Builder often builds a Composite. Often designs start out using Factory Method (less complicated more customizable subclasses proliferate) and evolve toward Abstract Factory Prototype or Builder (more flexible more complex) as the designer discovers where more flexibility is needed.
singleton,Design Patterns Creational patterns Ensure a class has only one instance and provide a global point of access to it. Encapsulated "just-in-time initialization" or "initialization on first use". Ownership of the single instance cannot be reasonably assigned Lazy initialization is desirable Global access is not otherwise provided for To Kill A Singleton Define a private  static  attribute in the "single instance" class. Define a public  static  accessor function in the class. Do "lazy initialization" (creation on first use) in the accessor function. Define all constructors to be  protected  or  private . Clients may only use the accessor function to manipulate the Singleton. Abstract Factory Builder and Prototype can use Singleton in their implementation. Facade objects are often Singletons because only one Facade object is required. State objects are often Singletons. The advantage of Singleton over global variables is that you are absolutely sure of the number of instances when you use Singleton and you can change your mind and manage any number of instances. The Singleton design pattern is one of the most inappropriately used patterns.  Singletons are intended to be used when a class must have exactly one instance no more no less. Designers frequently use Singletons in a misguided attempt to replace global variables. A Singleton is for intents and purposes a global variable.  The Singleton does not do away with the global; it merely renames it. When is Singleton unnecessary? Short answer: most of the time. Long answer: when it's simpler to pass an object resource as a reference to the objects that need it rather than letting objects access the resource globally. The real problem with Singletons is that they give you such a good excuse not to think carefully about the appropriate visibility of an object. Finding the right balance of exposure and protection for an object is critical for maintaining flexibility. Our group had a bad habit of using global data so I did a study group on Singleton. The next thing I know Singletons appeared everywhere and none of the problems related to global data went away. The answer to the global data question is not "Make it a Singleton." The answer is "Why in the hell are you using global data?" Changing the name doesn't change the problem. In fact it may make it worse because it gives you the opportunity to say "Well I'm not doing that I'm doing this" – even though this and that are the same thing.
object_pool,Design Patterns Creational patterns Reusable  -   Instances of classes in this role collaborate with other objects for a limited amount of time then they are no longer needed for that collaboration. Client  -   Instances of classes in this role use Reusable objects. ReusablePool  -   Instances of classes in this role manage Reusable objects for use by Client objects. Reusable Reusable ReusablePool ReusablePool acquireReusable Reusable ReusablePool Reusable Reusable Reusable Reusable acquireReusable Reusable acquireReusable Reusable acquireReusable Reusable Reusable Reusable ReusablePool releaseReusable releaseReusable Reusable Reusable Reusable ReusablePool Reusable Reusable ReusablePool ReusablePool Create  ObjectPool  class with private array of  Object s inside Create  acquire  and  release  methods in ObjectPool class Make sure that your ObjectPool is Singleton The Factory Method pattern can be used to encapsulate the creation logic for objects. However it does not manage them after their creation the object pool pattern keeps track of the objects it creates. Object Pools are usually implemented as Singletons.
factory_method,Design Patterns Creational patterns Define an interface for creating an object but let subclasses decide which class to instantiate.  Factory Method lets a class defer instantiation to subclasses. Defining a "virtual" constructor. The  new  operator considered harmful. static Color.make_RGB_color(float red float green float blue) Color.make_HSB_color(float hue float saturation float brightness) If you have an inheritance hierarchy that exercises polymorphism consider adding a polymorphic creation capability by defining a  static  factory method in the base class. Design the arguments to the factory method.  What qualities or characteristics are necessary and sufficient to identify the correct derived class to instantiate? Consider designing an internal "object pool" that will allow objects to be reused instead of created from scratch. Consider making all constructors  private  or  protected . Abstract Factory classes are often implemented with Factory Methods but they can be implemented using Prototype. Factory Methods are usually called within Template Methods. Factory Method: creation through inheritance. Prototype: creation through delegation. Often designs start out using Factory Method (less complicated more customizable subclasses proliferate) and evolve toward Abstract Factory Prototype or Builder (more flexible more complex) as the designer discovers where more flexibility is needed. Prototype doesn't require subclassing but it does require an Initialize operation. Factory Method requires subclassing but doesn't require Initialize. The advantage of a Factory Method is that it can return the same instance multiple times or can return a subclass rather than an object of that exact type. Some Factory Method advocates recommend that as a matter of language design (or failing that as a matter of style) absolutely all constructors should be private or protected.  It's no one else's business whether a class manufactures a new object or recycles an old one. The  new  operator considered harmful.  There is a difference between requesting an object and creating one.  The  new  operator always creates an object and fails to encapsulate object creation.  A Factory Method enforces that encapsulation and allows an object to be requested without inextricable coupling to the act of creation.
