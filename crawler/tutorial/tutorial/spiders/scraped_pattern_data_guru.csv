id,category_id,name,overview
91,0,abstract_factory_pattern,"
Question:What is the abstract factory pattern?
Answer: A factory pattern in which the factory class is abstract so that its implementation can be given as per requirement. 
This pattern provids an interface for creating families of related or dependent objects without specifying their concrete classes.
Given a set of related abstract classes, the Abstract Factory pattern provides a way to create instances of those abstract classes from a matched set of concerte subclases. The ""Abstract Factory"" pattern provides an abstract class that determines the appropriate concrete class to instantiate to create a set of concrete products that implement a standard interface. 
The client interacts only with the product interfaces and the Abstract Factory class. The client never knows about the concrete construction classes provided by this pattern. 
The Abstract Factory pattern is similar to the Factory Method pattern, except it creates families of related objects.

The following lists the benefits of using the Abstract Factory pattern:

Isolates concrete classes.
Makes exchanging product families easy.
Promotes consistency among products.


You should use the Abstract Factory pattern when:

The system should be independent of how its prodcuts are created, composed, and represented.
The system should be configured with one of multiple families of products  a) MS Windows or b) Apple Macintosh
The family of related product objects is designed to be used together, and you must enforce this constraint. 	This is the key point of the pattern, otherwise you could use a Factory Pattern.

Gang of Four Patterns

A realization is a semantic relationship between classifiers, where one classifier specifies a contract that another classifier guarantees to carry out.
Generalization relationship is an association with a small triangle next to the class being inherited from whereas an aggregation relationship is an association with a diamond next to the class representing the aggregate. 


The abstract factory pattern is a software design pattern that provides a way to encapsulate a group of individual factories that have a common theme. In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interfaces to create the concrete objects that are part of the theme. The client does not know (or care) which concrete objects it gets from each of these internal factories, since it uses only the generic interfaces of their products. 
This pattern separates the details of implementation of a set of objects from their general usage. 
An example of this would be an abstract factory class DocumentCreator that provides interfaces to create a number of products  (e.g. createLetter() and createResume()). The system would have any number of derived concrete versions of the DocumentCreator class like FancyDocumentCreator or ModernDocumentCreator, each with a different implementation of createLetter() and createResume() that would create a corresponding object like FancyLetter or ModernResume. 
Each of these products is derived from a simple abstract class like Letter or Resume of which the client is aware. The client code would get an appropriate instance of the DocumentCreator and call its factory methods. Each of the resulting objects would be created from the same DocumentCreator implementation and would share a common theme (they would all be fancy or modern objects). The client would need to know how to handle only the abstract Letter or Resume class, not the specific version that it got from the concrete factory.

A factory is the location or a concrete class in the code at which objects are constructed. 
The intent in employing the pattern is to insulate the creation of objects from their usage. 
This allows for new derived types to be introduced with no change to the code that uses the base class. 
Use of this pattern makes it possible to interchange concrete implementations without changing the code that uses them, even at runtime.
However, employment of this pattern, as with similar design patterns, may result in unnecessary complexity and extra work in the initial writing of code. Used correctly the ""extra work"" pays off in the second implementation of the factory.
Classic Computer Science Problems






"
92,0,decorator_pattern,"
The Decorator pattern enables you to add or remove object functionality without changing the external appearance or function of  the object.  It changes the functionality of an object in a way that is transparent to its clients by using an instance of a subclass of the original class that delegates operations to the original object.
The Decorator pattern attaches additional responsibilities to an object dynamically to provide a flexible alternative to changing object functionality without using static inheritance

The following lists the benefits of using the Decorator pattern:

More flexibility than static inheritance.
Avoids feature-laden  classes high up in the hierarchy 
Simplifies coding because you write a series of classes, each targeted at a specific part of the functionality, rather than coding all behavior into the object
Enhances the object's extensibility because you make changes by coding new classes.


You should use the Decorator pattern when:

You want to add responsibilities to individual objects dynamically  and transparently, that is without affecting other objects 
You want to add responsibilities to the object that you want to change in the future
When extension by static sub-classing is impractical.

September 23, 2020







"
93,0,facade_pattern,"
The Facade pattern provides a unified interface to a group of interfaces in a subsystem.  
The Facade pattern defines a higher-level interface that makes the subsystem easier to use because you have only one interface. 
This unified interface enables an object to access the subsystem using the interface to communicate with the subsystem. 
The figure below illustrates the Facade pattern.

The following lists the benefits of using the facade pattern.

Provides a simple interface to a complex system without reducing the options provided by the system.
Shields clients from subsystem components.
Promotes weak coupling between the subsystem and its clients.
Reduces coupling between subsystems if every subsystem uses its own Facade pattern and other parts of the system use the 
Facade pattern to communicate with the subsystem.
Translates the client requests to the subsystems that can fulfill those requests.

Facade Pattern Code
You should use the Facade pattern when:

You want to provide a simple interface to a complex subsystem.
There are many dependencies between clients and implementation classes of an abstraction.
You want to layer your subsystems.








"
94,0,composite_pattern,"
The Composite pattern enables you to create hierarchical tree structures of varying complexity, while allowing every element in the structure to operate with a uniform interface. The Composite pattern combines objects into tree structures to represent either the whole hierarchy or a part of the hierarchy. This means the Composite pattern allows clients to treat individual objects and compositions of objects uniformly. The figure below illustrates the Composite pattern.

Furthermore, the composite pattern is a partitioning design pattern. The composite pattern describes that a group of objects are to be treated in the same way as a single instance of an object. 
The intent of a composite is to ""compose"" objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.

When dealing with Tree-structured data, programmers often have to discriminate between a leaf-node and a branch. The solution is an interface that allows treating complex and primitive objects uniformly. 
In object-oriented programming,  a composite is an object designed as a composition of one-or-more similar objects,  all exhibiting similar functionality. 

This is known as a ""has-a"" relationship between objects. 
The key concept is that you can manipulate a single instance of the object just as you would manipulate a group of  them. The operations you can perform on all the composite objects often have a least common denominator relationship. 
For example, if defining a system to portray grouped shapes on a screen, it would be useful to define resizing a group of shapes  to have the same effect (in some sense) as resizing a single shape.

The following lists the benefits of using the Composite pattern:

Defines class hierarchies consisting of primitive objects and composite objects
Makes it easier to add new kinds of components
Provides flexibility of structure and a manageable interface


You should use the Composite pattern when:

You want to represent the whole hierarchy or part of the hierarchy of objects.
You want clients to be able to ignore the difference between compositions of objects and individual objects.
The structure can have any level of complexity, and is dynamic.








"
95,0,factory_method_pattern,"
In a factory pattern, a concrete class with static methods is used to create instances of objects that implement an interface.

The Factory Method pattern defines an interface for creating an object, but lets the subclasses decide which class to instantiate. The Factory method lets a class defer instantiation to subclasses, which is useful for constructing individual objects for a specific purpose without the requestor 
knowing the specific class being instantiated.  This allows you to introduce new classes without modifying the code because the new class implements only the interface so it can be used by the client. 
You create a new factory class to create the new class and the factory class implements the factory interface.

The following lists the benefits of using the Factory Method pattern.

Eliminates the need to bind application classes into your code. The code deals only with the interface, so you can work with any classes that implement that interface.
Enables the subclasses to provide an extended version of an object,  because creating an object inside a class is more flexible than creating the object directly in the client.

You should use the Factory method pattern when: 

A class cannot anticipate the class of objects it must create.
A class wants its subclasses to specify the objects it creates.
Classes delegate responsibility to one of several helper subclasses, and you want to localize the knowledge of which helper subclass is the delegate.



 The factory method pattern is an object-oriented creational design pattern to implement the concept of factories and deals with the problem of creating objects (products) without specifying the exact class of object that will be created. The essence of this pattern is to

Define an interface for creating an object, but let the classes that implement the interface decide which class to instantiate. 
The Factory method lets a class defer instantiation to subclasses.


Creating an object often requires complex processes not appropriate to include within a composing object. 
The object's creation may lead to a significant duplication of code, may require information not accessible to the composing object, may not provide a sufficient level of abstraction, or may otherwise not be part of the composing object's concerns. 
The factory method design pattern handles these problems by defining a separate method for creating the objects,  which subclasses can then override to specify the derived type of product that will be created. 
Some of the processes required in the creation of an object include determining which object to create, managing the lifetime of the object, and managing specialized build-up and tear-down concerns of the object. Outside the scope of design patterns, 
the term factory method can also refer to a method of a factory whose main purpose is creation of objects. The factory method pattern relies on inheritance, as object creation is delegated to subclasses that implement the factory method to create objects. 

The Factory Method is related to the idea on which libraries work because  library uses abstract classes for defining and maintaining relations between objects. One type of responsibility is creating such objects. The library knows when an object needs to be created, but not what kind of object it should create, this being specific to the application using the library. 
The Factory method works the same way because it defines an interface for creating an object, but leaves the choice of its type to the subclasses.  
A simple real life example of the Factory Method is the hotel. When staying in a hotel you first have to check in. The person working at the front desk will give you a key to your room after you have paid for the room you want.

This room can be conceived as a room factory.  While staying at the hotel, you might need to make a phone call, so you call the front desk and the person there will connect you with the number you need, 
becoming a phone-call factory, because he controls the access to calls. 







"
96,0,prototype_pattern,"
The Prototype pattern allows an object to create customized objects without knowing their exact class or the details of how to create them.It specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying this prototype.  The Prototype pattern works by giving prototypical objects to an object and then initiates the creation of objects. The creation-initiating object then creates objects by asking the prototypical objects to make copies of themselves. 
The Prototype pattern makes creating objects dynamically easier by defining classes whose objects can duplicate themselves.

The following lists the benefits of using the Prototype pattern:

Adding and removing products at run time.
Specifying new objects by varying values.
Specifying new objects by varying structure
Reduced subclassing
Configuring an application with classes dynamically



The classes to instantiate are specified at run time, for example, by dynamic loading.
To avoid building a class hierarchy of factories that parallels the class hierarchy of products
When instances of a class can have one of only a few different combinations of state


The prototype pattern is a creational design pattern used in software development when the type of objects to create 
is determined by a prototypical instance, which is cloned to produce new objects. This pattern is used to: 

avoid subclasses of an object creator in the client application, like the abstract factory pattern does.
avoid the inherent cost of creating a new object in the standard way (e.g., using the 'new' keyword) when it 
    is prohibitively expensive for a given application.
	


To implement the pattern, declare an abstract base class that specifies a pure virtual clone() method. 
Any class that needs a ""polymorphic constructor"" capability derives itself from the abstract base class, and implements the clone() operation.
The client, instead of writing code that invokes the ""new"" operator on a hard-coded class name, 
calls the clone() method on the prototype, calls a factory method with a parameter designating the particular concrete derived class desired, or invokes the clone() method through 
some mechanism provided by another design pattern.







"
97,0,adapter_pattern,"
The Adapter pattern acts as an intermediary between two classes, converting the interface of one class so that it can be used with the other. 
This enables classes with incompatible interfaces to work together. 
The Adapter pattern implements an interface known to its clients and provides access to an instance of a class not known to its clients. 
An adapter object provides the functionality of an interface without having to know the class used to implement that interace.

The following lists the benefits of using the Adapter pattern:

Allows two or more incompatible objects to communicate and interact
Improves resuability of older functionality


You want to use an existing class, and its interface does not match the interface you need.
You want to create a reusable class that cooperates with unrelated or unforesen classes,  that is, classes that do not necessarily have compatible interfaces.
You want to use an object in an environment that expects an interface that is different from the object's interface.
Interface translation among multiple sources must occur.

In computer programming, the adapter pattern (often referred to as the wrapper pattern or simply a wrapper) is a design pattern that translates one interface for a class into a compatible interface. 
An adapter allows classes to work together that normally could not because of incompatible interfaces, by providing its interface to clients while using the original interface. 
The adapter translates calls to its interface into calls to the original interface,  and the amount of code necessary to do this is typically small. 
The adapter is also responsible for transforming data into appropriate forms. For instance, if multiple boolean values are stored as a single integer (i.e. flags) but your client requires a 'true'/'false', 
the adapter would be responsible for extracting the appropriate values from the integer value. 
 Another example is transforming the format of dates (i.e. YYYYMMDD to MM/DD/YYYY or DD/MM/YYYY).







"
98,0,builder_pattern,"
The Builder pattern separates the construction of a complex object from its representation so the same construction process can create different objects. The Builder pattern allows a client object to construct a complex object by specifying only its type and content. The client is shielded from the details of the object's construction. This simplifies the creation of complex objects by defining a class that builds instances of another class. 
The Builder pattern produces one main product and there might be more than one class in the product, but there is always one main class. When you use the Builder pattern, you create the complex objects one step at a time.
Other patterns build the object in a single step.

The following lists the benefits of using the Builder pattern:

Allows you to vary a product's internal representation. Isolates code for construction and representation.Gives you greater control over the construction process.


You should use the Builder pattern when:

The algorithm for creating a complex object should be independent of both the parts that make up the objects and how these parts are assembled.
The construction process must allow different representations of the constructed object.


The ""Builder"" pattern is an object creation software design pattern.  The intention is to abstract the steps of construction so that different implementations of these steps can construct different representations of objects. Often, the builder pattern is used to build products in accordance with the composite pattern.
The intent of the Builder design pattern is to separate the construction of a complex object from its representation. By doing so, the same construction process can create different representations.

The builder is an abstract interface for creating objects.
Gang of Four Patterns






"
99,0,singleton_pattern,"The Singleton pattern ensures that a class has only one instance, and provides a global point of access to that class. It ensures that all objects that use an instance of this class use the same instance.

The figure below discusses the Singleton pattern.
The following lists the benefits of using the Singleton pattern:

Controlled access to sole instance.
Reduced name space.
Permits refinement of operations and representation.
Permits a variable number of instances.
More flexible than class operations.

You should use the Singleton pattern when: There must be exactly one instance of a class. 
In software engineering, the Singleton Pattern is a design pattern that restricts the instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system. 
The concept is sometimes generalized to systems that operate more efficiently when only one object exists, or that restrict the instantiation to a certain number of objects. 

The term comes from the mathematical concept of a singleton.
There is criticism of the use of the singleton pattern, as some consider it an anti-pattern,  judging that it is overused, introduces unnecessary restrictions in situations where a sole instance of a class is not actually required, 
and introduces global state into an application.  In C++ it also serves to isolate from the unpredictability of the order of dynamic initialization, returning control to the programmer. 
Modeling Aggregation and Composition







"
100,0,bridge_pattern,"
Divide a complex component into 2 separate but related inheritance hierarchies.

Refined Abstraction 
Implementor is an abstract class that inherits the 2 classes Concrete Implementor A,B 





 Implementor is an abstract class that inherits the 2 classes Concrete Implementor A,B

Bridge Pattern Code


When To Use:
You should use the Bridge pattern when:

You want to avoid a  permanent binding between an abstraction and its implementation
Both the abstractions and their implementations should be extensible using subclasses.
Changes in the implementation of an abstraction should have no impact on clients; that is, you should not have to recompile their code.


Benefits of the Bridge Pattern:

Enables you to separate the interface from the implementation
Improves extensibility
Hides implementation details from clients


The bridge pattern is a design pattern used in software engineering which is meant to ""decouple an abstraction from its implementation so that 

a) decoupling and  
b) abstraction can vary independently.

The bridge uses encapsulation, aggregation, and can use inheritance to separate responsibilities into different classes.

When a class varies often, the features of object-oriented programming become very useful because changes to a program's code can be made easily with minimal prior knowledge about the program. The bridge pattern is useful when both the class as well as what it does vary often. 

The 1) class itself can be thought of as the implementation and 2) what the class can do as the abstraction. 
The bridge pattern can also be thought of as two layers of abstraction.







"
101,0,flyweight_pattern,"
The Flyweight pattern reduces the number of low-level,  detailed objects within a system by sharing objects.
If instances of a class that contain the same information can be used interchangeably,  the Flyweight pattern allows a program to avoid the expense of multiple instances that contain the same information by sharing one instance. The figure below illustrates the Flyweight pattern.

The Flyweight pattern defines a structure for sharing objects.  Objects are shared for at least two reasons: 1) efficiency and 2) consistency. The Flyweight pattern focuses on sharing for space efficiency.  Applications that use lots of objects must pay careful attention to the cost of each object. Substantial savings can be achieved by sharing objects instead of replicating them.  
But objects can be shared only if they do not define context-dependent state. 
Flyweight objects have no such state. Any additional information they need to perform their task is passed to them when needed. 
Because they have no context-dependent state, Flyweight objects may be shared freely.

The following lists the benefits of using the Flyweight pattern:

Reduction in the number of objects to handle
Reduction in memory and on storage devices, if the objects are persisted


You should use the Flyweight pattern when all of the following are  true.

The application uses a large number of objects.
Storage costs are high because of the quantity of objects.
The application does not depend on object identity.








"
102,0,proxy_pattern,"
The Proxy pattern provides a surrogate or placeholder object to control access to the original object.
There are several types of implementations of the Proxy pattern with the

Remote proxy and
Virtual proxy
being the most common.
 
The figure below illustrates the Proxy pattern.

You are currently designing your own Desktop Publishing application, as you have not found any that do exactly what you want with existing applications. 
As part of the design you are using a Controller to which you send all GUI requests.
Not all objects can process the same commands. For example you cannot select the spell check tool when an image has the focus. 
To stop any possible errors you would like to filter out some of the messages as they are passed from these objects to the Controller object. What pattern could you use?
In this scenario what you are essentially trying to do is filter all packets that don't meet a certain set of requirements. This behavior is just like a Proxy server dropping packets from certain IP address etc.

A Remote proxy can hide the fact that an object resides in a different address space
A virtual proxy can perform optimizations, such as creating an object on demand.

You should use the proxy pattern when: 
You need a more versatile or sophisticated reference to an object than a simple pointer.







"
103,0,memento_pattern,"
The Memento pattern[1] contains a snapshot of the state of an object, so that the object can return to its original state without having to reveal its content to the rest of the world.
The figure below illustrates the Memento pattern. 

The following lists the benefits of using the Memento pattern:

Preserves encapsulation boundaries
Simplifies the originator


You should use the Memento pattern when:

A snapshot of an object's state must be saved so that it can be restored to that state later.
Using a direct interface to obtain the state would expose implementation details and break the object's encapsulation.

[1]memento: an object kept as a reminder or souvenir of a person or event.







"
104,0,interpreter_pattern,"
The Interpreter pattern interprets a language to define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language. The following diagram illustrates the Interpreter pattern.
The following lists the benefits of using the Interpreter pattern:

Easy to change and extend the grammar
Implementing the grammar is easy


You should use the Interpreter pattern when:

The grammar of the language is simple.
Efficiency is not a critical concern.


Interpreter Pattern: Useful when the objective is to provide a client program or a user the ability to specify operations in a simple language. Helps in interpreting operations specified using a language, using its grammar. More suitable for languages with simple grammar







"
105,0,iterator_pattern,"
The iterator pattern provides a consistent way to sequentially access items in a collection that is independent of and separate from the underlying collection. The figure below represents the iterator pattern.


Supports variations in the traversal of a collection
Simplifies the interface of the collection.


You should use the Interpreter pattern when you want to:

Access a collection object’s contents without exposing its internal representation.
Support multiple traversals of objects in a collection.
Provide a uniform interface for traversing different structures in a collection.


In object-oriented programming, the iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container's elements.  The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and cannot be decoupled. For example, the hypothetical algorithm SearchForElement can be implemented generally using a specified type of iterator rather than implementing it as a container-specific algorithm. 
This allows SearchForElement to be used on any container that supports the required type of iterator.







"
106,0,observer_pattern,"
The Observer pattern provides a way for a component to flexibly broadcast messages to interested receivers. 
It defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. The Figure below illustrates the Observer pattern.
The following lists the benefits of using the Observer pattern:

Abstract coupling between subject and observer
Support for broadcast communication


You should use the Observer pattern when:

A change to one object requires changing the other object and you do not know how many objects need to change.
 An object should be able to notify other objects without making assumptions about the identity of those objects.








"
107,0,command_pattern,"
The Command pattern encapsulates a request in an object, which enables you to store the command, pass the command to a method, and return the command like any other object.  The figure below illustrates the Command Pattern.

The following lists the benefits of using the Command Pattern:

Separates the object that invokes the operation from the one that knows how to perform it.
 It's easy to add new commands, because you don't have to change existing classes.


You should use the Command pattern when:

You want to parameterize objects by an action to perform.
You specify, queue, and execute requests at different times. 
You must support undo, logging, or transactions








"
108,0,mediator_pattern,"
The Mediator pattern simplifies communication among objects in a system by introducing a single object that manages message distribution among other objects. The Mediator pattern promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently. The diagram below illustrates the Mediator pattern.

The following lists the benefits of using the Mediator pattern:

Decouples colleagues
Simplifies object protocols
Centralizes Control
The individual components become simpler and easier to deal with, because they no longer need to directly pass messages to each other
Components are more generic, because they no longer need to contain logic to deal with their communication with other components.


You should use the Mediator pattern when:

A set of objects communicate in well-defined but complex ways.
You want to customize a behavior that's distributed between several objects without using subclasses.

"
109,0,chain_of_responsibility,"
The Chain of Responsibility pattern establishes a chain within a system, so that a message can either be handled at the level where it is first received, or be directed to an object that can handle it.

The following lists the benefits of using the Chain of Responsibility pattern:

Reduced coupling
Added flexibility in assigning responsibilites to objects
Allows a set of classes to behave as a whole, because events produced in one class can be sent on to other handler classes within the composite. 


You should use the Chain of Responsibility Pattern when:

More  than one object can handle a request, and the handler is not known.
You want to issue a request to one of several objects without specifying the receiver completely.
The set of objects that can handle a request should be specified dynamically.


In Object Oriented Design, the chain-of-responsibility pattern is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain. 
A mechanism also exists for adding new processing objects to the end of this chain. In a variation of the standard chain-of-responsibility model, some handlers may act as dispatchers, capable of sending commands out in a variety of directions, forming a tree of responsibility. 
In some cases, this can occur recursively, with processing objects calling higher-up processing objects with commands that attempt to solve some smaller part of the problem; in this case recursion continues until the command is processed, or the entire tree has been explored. An XML interpreter might work in this manner. 

This pattern promotes the idea of loose coupling, which is considered a programming best practice.
"
110,0,state_pattern,"
The State pattern allows an object to alter its behavior when its internal state changes. The object appears to change its class. The Figure illustrates the State Pattern. 
The following lists the benefits of using the State pattern:

Localizes state-specific behavior and partitions behavior for different states .
Make state transitions explicit.


You should use the State pattern when:

An object's behavior depends on its state and it must change its behavior at run-time depending on that state.
Operations have large conditional statements that consist of multiple states and depend on the object's state.

"
111,0,externalize_stack_pattern,"Rewrite a recursive program/algorithm/function into an iterative one which uses an external stack.

All computer scientists are familiar with recursion and many consider it an alternative way of implementing iteration.
Algorithms that use iteration must repeat some computation.  
However, recursive algorithms, when written with the consideration of performance, can consume a valuable resource, namely theStack.

In languages which use stacks to maintain activation records, which include

C ,
C++, and 
Java

not including Smalltalk.
Some recursive algorithms exhibit TailRecursion and can be rewritten in an iterative way that uses bounded space 
(and some compilers, especially of functional languages, will perform this transformation as an optimization). 
However, many recursive algorithms are not tail-recursive. 
The most natural way to express recursive algorithms is with recursive function calls; 
each instance of the function gets its own activation record to maintain its particular state, while TheStack holds the complete set.

The challenges with a Stack in many languages (or the stacks in multithreaded programs) are as follows:

In addition to holding the state which must be kept recursively, all other states (local variables) as well as tracking information for repeated function calls is held on the stack.  
Wastes memory 
Would not be too much of a problem, except for the following fact.
Program stacks often must occupy contiguous address space. 
The remaining contiguous address space above the top of the stack is far less than the the total remaining system memory (physical and virtual).  On many systems, the stack grows downward from the top of your address space. 
Thus, the stack and the heap have exactly the same remaining memory available.

Figure out what state must be maintained between successive invocations of the function. 
Define a structure to hold that (and only that) state.  Declare a stack (or a linked list, or whatever you have available) (a linked list is one possible implementation of the abstract data type stack,  not something to be seen as an alternative to a stack) 
of that structure.  Use it to hold the stacked copies of the recursive state.  
Then rewrite the remainder of the function to be iterative. 
In the case of Java serialization, and many other graph tree traversal algorithms, the only thing that needs to be maintained in recursive fashion is a BackPointer, which is a pointer to the previous node.







"
112,0,template_pattern,"
The Template Method pattern provides a method that allows subclasses to override parts of the method without rewriting it.  Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the structure of the algorithm. 
The figure below illustrates the Template pattern.

The following lists the benefits of using the Template pattern:
Fundamental technique for reusing code 

You should use the Template pattern when:

 You want to implement the invariant parts of an algorithm once and use subclasses to implement the behavior that can vary.
When common behavior among subclasses should be factored and localized in a common class to avoid code duplication. 

"
113,0,hierarchical_visitor_pattern,"
Provide a way to visit every node in a hierarchical data structure such as a tree.
Represent an operation to be performed on the nodes of a hierarchical object structure. 
Hierarchical Visitor lets one define new operations without changing the classes of the nodes on which it operates.  
Hierarchical Visitor overcomes the limitations of the traditional VisitorPattern by allowing a programmer to track traversal depth and short-circuit branch traversal.

Consider a file system represented using a hierarchical structure, such as that provided by the CompositePattern. 
The file objects are leaf nodes and the directories are the composite nodes. Now consider two operations on a file system: 

fully qualifying a file name and 
searching for a specific  file.


To fully qualify a file name, we must traverse each of its parent composites. To do this, we start with a string representing the root composite, and concatenate each child composite until we reach the actual file object.
We need to determine what composites (directories) are children of the root and which are its siblings. 
This requires we track when we are entering a composite and leaving a composite. If we enter the composite bar before we have left the composite foo, we know we have ""foo/bar"". However, if we leave foo before entering bar then foo and bar are siblings. 
This is quite impossible if equipped only with the traditional VisitorPattern as it only tells us when we are entering a composite node.

To search a file system optimally, we need to take advantage of fully qualified names. If we are searching for root/foo2/bar3/file.dat, we do not need to search through the branches 

root/foo1/*,  
""root/foo2/bar1/*"", or even 
""root/foo2/bar2/*"".

Unfortunately, because the traditional VisitorPattern does not have the ability to conditionally traverse a hierarchical structure, we are left with only two choices. 
(a) use an alternative means of traversal or (b) search even those branches that have no possibility of a match. 
These two examples summarize the advantages of the HierarchicalVisitorPattern. 
One no longer needs to rely on multiple traversal techniques when the limitations of the traditional visitor pattern must be exceeded. 
We can generalize these limitations as:

hierarchical navigation: the traditional VisitorPattern has no concept of depth. As a result, visitor cannot determine if one composite is within another composite or beside it.
conditional navigation: the traditional VisitorPattern does not allow branches to be skipped. As a result, visitor cannot stop, filter, or optimize  traversal based on some condition. 







"
114,0,strategy_pattern,"
The intent of the Strategy Pattern is to define a family of algorithms, encapsulate each algorithm, and make them interchangeable. 
The Strategy Pattern lets the algorithm vary independently from clients that use it.
In addition the pattern, defines a group of classes that represent a set of possible behaviors. 
These behaviors can then be used in an application to change its functionality.
The figure below illustrates the Strategy pattern.
The following lists the benefits of using the Strategy pattern:

An alternative to subclassing
Defines each behavior in its own class, which eliminates conditional statements
Easier to extend a model to incorporate new behaviors without recoding the application 

You should use the Strategy pattern when:

Many related classes differ only in their behavior.
You need different variants of an algorithm.
An algorithm uses data unknown to clients.








"
115,0,abstract_factory,"

A family of related products, say: Chair + Sofa + CoffeeTable.


Several variants of this family. For example, products Chair + Sofa + CoffeeTable are available in these variants: Modern, Victorian, ArtDeco.






Abstract Products declare interfaces for a set of distinct but related products which make up a product family.


Concrete Products are various implementations of abstract products, grouped by variants. Each abstract product (chair/sofa) must be implemented in all given variants (Victorian/Modern).


The Abstract Factory interface declares a set of methods for creating each of the abstract products.


Concrete Factories implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.


Although concrete factories instantiate concrete products, signatures of their creation methods must return corresponding abstract products. This way the client code that uses a factory doesn’t get coupled to the specific variant of the product it gets from a factory. The Client can work with any concrete factory/product variant, as long as it communicates with their objects via abstract interfaces.




 Use the Abstract Factory when your code needs to work with various families of related products, but you don’t want it to depend on the concrete classes of those products—they might be unknown beforehand or you simply want to allow for future extensibility.

 The Abstract Factory provides you with an interface for creating objects from each class of the product family. As long as your code creates objects via this interface, you don’t have to worry about creating the wrong variant of a product which doesn’t match the products already created by your app.


 Consider implementing the Abstract Factory when you have a class with a set of Factory Methods that blur its primary responsibility.

 In a well-designed program each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.



Map out a matrix of distinct product types versus variants of these products.


Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.


Declare the abstract factory interface with a set of creation methods for all abstract products.


Implement a set of concrete factory classes, one for each product variant.


Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.


Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.




 You can be sure that the products you’re getting from a factory are compatible with each other.

 You avoid tight coupling between concrete products and client code.

 Single Responsibility Principle. You can extract the product creation code into one place, making the code easier to support.

 Open/Closed Principle. You can introduce new variants of products without breaking existing client code.




 The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.


Read our Factory Comparison to learn more about the differences between various factory patterns and concepts.
"
116,0,singleton,"

Ensure that a class has just a single instance. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource—for example, a database or a file.
Here’s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you’ll get the one you already created.
Note that this behavior is impossible to implement with a regular constructor since a constructor call must always return a new object by design.


Make the default constructor private, to prevent other objects from using the new operator with the Singleton class.
Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.





The Singleton class declares the static method getInstance that returns the same instance of its own class.
The Singleton’s constructor should be hidden from the client code. Calling the getInstance method should be the only way of getting the Singleton object.




 Use the Singleton pattern when a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program.

 The Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created.


 Use the Singleton pattern when you need stricter control over global variables.

 Unlike global variables, the Singleton pattern guarantees that there’s just one instance of a class. Nothing, except for the Singleton class itself, can replace the cached instance.
Note that you can always adjust this limitation and allow creating any number of Singleton instances. The only piece of code that needs changing is the body of the getInstance method.



Add a private static field to the class for storing the singleton instance.


Declare a public static creation method for getting the singleton instance.


Implement “lazy initialization” inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.


Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.


Go over the client code and replace all direct calls to the singleton’s constructor with calls to its static creation method.




 You can be sure that a class has only a single instance.

 You gain a global access point to that instance.

 The singleton object is initialized only when it’s requested for the first time.




 Violates the Single Responsibility Principle. The pattern solves two problems at the time.

 The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other.

 The pattern requires special treatment in a multithreaded environment so that multiple threads won’t create a singleton object several times.

 It may be difficult to unit test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don’t write the tests. Or don’t use the Singleton pattern.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.



Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
117,0,composite,"




The Component interface describes operations that are common to both simple and complex elements of the tree.


The Leaf is a basic element of a tree that doesn’t have sub-elements.
Usually, leaf components end up doing most of the real work, since they don’t have anyone to delegate the work to.


The Container (aka composite) is an element that has sub-elements: leaves or other containers. A container doesn’t know the concrete classes of its children. It works with all sub-elements only via the component interface.
Upon receiving a request, a container delegates the work to its sub-elements, processes intermediate results and then returns the final result to the client.


The Client works with all elements through the component interface. As a result, the client can work in the same way with both simple or complex elements of the tree.




 Use the Composite pattern when you have to implement a tree-like object structure.

 The Composite pattern provides you with two basic element types that share a common interface: simple leaves and complex containers. A container can be composed of both leaves and other containers. This lets you construct a nested recursive object structure that resembles a tree.


 Use the pattern when you want the client code to treat both simple and complex elements uniformly.

 All elements defined by the Composite pattern share a common interface. Using this interface, the client doesn’t have to worry about the concrete class of the objects it works with.



Make sure that the core model of your app can be represented as a tree structure. Try to break it down into simple elements and containers. Remember that containers must be able to contain both simple elements and other containers.


Declare the component interface with a list of methods that make sense for both simple and complex components.


Create a leaf class to represent simple elements. A program may have multiple different leaf classes.


Create a container class to represent complex elements. In this class, provide an array field for storing references to sub-elements. The array must be able to store both leaves and containers, so make sure it’s declared with the component interface type.
While implementing the methods of the component interface, remember that a container is supposed to be delegating most of the work to sub-elements.


Finally, define the methods for adding and removal of child elements in the container.
Keep in mind that these operations can be declared in the component interface. This would violate the Interface Segregation Principle because the methods will be empty in the leaf class. However, the client will be able to treat all the elements equally, even when composing the tree.




 You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage.

 Open/Closed Principle. You can introduce new element types into the app without breaking the existing code, which now works with the object tree.




 It might be difficult to provide a common interface for classes whose functionality differs too much. In certain scenarios, you’d need to overgeneralize the component interface, making it harder to comprehend.



You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.


Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.


You can use Iterators to traverse Composite trees.


You can use Visitor to execute an operation over an entire Composite tree.


You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.
A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.
However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.

"
118,0,facade,"




The Facade provides convenient access to a particular part of the subsystem’s functionality. It knows where to direct the client’s request and how to operate all the moving parts.


An Additional Facade class can be created to prevent polluting a single facade with unrelated features that might make it yet another complex structure. Additional facades can be used by both clients and other facades.


The Complex Subsystem consists of dozens of various objects. To make them all do something meaningful, you have to dive deep into the subsystem’s implementation details, such as initializing objects in the correct order and supplying them with data in the proper format.
Subsystem classes aren’t aware of the facade’s existence. They operate within the system and work with each other directly.


The Client uses the facade instead of calling the subsystem objects directly.




 Use the Facade pattern when you need to have a limited but straightforward interface to a complex subsystem.

 Often, subsystems get more complex over time. Even applying design patterns typically leads to creating more classes. A subsystem may become more flexible and easier to reuse in various contexts, but the amount of configuration and boilerplate code it demands from a client grows ever larger. The Facade attempts to fix this problem by providing a shortcut to the most-used features of the subsystem which fit most client requirements.


 Use the Facade when you want to structure a subsystem into layers.

 Create facades to define entry points to each level of a subsystem. You can reduce coupling between multiple subsystems by requiring them to communicate only through facades.
For example, let’s return to our video conversion framework. It can be broken down into two layers: video- and audio-related. For each layer, you can create a facade and then make the classes of each layer communicate with each other via those facades. This approach looks very similar to the Mediator pattern.



Check whether it’s possible to provide a simpler interface than what an existing subsystem already provides. You’re on the right track if this interface makes the client code independent from many of the subsystem’s classes.


Declare and implement this interface in a new facade class. The facade should redirect the calls from the client code to appropriate objects of the subsystem. The facade should be responsible for initializing the subsystem and managing its further life cycle unless the client code already does this.


To get the full benefit from the pattern, make all the client code communicate with the subsystem only via the facade. Now the client code is protected from any changes in the subsystem code. For example, when a subsystem gets upgraded to a new version, you will only need to modify the code in the facade.


If the facade becomes too big, consider extracting part of its behavior to a new, refined facade class.




 You can isolate your code from the complexity of a subsystem.




 A facade can become a god object coupled to all classes of an app.



Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.


Facade defines a simplified interface to a subsystem of objects, but it doesn’t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

Mediator centralizes communication between components of the system. The components only know about the mediator object and don’t communicate directly.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.

"
119,0,flyweight,"Extrinsic state storageFlyweight and immutabilityFlyweight factory




The Flyweight pattern is merely an optimization. Before applying it, make sure your program does have the RAM consumption problem related to having a massive number of similar objects in memory at the same time. Make sure that this problem can’t be solved in any other meaningful way.


The Flyweight class contains the portion of the original object’s state that can be shared between multiple objects. The same flyweight object can be used in many different contexts. The state stored inside a flyweight is called intrinsic. The state passed to the flyweight’s methods is called extrinsic.


The Context class contains the extrinsic state, unique across all original objects. When a context is paired with one of the flyweight objects, it represents the full state of the original object.


Usually, the behavior of the original object remains in the flyweight class. In this case, whoever calls a flyweight’s method must also pass appropriate bits of the extrinsic state into the method’s parameters. On the other hand, the behavior can be moved to the context class, which would use the linked flyweight merely as a data object.


The Client calculates or stores the extrinsic state of flyweights. From the client’s perspective, a flyweight is a template object which can be configured at runtime by passing some contextual data into parameters of its methods.


The Flyweight Factory manages a pool of existing flyweights. With the factory, clients don’t create flyweights directly. Instead, they call the factory, passing it bits of the intrinsic state of the desired flyweight. The factory looks over previously created flyweights and either returns an existing one that matches search criteria or creates a new one if nothing is found.




 Use the Flyweight pattern only when your program must support a huge number of objects which barely fit into available RAM.

 The benefit of applying the pattern depends heavily on how and where it’s used. It’s most useful when:

an application needs to spawn a huge number of similar objects
this drains all available RAM on a target device
the objects contain duplicate states which can be extracted and shared between multiple objects




Divide fields of a class that will become a flyweight into two parts:

the intrinsic state: the fields that contain unchanging data duplicated across many objects
the extrinsic state: the fields that contain contextual data unique to each object



Leave the fields that represent the intrinsic state in the class, but make sure they’re immutable. They should take their initial values only inside the constructor.


Go over methods that use fields of the extrinsic state. For each field used in the method, introduce a new parameter and use it instead of the field.


Optionally, create a factory class to manage the pool of flyweights. It should check for an existing flyweight before creating a new one. Once the factory is in place, clients must only request flyweights through it. They should describe the desired flyweight by passing its intrinsic state to the factory.


The client must store or calculate values of the extrinsic state (context) to be able to call methods of flyweight objects. For the sake of convenience, the extrinsic state along with the flyweight-referencing field may be moved to a separate context class.




 You can save lots of RAM, assuming your program has tons of similar objects.




 You might be trading RAM over CPU cycles when some of the context data needs to be recalculated each time somebody calls a flyweight method.

 The code becomes much more complicated. New team members will always be wondering why the state of an entity was separated in such a way.



You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.


"
120,0,template_method,"

abstract steps must be implemented by every subclass

optional steps already have some default implementation, but still can be overridden if needed





The Abstract Class declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order. The steps may either be declared abstract or have some default implementation.


Concrete Classes can override all of the steps, but not the template method itself.




 Use the Template Method pattern when you want to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure.

 The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass.


 Use the pattern when you have several classes that contain almost identical algorithms with some minor differences. As a result, you might need to modify all classes when the algorithm changes.

 When you turn such an algorithm into a template method, you can also pull up the steps with similar implementations into a superclass, eliminating code duplication. Code that varies between subclasses can remain in subclasses.



Analyze the target algorithm to see whether you can break it into steps. Consider which steps are common to all subclasses and which ones will always be unique.


Create the abstract base class and declare the template method and a set of abstract methods representing the algorithm’s steps. Outline the algorithm’s structure in the template method by executing corresponding steps. Consider making the template method final to prevent subclasses from overriding it.


It’s okay if all the steps end up being abstract. However, some steps might benefit from having a default implementation. Subclasses don’t have to implement those methods.


Think of adding hooks between the crucial steps of the algorithm.


For each variation of the algorithm, create a new concrete subclass. It must implement all of the abstract steps, but may also override some of the optional ones.




 You can let clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm.

 You can pull the duplicate code into a superclass.




 Some clients may be limited by the provided skeleton of an algorithm.

 You might violate the Liskov Substitution Principle by suppressing a default step implementation via a subclass.

 Template methods tend to be harder to maintain the more steps they have.



Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.


Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object’s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it’s static. Strategy works on the object level, letting you switch behaviors at runtime.

"
121,0,visitor,"
If it’s a residential building, he sells medical insurance.
If it’s a bank, he sells theft insurance.
If it’s a coffee shop, he sells fire and flood insurance.





The Visitor interface declares a set of visiting methods that can take concrete elements of an object structure as arguments. These methods may have the same names if the program is written in a language that supports overloading, but the type of their parameters must be different.


Each Concrete Visitor implements several versions of the same behaviors, tailored for different concrete element classes.


The Element interface declares a method for “accepting” visitors. This method should have one parameter declared with the type of the visitor interface.


Each Concrete Element must implement the acceptance method. The purpose of this method is to redirect the call to the proper visitor’s method corresponding to the current element class. Be aware that even if a base element class implements this method, all subclasses must still override this method in their own classes and call the appropriate method on the visitor object.


The Client usually represents a collection or some other complex object (for example, a Composite tree). Usually, clients aren’t aware of all the concrete element classes because they work with objects from that collection via some abstract interface.




 Use the Visitor when you need to perform an operation on all elements of a complex object structure (for example, an object tree).

 The Visitor pattern lets you execute an operation over a set of objects with different classes by having a visitor object implement several variants of the same operation, which correspond to all target classes.


 Use the Visitor to clean up the business logic of auxiliary behaviors.

 The pattern lets you make the primary classes of your app more focused on their main jobs by extracting all other behaviors into a set of visitor classes.


 Use the pattern when a behavior makes sense only in some classes of a class hierarchy, but not in others.

 You can extract this behavior into a separate visitor class and implement only those visiting methods that accept objects of relevant classes, leaving the rest empty.



Declare the visitor interface with a set of “visiting” methods, one per each concrete element class that exists in the program.


Declare the element interface. If you’re working with an existing element class hierarchy, add the abstract “acceptance” method to the base class of the hierarchy. This method should accept a visitor object as an argument.


Implement the acceptance methods in all concrete element classes. These methods must simply redirect the call to a visiting method on the incoming visitor object which matches the class of the current element.


The element classes should only work with visitors via the visitor interface. Visitors, however, must be aware of all concrete element classes, referenced as parameter types of the visiting methods.


For each behavior that can’t be implemented inside the element hierarchy, create a new concrete visitor class and implement all of the visiting methods.
You might encounter a situation where the visitor will need access to some private members of the element class. In this case, you can either make these fields or methods public, violating the element’s encapsulation, or nest the visitor class in the element class. The latter is only possible if you’re lucky to work with a programming language that supports nested classes.


The client must create visitor objects and pass them into elements via “acceptance” methods.




 Open/Closed Principle. You can introduce a new behavior that can work with objects of different classes without changing these classes.

 Single Responsibility Principle. You can move multiple versions of the same behavior into the same class.

 A visitor object can accumulate some useful information while working with various objects. This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure.




 You need to update all visitors each time a class gets added to or removed from the element hierarchy.

 Visitors might lack the necessary access to the private fields and methods of the elements that they’re supposed to work with.



You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.


You can use Visitor to execute an operation over an entire Composite tree.


You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.


Puzzled why we can’t simply replace the Visitor pattern with method overloading? Read my article Visitor and Double Dispatch to learn about the nasty details.
"
122,0,factory_method,"




The Product declares the interface, which is common to all objects that can be produced by the creator and its subclasses.


Concrete Products are different implementations of the product interface.


The Creator class declares the factory method that returns new product objects. It’s important that the return type of this method matches the product interface.
You can declare the factory method as abstract to force all subclasses to implement their own versions of the method. As an alternative, the base factory method can return some default product type.
Note, despite its name, product creation is not the primary responsibility of the creator. Usually, the creator class already has some core business logic related to products. The factory method helps to decouple this logic from the concrete product classes. Here is an analogy: a large software development company can have a training department for programmers. However, the primary function of the company as a whole is still writing code, not producing programmers.


Concrete Creators override the base factory method so it returns a different type of product.
Note that the factory method doesn’t have to create new instances all the time. It can also return existing objects from a cache, an object pool, or another source.




 Use the Factory Method when you don’t know beforehand the exact types and dependencies of the objects your code should work with.

 The Factory Method separates product construction code from the code that actually uses the product. Therefore it’s easier to extend the product construction code independently from the rest of the code.
For example, to add a new product type to the app, you’ll only need to create a new creator subclass and override the factory method in it.


 Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.

 Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component?
The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself.
Let’s see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard Button class with a glorious RoundButton subclass. But now you need to tell the main UIFramework class to use the new button subclass instead of a default one.
To achieve this, you create a subclass UIWithRoundButtons from a base framework class and override its createButton method. While this method returns Button objects in the base class, you make your subclass return RoundButton objects. Now use the UIWithRoundButtons class instead of UIFramework. And that’s about it!


 Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time.

 You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources.
Let’s think about what has to be done to reuse an existing object:

First, you need to create some storage to keep track of all of the created objects.
When someone requests an object, the program should look for a free object inside that pool.
… and then return it to the client code.
If there are no free objects, the program should create a new one (and add it to the pool).

That’s a lot of code! And it must all be put into a single place so that you don’t pollute the program with duplicate code.
Probably the most obvious and convenient place where this code could be placed is the constructor of the class whose objects we’re trying to reuse. However, a constructor must always return new objects by definition. It can’t return existing instances.
Therefore, you need to have a regular method capable of creating new objects as well as reusing existing ones. That sounds very much like a factory method.



Make all products follow the same interface. This interface should declare methods that make sense in every product.


Add an empty factory method inside the creator class. The return type of the method should match the common product interface.


In the creator’s code find all references to product constructors. One by one, replace them with calls to the factory method, while extracting the product creation code into the factory method.
You might need to add a temporary parameter to the factory method to control the type of returned product.
At this point, the code of the factory method may look pretty ugly. It may have a large switch statement that picks which product class to instantiate. But don’t worry, we’ll fix it soon enough.


Now, create a set of creator subclasses for each type of product listed in the factory method. Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.


If there are too many product types and it doesn’t make sense to create subclasses for all of them, you can reuse the control parameter from the base class in subclasses.
For instance, imagine that you have the following hierarchy of classes: the base Mail class with a couple of subclasses: AirMail and GroundMail; the Transport classes are Plane, Truck and Train. While the AirMail class only uses Plane objects, GroundMail may work with both Truck and Train objects. You can create a new subclass (say TrainMail) to handle both cases, but there’s another option. The client code can pass an argument to the factory method of the GroundMail class to control which product it wants to receive.


If, after all of the extractions, the base factory method has become empty, you can make it abstract. If there’s something left, you can make it a default behavior of the method.




 You avoid tight coupling between the creator and the concrete products.

 Single Responsibility Principle. You can move the product creation code into one place in the program, making the code easier to support.

 Open/Closed Principle. You can introduce new types of products into the program without breaking existing client code.




 The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern. The best case scenario is when you’re introducing the pattern into an existing hierarchy of creator classes.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.


Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.


Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.


Read our Factory Comparison if you can’t figure out the difference between various factory patterns and concepts.
"
123,0,abstract_factory,"

A family of related products, say: Chair + Sofa + CoffeeTable.


Several variants of this family. For example, products Chair + Sofa + CoffeeTable are available in these variants: Modern, Victorian, ArtDeco.






Abstract Products declare interfaces for a set of distinct but related products which make up a product family.


Concrete Products are various implementations of abstract products, grouped by variants. Each abstract product (chair/sofa) must be implemented in all given variants (Victorian/Modern).


The Abstract Factory interface declares a set of methods for creating each of the abstract products.


Concrete Factories implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.


Although concrete factories instantiate concrete products, signatures of their creation methods must return corresponding abstract products. This way the client code that uses a factory doesn’t get coupled to the specific variant of the product it gets from a factory. The Client can work with any concrete factory/product variant, as long as it communicates with their objects via abstract interfaces.




 Use the Abstract Factory when your code needs to work with various families of related products, but you don’t want it to depend on the concrete classes of those products—they might be unknown beforehand or you simply want to allow for future extensibility.

 The Abstract Factory provides you with an interface for creating objects from each class of the product family. As long as your code creates objects via this interface, you don’t have to worry about creating the wrong variant of a product which doesn’t match the products already created by your app.


 Consider implementing the Abstract Factory when you have a class with a set of Factory Methods that blur its primary responsibility.

 In a well-designed program each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.



Map out a matrix of distinct product types versus variants of these products.


Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.


Declare the abstract factory interface with a set of creation methods for all abstract products.


Implement a set of concrete factory classes, one for each product variant.


Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.


Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.




 You can be sure that the products you’re getting from a factory are compatible with each other.

 You avoid tight coupling between concrete products and client code.

 Single Responsibility Principle. You can extract the product creation code into one place, making the code easier to support.

 Open/Closed Principle. You can introduce new variants of products without breaking existing client code.




 The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.


Read our Factory Comparison to learn more about the differences between various factory patterns and concepts.
"
124,0,composite,"




The Component interface describes operations that are common to both simple and complex elements of the tree.


The Leaf is a basic element of a tree that doesn’t have sub-elements.
Usually, leaf components end up doing most of the real work, since they don’t have anyone to delegate the work to.


The Container (aka composite) is an element that has sub-elements: leaves or other containers. A container doesn’t know the concrete classes of its children. It works with all sub-elements only via the component interface.
Upon receiving a request, a container delegates the work to its sub-elements, processes intermediate results and then returns the final result to the client.


The Client works with all elements through the component interface. As a result, the client can work in the same way with both simple or complex elements of the tree.




 Use the Composite pattern when you have to implement a tree-like object structure.

 The Composite pattern provides you with two basic element types that share a common interface: simple leaves and complex containers. A container can be composed of both leaves and other containers. This lets you construct a nested recursive object structure that resembles a tree.


 Use the pattern when you want the client code to treat both simple and complex elements uniformly.

 All elements defined by the Composite pattern share a common interface. Using this interface, the client doesn’t have to worry about the concrete class of the objects it works with.



Make sure that the core model of your app can be represented as a tree structure. Try to break it down into simple elements and containers. Remember that containers must be able to contain both simple elements and other containers.


Declare the component interface with a list of methods that make sense for both simple and complex components.


Create a leaf class to represent simple elements. A program may have multiple different leaf classes.


Create a container class to represent complex elements. In this class, provide an array field for storing references to sub-elements. The array must be able to store both leaves and containers, so make sure it’s declared with the component interface type.
While implementing the methods of the component interface, remember that a container is supposed to be delegating most of the work to sub-elements.


Finally, define the methods for adding and removal of child elements in the container.
Keep in mind that these operations can be declared in the component interface. This would violate the Interface Segregation Principle because the methods will be empty in the leaf class. However, the client will be able to treat all the elements equally, even when composing the tree.




 You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage.

 Open/Closed Principle. You can introduce new element types into the app without breaking the existing code, which now works with the object tree.




 It might be difficult to provide a common interface for classes whose functionality differs too much. In certain scenarios, you’d need to overgeneralize the component interface, making it harder to comprehend.



You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.


Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.


You can use Iterators to traverse Composite trees.


You can use Visitor to execute an operation over an entire Composite tree.


You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.
A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.
However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.

"
125,0,builder,"Director




The Builder interface declares product construction steps that are common to all types of builders.


Concrete Builders provide different implementations of the construction steps. Concrete builders may produce products that don’t follow the common interface.


Products are resulting objects. Products constructed by different builders don’t have to belong to the same class hierarchy or interface.


The Director class defines the order in which to call construction steps, so you can create and reuse specific configurations of products.


The Client must associate one of the builder objects with the director. Usually, it’s done just once, via parameters of the director’s constructor. Then the director uses that builder object for all further construction. However, there’s an alternative approach for when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.




 Use the Builder pattern to get rid of a “telescoping constructor”.

 Say you have a constructor with ten optional parameters. Calling such a beast is very inconvenient; therefore, you overload the constructor and create several shorter versions with fewer parameters. These constructors still refer to the main one, passing some default values into any omitted parameters.

class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...


Creating such a monster is only possible in languages that support method overloading, such as C# or Java.


The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don’t have to cram dozens of parameters into your constructors anymore.


 Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).

 The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details.
The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction.


 Use the Builder to construct Composite trees or other complex objects.

 The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree.
A builder doesn’t expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result.



Make sure that you can clearly define the common construction steps for building all available product representations. Otherwise, you won’t be able to proceed with implementing the pattern.


Declare these steps in the base builder interface.


Create a concrete builder class for each of the product representations and implement their construction steps.
Don’t forget about implementing a method for fetching the result of the construction. The reason why this method can’t be declared inside the builder interface is that various builders may construct products that don’t have a common interface. Therefore, you don’t know what would be the return type for such a method. However, if you’re dealing with products from a single hierarchy, the fetching method can be safely added to the base interface.


Think about creating a director class. It may encapsulate various ways to construct a product using the same builder object.


The client code creates both the builder and the director objects. Before construction starts, the client must pass a builder object to the director. Usually, the client does this only once, via parameters of the director’s class constructor. The director uses the builder object in all further construction. There’s an alternative approach, where the builder is passed to a specific product construction method of the director.


The construction result can be obtained directly from the director only if all products follow the same interface. Otherwise, the client should fetch the result from the builder.




 You can construct objects step-by-step, defer construction steps or run steps recursively.

 You can reuse the same construction code when building various representations of products.

 Single Responsibility Principle. You can isolate complex construction code from the business logic of the product.




 The overall complexity of the code increases since the pattern requires creating multiple new classes.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.


You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.


You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
126,0,prototype,"
Basic implementation






The Prototype interface declares the cloning methods. In most cases, it’s a single clone method.


The Concrete Prototype class implements the cloning method. In addition to copying the original object’s data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies, etc.


The Client can produce a copy of any object that follows the prototype interface.

Prototype registry implementation






The Prototype Registry provides an easy way to access frequently-used prototypes. It stores a set of pre-built objects that are ready to be copied. The simplest prototype registry is a name → prototype hash map. However, if you need better search criteria than a simple name, you can build a much more robust version of the registry.




 Use the Prototype pattern when your code shouldn’t depend on the concrete classes of objects that you need to copy.

 This happens a lot when your code works with objects passed to you from 3rd-party code via some interface. The concrete classes of these objects are unknown, and you couldn’t depend on them even if you wanted to.
The Prototype pattern provides the client code with a general interface for working with all objects that support cloning. This interface makes the client code independent from the concrete classes of objects that it clones.


 Use the pattern when you want to reduce the number of subclasses that only differ in the way they initialize their respective objects.

 Suppose you have a complex class that requires a laborious configuration before it can be used. There are several common ways to configure this class, and this code is scattered through your app. To reduce the duplication, you create several subclasses and put every common configuration code into their constructors. You solved the duplication problem, but now you have lots of dummy subclasses.
The Prototype pattern lets you use a set of pre-built objects configured in various ways as prototypes. Instead of instantiating a subclass that matches some configuration, the client can simply look for an appropriate prototype and clone it.



Create the prototype interface and declare the clone method in it. Or just add the method to all classes of an existing class hierarchy, if you have one.


A prototype class must define the alternative constructor that accepts an object of that class as an argument. The constructor must copy the values of all fields defined in the class from the passed object into the newly created instance. If you’re changing a subclass, you must call the parent constructor to let the superclass handle the cloning of its private fields.
If your programming language doesn’t support method overloading, you won’t be able to create a separate “prototype” constructor. Thus, copying the object’s data into the newly created clone will have to be performed within the clone method. Still, having this code in a regular constructor is safer because the resulting object is returned fully configured right after you call the new operator.


The cloning method usually consists of just one line: running a new operator with the prototypical version of the constructor. Note, that every class must explicitly override the cloning method and use its own class name along with the new operator. Otherwise, the cloning method may produce an object of a parent class.


Optionally, create a centralized prototype registry to store a catalog of frequently used prototypes.
You can implement the registry as a new factory class or put it in the base prototype class with a static method for fetching the prototype. This method should search for a prototype based on search criteria that the client code passes to the method. The criteria might either be a simple string tag or a complex set of search parameters. After the appropriate prototype is found, the registry should clone it and return the copy to the client.
Finally, replace the direct calls to the subclasses’ constructors with calls to the factory method of the prototype registry.




 You can clone objects without coupling to their concrete classes.

 You can get rid of repeated initialization code in favor of cloning pre-built prototypes.

 You can produce complex objects more conveniently.

 You get an alternative to inheritance when dealing with configuration presets for complex objects.




 Cloning complex objects that have circular references might be very tricky.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


Prototype can help when you need to save copies of Commands into history.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.


Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.


Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
127,0,decorator,"
Inheritance is static. You can’t alter the behavior of an existing object at runtime. You can only replace the whole object with another one that’s created from a different subclass.
Subclasses can have just one parent class. In most languages, inheritance doesn’t let a class inherit behaviors of multiple classes at the same time.





The Component declares the common interface for both wrappers and wrapped objects.


Concrete Component is a class of objects being wrapped. It defines the basic behavior, which can be altered by decorators.


The Base Decorator class has a field for referencing a wrapped object. The field’s type should be declared as the component interface so it can contain both concrete components and decorators. The base decorator delegates all operations to the wrapped object.


Concrete Decorators define extra behaviors that can be added to components dynamically. Concrete decorators override methods of the base decorator and execute their behavior either before or after calling the parent method.


The Client can wrap components in multiple layers of decorators, as long as it works with all objects via the component interface.




Just before the data is written to disk, the decorators encrypt and compress it. The original class writes the encrypted and protected data to the file without knowing about the change.


Right after the data is read from disk, it goes through the same decorators, which decompress and decode it.



 Use the Decorator pattern when you need to be able to assign extra behaviors to objects at runtime without breaking the code that uses these objects.

 The Decorator lets you structure your business logic into layers, create a decorator for each layer and compose objects with various combinations of this logic at runtime. The client code can treat all these objects in the same way, since they all follow a common interface.


 Use the pattern when it’s awkward or not possible to extend an object’s behavior using inheritance.

 Many programming languages have the final keyword that can be used to prevent further extension of a class. For a final class, the only way to reuse the existing behavior would be to wrap the class with your own wrapper, using the Decorator pattern.



Make sure your business domain can be represented as a primary component with multiple optional layers over it.


Figure out what methods are common to both the primary component and the optional layers. Create a component interface and declare those methods there.


Create a concrete component class and define the base behavior in it.


Create a base decorator class. It should have a field for storing a reference to a wrapped object. The field should be declared with the component interface type to allow linking to concrete components as well as decorators. The base decorator must delegate all work to the wrapped object.


Make sure all classes implement the component interface.


Create concrete decorators by extending them from the base decorator. A concrete decorator must execute its behavior before or after the call to the parent method (which always delegates to the wrapped object).


The client code must be responsible for creating decorators and composing them in the way the client needs.




 You can extend an object’s behavior without making a new subclass.

 You can add or remove responsibilities from an object at runtime.

 You can combine several behaviors by wrapping an object into multiple decorators.

 Single Responsibility Principle. You can divide a monolithic class that implements many possible variants of behavior into several smaller classes.




 It’s hard to remove a specific wrapper from the wrappers stack.

 It’s hard to implement a decorator in such a way that its behavior doesn’t depend on the order in the decorators stack.

 The initial configuration code of layers might look pretty ugly.



Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.


Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.
The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.


Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.
A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.
However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.


Decorator lets you change the skin of an object, while Strategy lets you change the guts.


Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.

"
128,0,adapter,"
The adapter gets an interface, compatible with one of the existing objects.
Using this interface, the existing object can safely call the adapter’s methods.
Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects.

Object adapter
This implementation uses the object composition principle: the adapter implements the interface of one object and wraps the other one. It can be implemented in all popular programming languages.






The Client is a class that contains the existing business logic of the program.


The Client Interface describes a protocol that other classes must follow to be able to collaborate with the client code.


The Service is some useful class (usually 3rd-party or legacy). The client can’t use this class directly because it has an incompatible interface.


The Adapter is a class that’s able to work with both the client and the service: it implements the client interface, while wrapping the service object. The adapter receives calls from the client via the adapter interface and translates them into calls to the wrapped service object in a format it can understand.


The client code doesn’t get coupled to the concrete adapter class as long as it works with the adapter via the client interface. Thanks to this, you can introduce new types of adapters into the program without breaking the existing client code. This can be useful when the interface of the service class gets changed or replaced: you can just create a new adapter class without changing the client code.

Class adapter
This implementation uses inheritance: the adapter inherits interfaces from both objects at the same time. Note that this approach can only be implemented in programming languages that support multiple inheritance, such as C++.






The Class Adapter doesn’t need to wrap any objects because it inherits behaviors from both the client and the service. The adaptation happens within the overridden methods. The resulting adapter can be used in place of an existing client class.




 Use the Adapter class when you want to use some existing class, but its interface isn’t compatible with the rest of your code.

 The Adapter pattern lets you create a middle-layer class that serves as a translator between your code and a legacy class, a 3rd-party class or any other class with a weird interface.


 Use the pattern when you want to reuse several existing subclasses that lack some common functionality that can’t be added to the superclass.

 You could extend each subclass and put the missing functionality into new child classes. However, you’ll need to duplicate the code across all of these new classes, which smells really bad.
The much more elegant solution would be to put the missing functionality into an adapter class. Then you would wrap objects with missing features inside the adapter, gaining needed features dynamically. For this to work, the target classes must have a common interface, and the adapter’s field should follow that interface. This approach looks very similar to the Decorator pattern.



Make sure that you have at least two classes with incompatible interfaces:

A useful service class, which you can’t change (often 3rd-party, legacy or with lots of existing dependencies).
One or several client classes that would benefit from using the service class.



Declare the client interface and describe how clients communicate with the service.


Create the adapter class and make it follow the client interface. Leave all the methods empty for now.


Add a field to the adapter class to store a reference to the service object. The common practice is to initialize this field via the constructor, but sometimes it’s more convenient to pass it to the adapter when calling its methods.


One by one, implement all methods of the client interface in the adapter class. The adapter should delegate most of the real work to the service object, handling only the interface or data format conversion.


Clients should use the adapter via the client interface. This will let you change or extend the adapters without affecting the client code.




 Single Responsibility Principle. You can separate the interface or data conversion code from the primary business logic of the program.

 Open/Closed Principle. You can introduce new types of adapters into the program without breaking the existing client code, as long as they work with the adapters through the client interface.




 The overall complexity of the code increases because you need to introduce a set of new interfaces and classes. Sometimes it’s simpler just to change the service class so that it matches the rest of your code.



Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.


Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.


Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.


Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.

"
129,0,singleton,"

Ensure that a class has just a single instance. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource—for example, a database or a file.
Here’s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you’ll get the one you already created.
Note that this behavior is impossible to implement with a regular constructor since a constructor call must always return a new object by design.


Make the default constructor private, to prevent other objects from using the new operator with the Singleton class.
Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.





The Singleton class declares the static method getInstance that returns the same instance of its own class.
The Singleton’s constructor should be hidden from the client code. Calling the getInstance method should be the only way of getting the Singleton object.




 Use the Singleton pattern when a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program.

 The Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created.


 Use the Singleton pattern when you need stricter control over global variables.

 Unlike global variables, the Singleton pattern guarantees that there’s just one instance of a class. Nothing, except for the Singleton class itself, can replace the cached instance.
Note that you can always adjust this limitation and allow creating any number of Singleton instances. The only piece of code that needs changing is the body of the getInstance method.



Add a private static field to the class for storing the singleton instance.


Declare a public static creation method for getting the singleton instance.


Implement “lazy initialization” inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.


Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.


Go over the client code and replace all direct calls to the singleton’s constructor with calls to its static creation method.




 You can be sure that a class has only a single instance.

 You gain a global access point to that instance.

 The singleton object is initialized only when it’s requested for the first time.




 Violates the Single Responsibility Principle. The pattern solves two problems at the time.

 The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other.

 The pattern requires special treatment in a multithreaded environment so that multiple threads won’t create a singleton object several times.

 It may be difficult to unit test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don’t write the tests. Or don’t use the Singleton pattern.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.



Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
130,0,bridge,"Abstraction and Implementation
Have several different GUIs (for instance, tailored for regular customers or admins).
Support several different APIs (for example, to be able to launch the app under Windows, Linux, and macOS).

Abstraction: the GUI layer of the app.
Implementation: the operating systems’ APIs.





The Abstraction provides high-level control logic. It relies on the implementation object to do the actual low-level work.


The Implementation declares the interface that’s common for all concrete implementations. An abstraction can only communicate with an implementation object via methods that are declared here.
The abstraction may list the same methods as the implementation, but usually the abstraction declares some complex behaviors that rely on a wide variety of primitive operations declared by the implementation.


Concrete Implementations contain platform-specific code.


Refined Abstractions provide variants of control logic. Like their parent, they work with different implementations via the general implementation interface.


Usually, the Client is only interested in working with the abstraction. However, it’s the client’s job to link the abstraction object with one of the implementation objects.




 Use the Bridge pattern when you want to divide and organize a monolithic class that has several variants of some functionality (for example, if the class can work with various database servers).

 The bigger a class becomes, the harder it is to figure out how it works, and the longer it takes to make a change. The changes made to one of the variations of functionality may require making changes across the whole class, which often results in making errors or not addressing some critical side effects.
The Bridge pattern lets you split the monolithic class into several class hierarchies. After this, you can change the classes in each hierarchy independently of the classes in the others. This approach simplifies code maintenance and minimizes the risk of breaking existing code.


 Use the pattern when you need to extend a class in several orthogonal (independent) dimensions.

 The Bridge suggests that you extract a separate class hierarchy for each of the dimensions. The original class delegates the related work to the objects belonging to those hierarchies instead of doing everything on its own.


 Use the Bridge if you need to be able to switch implementations at runtime.

 Although it’s optional, the Bridge pattern lets you replace the implementation object inside the abstraction. It’s as easy as assigning a new value to a field.
By the way, this last item is the main reason why so many people confuse the Bridge with the Strategy pattern. Remember that a pattern is more than just a certain way to structure your classes. It may also communicate intent and a problem being addressed.



Identify the orthogonal dimensions in your classes. These independent concepts could be: abstraction/platform, domain/infrastructure, front-end/back-end, or interface/implementation.


See what operations the client needs and define them in the base abstraction class.


Determine the operations available on all platforms. Declare the ones that the abstraction needs in the general implementation interface.


For all platforms in your domain create concrete implementation classes, but make sure they all follow the implementation interface.


Inside the abstraction class, add a reference field for the implementation type. The abstraction delegates most of the work to the implementation object that’s referenced in that field.


If you have several variants of high-level logic, create refined abstractions for each variant by extending the base abstraction class.


The client code should pass an implementation object to the abstraction’s constructor to associate one with the other. After that, the client can forget about the implementation and work only with the abstraction object.




 You can create platform-independent classes and apps.

 The client code works with high-level abstractions. It isn’t exposed to the platform details.

 Open/Closed Principle. You can introduce new abstractions and implementations independently from each other.

 Single Responsibility Principle. You can focus on high-level logic in the abstraction and on platform details in the implementation.




 You might make the code more complicated by applying the pattern to a highly cohesive class.



Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.


Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.


You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.

"
131,0,facade,"




The Facade provides convenient access to a particular part of the subsystem’s functionality. It knows where to direct the client’s request and how to operate all the moving parts.


An Additional Facade class can be created to prevent polluting a single facade with unrelated features that might make it yet another complex structure. Additional facades can be used by both clients and other facades.


The Complex Subsystem consists of dozens of various objects. To make them all do something meaningful, you have to dive deep into the subsystem’s implementation details, such as initializing objects in the correct order and supplying them with data in the proper format.
Subsystem classes aren’t aware of the facade’s existence. They operate within the system and work with each other directly.


The Client uses the facade instead of calling the subsystem objects directly.




 Use the Facade pattern when you need to have a limited but straightforward interface to a complex subsystem.

 Often, subsystems get more complex over time. Even applying design patterns typically leads to creating more classes. A subsystem may become more flexible and easier to reuse in various contexts, but the amount of configuration and boilerplate code it demands from a client grows ever larger. The Facade attempts to fix this problem by providing a shortcut to the most-used features of the subsystem which fit most client requirements.


 Use the Facade when you want to structure a subsystem into layers.

 Create facades to define entry points to each level of a subsystem. You can reduce coupling between multiple subsystems by requiring them to communicate only through facades.
For example, let’s return to our video conversion framework. It can be broken down into two layers: video- and audio-related. For each layer, you can create a facade and then make the classes of each layer communicate with each other via those facades. This approach looks very similar to the Mediator pattern.



Check whether it’s possible to provide a simpler interface than what an existing subsystem already provides. You’re on the right track if this interface makes the client code independent from many of the subsystem’s classes.


Declare and implement this interface in a new facade class. The facade should redirect the calls from the client code to appropriate objects of the subsystem. The facade should be responsible for initializing the subsystem and managing its further life cycle unless the client code already does this.


To get the full benefit from the pattern, make all the client code communicate with the subsystem only via the facade. Now the client code is protected from any changes in the subsystem code. For example, when a subsystem gets upgraded to a new version, you will only need to modify the code in the facade.


If the facade becomes too big, consider extracting part of its behavior to a new, refined facade class.




 You can isolate your code from the complexity of a subsystem.




 A facade can become a god object coupled to all classes of an app.



Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.


Facade defines a simplified interface to a subsystem of objects, but it doesn’t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

Mediator centralizes communication between components of the system. The components only know about the mediator object and don’t communicate directly.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.

"
132,0,proxy,"




The Service Interface declares the interface of the Service. The proxy must follow this interface to be able to disguise itself as a service object.


The Service is a class that provides some useful business logic.


The Proxy class has a reference field that points to a service object. After the proxy finishes its processing (e.g., lazy initialization, logging, access control, caching, etc.), it passes the request to the service object.
Usually, proxies manage the full lifecycle of their service objects.


The Client should work with both services and proxies via the same interface. This way you can pass a proxy into any code that expects a service object.



There are dozens of ways to utilize the Proxy pattern. Let’s go over the most popular uses.

 Lazy initialization (virtual proxy). This is when you have a heavyweight service object that wastes system resources by being always up, even though you only need it from time to time.

 Instead of creating the object when the app launches, you can delay the object’s initialization to a time when it’s really needed.


 Access control (protection proxy). This is when you want only specific clients to be able to use the service object; for instance, when your objects are crucial parts of an operating system and clients are various launched applications (including malicious ones).

 The proxy can pass the request to the service object only if the client’s credentials match some criteria.


 Local execution of a remote service (remote proxy). This is when the service object is located on a remote server.

 In this case, the proxy passes the client request over the network, handling all of the nasty details of working with the network.


 Logging requests (logging proxy). This is when you want to keep a history of requests to the service object.

 The proxy can log each request before passing it to the service.


 Caching request results (caching proxy). This is when you need to cache results of client requests and manage the life cycle of this cache, especially if results are quite large.

 The proxy can implement caching for recurring requests that always yield the same results. The proxy may use the parameters of requests as the cache keys.


 Smart reference. This is when you need to be able to dismiss a heavyweight object once there are no clients that use it.

 The proxy can keep track of clients that obtained a reference to the service object or its results. From time to time, the proxy may go over the clients and check whether they are still active. If the client list gets empty, the proxy might dismiss the service object and free the underlying system resources.
The proxy can also track whether the client had modified the service object. Then the unchanged objects may be reused by other clients.



If there’s no pre-existing service interface, create one to make proxy and service objects interchangeable. Extracting the interface from the service class isn’t always possible, because you’d need to change all of the service’s clients to use that interface. Plan B is to make the proxy a subclass of the service class, and this way it’ll inherit the interface of the service.


Create the proxy class. It should have a field for storing a reference to the service. Usually, proxies create and manage the whole life cycle of their services. On rare occasions, a service is passed to the proxy via a constructor by the client.


Implement the proxy methods according to their purposes. In most cases, after doing some work, the proxy should delegate the work to the service object.


Consider introducing a creation method that decides whether the client gets a proxy or a real service. This can be a simple static method in the proxy class or a full-blown factory method.


Consider implementing lazy initialization for the service object.




 You can control the service object without clients knowing about it.

 You can manage the lifecycle of the service object when clients don’t care about it.

 The proxy works even if the service object isn’t ready or is not available.

 Open/Closed Principle. You can introduce new proxies without changing the service or clients.




 The code may become more complicated since you need to introduce a lot of new classes.

 The response from the service might get delayed.



Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.


Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.

"
133,0,chain_of_responsibility,"

One of your colleagues suggested that it’s unsafe to pass raw data straight to the ordering system. So you added an extra validation step to sanitize the data in a request.


Later, somebody noticed that the system is vulnerable to brute force password cracking. To negate this, you promptly added a check that filters repeated failed requests coming from the same IP address.


Someone else suggested that you could speed up the system by returning cached results on repeated requests containing the same data. Hence, you added another check which lets the request pass through to the system only if there’s no suitable cached response.






The Handler declares the interface, common for all concrete handlers. It usually  contains just a single method for handling requests, but sometimes it may also have another method for setting the next handler on the chain.


The Base Handler is an optional class where you can put the boilerplate code that’s common to all handler classes.
Usually, this class defines a field for storing a reference to the next handler. The clients can build a chain by passing a handler to the constructor or setter of the previous handler. The class may also implement the default handling behavior: it can pass execution to the next handler after checking for its existence.


Concrete Handlers contain the actual code for processing requests. Upon receiving a request, each handler must decide whether to process it and, additionally, whether to pass it along the chain.
Handlers are usually self-contained and immutable, accepting all necessary data just once via the constructor.


The Client may compose chains just once or compose them dynamically, depending on the application’s logic. Note that a request can be sent to any handler in the chain—it doesn’t have to be the first one.




 Use the Chain of Responsibility pattern when your program is expected to process different kinds of requests in various ways, but the exact types of requests and their sequences are unknown beforehand.

 The pattern lets you link several handlers into one chain and, upon receiving a request, “ask” each handler whether it can process it. This way all handlers get a chance to process the request.


 Use the pattern when it’s essential to execute several handlers in a particular order.

 Since you can link the handlers in the chain in any order, all requests will get through the chain exactly as you planned.


 Use the CoR pattern when the set of handlers and their order are supposed to change at runtime.

 If you provide setters for a reference field inside the handler classes, you’ll be able to insert, remove or reorder handlers dynamically.



Declare the handler interface and describe the signature of a method for handling requests.
Decide how the client will pass the request data into the method. The most flexible way is to convert the request into an object and pass it to the handling method as an argument.


To eliminate duplicate boilerplate code in concrete handlers, it might be worth creating an abstract base handler class, derived from the handler interface.
This class should have a field for storing a reference to the next handler in the chain. Consider making the class immutable. However, if you plan to modify chains at runtime, you need to define a setter for altering the value of the reference field.
You can also implement the convenient default behavior for the handling method, which is to forward the request to the next object unless there’s none left. Concrete handlers will be able to use this behavior by calling the parent method.


One by one create concrete handler subclasses and implement their handling methods. Each handler should make two decisions when receiving a request:

Whether it’ll process the request.
Whether it’ll pass the request along the chain.



The client may either assemble chains on its own or receive pre-built chains from other objects. In the latter case, you must implement some factory classes to build chains according to the configuration or environment settings.


The client may trigger any handler in the chain, not just the first one. The request will be passed along the chain until some handler refuses to pass it further or until it reaches the end of the chain.


Due to the dynamic nature of the chain, the client should be ready to handle the following scenarios:

The chain may consist of a single link.
Some requests may not reach the end of the chain.
Others may reach the end of the chain unhandled.





 You can control the order of request handling.

 Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform operations.

 Open/Closed Principle. You can introduce new handlers into the app without breaking the existing client code.




 Some requests may end up unhandled.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.


Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.
However, there’s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.


Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.
The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.

"
134,0,command,"




The Sender class (aka invoker) is responsible for initiating requests. This class must have a field for storing a reference to a command object. The sender triggers that command instead of sending the request directly to the receiver. Note that the sender isn’t responsible for creating the command object. Usually, it gets a pre-created command from the client via the constructor.


The Command interface usually declares just a single method for executing the command.


Concrete Commands implement various kinds of requests. A concrete command isn’t supposed to perform the work on its own, but rather to pass the call to one of the business logic objects. However, for the sake of simplifying the code, these classes can be merged.
Parameters required to execute a method on a receiving object can be declared as fields in the concrete command. You can make command objects immutable by only allowing the initialization of these fields via the constructor.


The Receiver class contains some business logic. Almost any object may act as a receiver. Most commands only handle the details of how a request is passed to the receiver, while the receiver itself does the actual work.


The Client creates and configures concrete command objects. The client must pass all of the request parameters, including a receiver instance, into the command’s constructor. After that, the resulting command may be associated with one or multiple senders.




 Use the Command pattern when you want to parametrize objects with operations.

 The Command pattern can turn a specific method call into a stand-alone object. This change opens up a lot of interesting uses: you can pass commands as method arguments, store them inside other objects, switch linked commands at runtime, etc.
Here’s an example: you’re developing a GUI component such as a context menu, and you want your users to be able to configure menu items that trigger operations when an end user clicks an item.


 Use the Command pattern when you want to queue operations, schedule their execution, or execute them remotely.

 As with any other object, a command can be serialized, which means converting it to a string that can be easily written to a file or a database. Later, the string can be restored as the initial command object. Thus, you can delay and schedule command execution. But there’s even more! In the same way, you can queue, log or send commands over the network.


 Use the Command pattern when you want to implement reversible operations.

 Although there are many ways to implement undo/redo, the Command pattern is perhaps the most popular of all.
To be able to revert operations, you need to implement the history of performed operations. The command history is a stack that contains all executed command objects along with related backups of the application’s state.
This method has two drawbacks. First, it isn’t that easy to save an application’s state because some of it can be private. This problem can be mitigated with the Memento pattern.
Second, the state backups may consume quite a lot of RAM. Therefore, sometimes you can resort to an alternative implementation: instead of restoring the past state, the command performs the inverse operation. The reverse operation also has a price: it may turn out to be hard or even impossible to implement.



Declare the command interface with a single execution method.


Start extracting requests into concrete command classes that implement the command interface. Each class must have a set of fields for storing the request arguments along with a reference to the actual receiver object. All these values must be initialized via the command’s constructor.


Identify classes that will act as senders. Add the fields for storing commands into these classes. Senders should communicate with their commands only via the command interface. Senders usually don’t create command objects on their own, but rather get them from the client code.


Change the senders so they execute the command instead of sending a request to the receiver directly.


The client should initialize objects in the following order:

Create receivers.
Create commands, and associate them with receivers if needed.
Create senders, and associate them with specific commands.





 Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform these operations.

 Open/Closed Principle. You can introduce new commands into the app without breaking existing client code.

 You can implement undo/redo.

 You can implement deferred execution of operations.

 You can assemble a set of simple commands into a complex one.




 The code may become more complicated since you’re introducing a whole new layer between senders and receivers.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.
However, there’s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.


You can use Command and Memento together when implementing “undo”. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.


Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.


You can use Command to convert any operation into an object. The operation’s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.


On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.




Prototype can help when you need to save copies of Commands into history.


You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.

"
135,0,memento,"
Implementation based on nested classes
The classic implementation of the pattern relies on support for nested classes, available in many popular programming languages (such as C++, C#, and Java).






The Originator class can produce snapshots of its own state, as well as restore its state from snapshots when needed.


The Memento is a value object that acts as a snapshot of the originator’s state. It’s a common practice to make the memento immutable and pass it the data only once, via the constructor.


The Caretaker knows not only “when” and “why” to capture the originator’s state, but also when the state should be restored.
A caretaker can keep track of the originator’s history by storing a stack of mementos. When the originator has to travel back in history, the caretaker fetches the topmost memento from the stack and passes it to the originator’s restoration method.


In this implementation, the memento class is nested inside the originator. This lets the originator access the fields and methods of the memento, even though they’re declared private. On the other hand, the caretaker has very limited access to the memento’s fields and methods, which lets it store mementos in a stack but not tamper with their state.

Implementation based on an intermediate interface
There’s an alternative implementation, suitable for programming languages that don’t support nested classes (yeah, PHP, I’m talking about you).






In the absence of nested classes, you can restrict access to the memento’s fields by establishing a convention that caretakers can work with a memento only through an explicitly declared intermediary interface, which would only declare methods related to the memento’s metadata.


On the other hand, originators can work with a memento object directly, accessing fields and methods declared in the memento class. The downside of this approach is that you need to declare all members of the memento public.

Implementation with even stricter encapsulation
There’s another implementation which is useful when you don’t want to leave even the slightest chance of other classes accessing the state of the originator through the memento.






This implementation allows having multiple types of originators and mementos. Each originator works with a corresponding memento class. Neither originators nor mementos expose their state to anyone.


Caretakers are now explicitly restricted from changing the state stored in mementos. Moreover, the caretaker class becomes independent from the originator because the restoration method is now defined in the memento class.


Each memento becomes linked to the originator that produced it. The originator passes itself to the memento’s constructor, along with the values of its state. Thanks to the close relationship between these classes, a memento can restore the state of its originator, given that the latter has defined the appropriate setters.




 Use the Memento pattern when you want to produce snapshots of the object’s state to be able to restore a previous state of the object.

 The Memento pattern lets you make full copies of an object’s state, including private fields, and store them separately from the object. While most people remember this pattern thanks to the “undo” use case, it’s also indispensable when dealing with transactions (i.e., if you need to roll back an operation on error).


 Use the pattern when direct access to the object’s fields/getters/setters violates its encapsulation.

 The Memento makes the object itself responsible for creating a snapshot of its state. No other object can read the snapshot, making the original object’s state data safe and secure.



Determine what class will play the role of the originator. It’s important to know whether the program uses one central object of this type or multiple smaller ones.


Create the memento class. One by one, declare a set of fields that mirror the fields declared inside the originator class.


Make the memento class immutable. A memento should accept the data just once, via the constructor. The class should have no setters.


If your programming language supports nested classes, nest the memento inside the originator. If not, extract a blank interface from the memento class and make all other objects use it to refer to the memento. You may add some metadata operations to the interface, but nothing that exposes the originator’s state.


Add a method for producing mementos to the originator class. The originator should pass its state to the memento via one or multiple arguments of the memento’s constructor.
The return type of the method should be of the interface you extracted in the previous step (assuming that you extracted it at all). Under the hood, the memento-producing method should work directly with the memento class.


Add a method for restoring the originator’s state to its class. It should accept a memento object as an argument. If you extracted an interface in the previous step, make it the type of the parameter. In this case, you need to typecast the incoming object to the memento class, since the originator needs full access to that object.


The caretaker, whether it represents a command object, a history, or something entirely different, should know when to request new mementos from the originator, how to store them and when to restore the originator with a particular memento.


The link between caretakers and originators may be moved into the memento class. In this case, each memento must be connected to the originator that had created it. The restoration method would also move to the memento class. However, this would all make sense only if the memento class is nested into originator or the originator class provides sufficient setters for overriding its state.




 You can produce snapshots of the object’s state without violating its encapsulation.

 You can simplify the originator’s code by letting the caretaker maintain the history of the originator’s state.




 The app might consume lots of RAM if clients create mementos too often.

 Caretakers should track the originator’s lifecycle to be able to destroy obsolete mementos.

 Most dynamic programming languages, such as PHP, Python and JavaScript, can’t guarantee that the state within the memento stays untouched.



You can use Command and Memento together when implementing “undo”. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.


You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.


Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.

"
136,0,mediator,"




Components are various classes that contain some business logic. Each component has a reference to a mediator, declared with the type of the mediator interface. The component isn’t aware of the actual class of the mediator, so you can reuse the component in other programs by linking it to a different mediator.


The Mediator interface declares methods of communication with components, which usually include just a single notification method. Components may pass any context as arguments of this method, including their own objects, but only in such a way that no coupling occurs between a receiving component and the sender’s class.


Concrete Mediators encapsulate relations between various components. Concrete mediators often keep references to all components they manage and sometimes even manage their lifecycle.


Components must not be aware of other components. If something important happens within or to a component, it must only notify the mediator. When the mediator receives the notification, it can easily identify the sender, which might be just enough to decide what component should be triggered in return.
From a component’s perspective, it all looks like a total black box. The sender doesn’t know who’ll end up handling its request, and the receiver doesn’t know who sent the request in the first place.




 Use the Mediator pattern when it’s hard to change some of the classes because they are tightly coupled to a bunch of other classes.

 The pattern lets you extract all the relationships between classes into a separate class, isolating any changes to a specific component from the rest of the components.


 Use the pattern when you can’t reuse a component in a different program because it’s too dependent on other components.

 After you apply the Mediator, individual components become unaware of the other components. They could still communicate with each other, albeit indirectly, through a mediator object. To reuse a component in a different app, you need to provide it with a new mediator class.


 Use the Mediator when you find yourself creating tons of component subclasses just to reuse some basic behavior in various contexts.

 Since all relations between components are contained within the mediator, it’s easy to define entirely new ways for these components to collaborate by introducing new mediator classes, without having to change the components themselves.



Identify a group of tightly coupled classes which would benefit from being more independent (e.g., for easier maintenance or simpler reuse of these classes).


Declare the mediator interface and describe the desired communication protocol between mediators and various components. In most cases, a single method for receiving notifications from components is sufficient.
This interface is crucial when you want to reuse component classes in different contexts. As long as the component works with its mediator via the generic interface, you can link the component with a different implementation of the mediator.


Implement the concrete mediator class. Consider storing references to all components inside the mediator. This way, you could call any component from the mediator’s methods.


You can go even further and make the mediator responsible for the creation and destruction of component objects. After this, the mediator may resemble a factory or a facade.


Components should store a reference to the mediator object. The connection is usually established in the component’s constructor, where a mediator object is passed as an argument.


Change the components’ code so that they call the mediator’s notification method instead of methods on other components. Extract the code that involves calling other components into the mediator class. Execute this code whenever the mediator receives notifications from that component.




 Single Responsibility Principle. You can extract the communications between various components into a single place, making it easier to comprehend and maintain.

 Open/Closed Principle. You can introduce new mediators without having to change the actual components.

 You can reduce coupling between various components of a program.

 You can reuse individual components more easily.




 Over time a mediator can evolve into a God Object.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.


Facade defines a simplified interface to a subsystem of objects, but it doesn’t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

Mediator centralizes communication between components of the system. The components only know about the mediator object and don’t communicate directly.



The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let’s see how we can do that.
The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.
There’s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator’s events. When Mediator is implemented this way, it may look very similar to Observer.
When you’re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won’t resemble Observer but will still be an instance of the Mediator pattern.
Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won’t be a centralized mediator object, only a distributed set of observers.

"
137,0,iterator,"




The Iterator interface declares the operations required for traversing a collection: fetching the next element, retrieving the current position, restarting iteration, etc.


Concrete Iterators implement specific algorithms for traversing a collection. The iterator object should track the traversal progress on its own. This allows several iterators to traverse the same collection independently of each other.


The Collection interface declares one or multiple methods for getting iterators compatible with the collection. Note that the return type of the methods must be declared as the iterator interface so that the concrete collections can return various kinds of iterators.


Concrete Collections return new instances of a particular concrete iterator class each time the client requests one. You might be wondering, where’s the rest of the collection’s code? Don’t worry, it should be in the same class. It’s just that these details aren’t crucial to the actual pattern, so we’re omitting them.


The Client works with both collections and iterators via their interfaces. This way the client isn’t coupled to concrete classes, allowing you to use various collections and iterators with the same client code.
Typically, clients don’t create iterators on their own, but instead get them from collections. Yet, in certain cases, the client can create one directly; for example, when the client defines its own special iterator.




 Use the Iterator pattern when your collection has a complex data structure under the hood, but you want to hide its complexity from clients (either for convenience or security reasons).

 The iterator encapsulates the details of working with a complex data structure, providing the client with several simple methods of accessing the collection elements. While this approach is very convenient for the client, it also protects the collection from careless or malicious actions which the client would be able to perform if working with the collection directly.


 Use the pattern to reduce duplication of the traversal code across your app.

 The code of non-trivial iteration algorithms tends to be very bulky. When placed within the business logic of an app, it may blur the responsibility of the original code and make it less maintainable. Moving the traversal code to designated iterators can help you make the code of the application more lean and clean.


 Use the Iterator when you want your code to be able to traverse different data structures or when types of these structures are unknown beforehand.

 The pattern provides a couple of generic interfaces for both collections and iterators. Given that your code now uses these interfaces, it’ll still work if you pass it various kinds of collections and iterators that implement these interfaces.



Declare the iterator interface. At the very least, it must have a method for fetching the next element from a collection. But for the sake of convenience you can add a couple of other methods, such as fetching the previous element, tracking the current position, and checking the end of the iteration.


Declare the collection interface and describe a method for fetching iterators. The return type should be equal to that of the iterator interface. You may declare similar methods if you plan to have several distinct groups of iterators.


Implement concrete iterator classes for the collections that you want to be traversable with iterators. An iterator object must be linked with a single collection instance. Usually, this link is established via the iterator’s constructor.


Implement the collection interface in your collection classes. The main idea is to provide the client with a shortcut for creating iterators, tailored for a particular collection class. The collection object must pass itself to the iterator’s constructor to establish a link between them.


Go over the client code to replace all of the collection traversal code with the use of iterators. The client fetches a new iterator object each time it needs to iterate over the collection elements.




 Single Responsibility Principle. You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes.

 Open/Closed Principle. You can implement new types of collections and iterators and pass them to existing code without breaking anything.

 You can iterate over the same collection in parallel because each iterator object contains its own iteration state.

 For the same reason, you can delay an iteration and continue it when needed.




 Applying the pattern can be an overkill if your app only works with simple collections.

 Using an iterator may be less efficient than going through elements of some specialized collections directly.



You can use Iterators to traverse Composite trees.


You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.


You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.


You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.

"
138,0,observer,"




The Publisher issues events of interest to other objects. These events occur when the publisher changes its state or executes some behaviors. Publishers contain a subscription infrastructure that lets new subscribers join and current subscribers leave the list.


When a new event happens, the publisher goes over the subscription list and calls the notification method declared in the subscriber interface on each subscriber object.


The Subscriber interface declares the notification interface. In most cases, it consists of a single update method. The method may have several parameters that let the publisher pass some event details along with the update.


Concrete Subscribers perform some actions in response to notifications issued by the publisher. All of these classes must implement the same interface so the publisher isn’t coupled to concrete classes.


Usually, subscribers need some contextual information to handle the update correctly. For this reason, publishers often pass some context data as arguments of the notification method. The publisher can pass itself as an argument, letting subscriber fetch any required data directly.


The Client creates publisher and subscriber objects separately and then registers subscribers for publisher updates.




 Use the Observer pattern when changes to the state of one object may require changing other objects, and the actual set of objects is unknown beforehand or changes dynamically.

 You can often experience this problem when working with classes of the graphical user interface. For example, you created custom button classes, and you want to let the clients hook some custom code to your buttons so that it fires whenever a user presses a button.
The Observer pattern lets any object that implements the subscriber interface subscribe for event notifications in publisher objects. You can add the subscription mechanism to your buttons, letting the clients hook up their custom code via custom subscriber classes.


 Use the pattern when some objects in your app must observe others, but only for a limited time or in specific cases.

 The subscription list is dynamic, so subscribers can join or leave the list whenever they need to.



Look over your business logic and try to break it down into two parts: the core functionality, independent from other code, will act as the publisher; the rest will turn into a set of subscriber classes.


Declare the subscriber interface. At a bare minimum, it should declare a single update method.


Declare the publisher interface and describe a pair of methods for adding a subscriber object to and removing it from the list. Remember that publishers must work with subscribers only via the subscriber interface.


Decide where to put the actual subscription list and the implementation of subscription methods. Usually, this code looks the same for all types of publishers, so the obvious place to put it is in an abstract class derived directly from the publisher interface. Concrete publishers extend that class, inheriting the subscription behavior.
However, if you’re applying the pattern to an existing class hierarchy, consider an approach based on composition: put the subscription logic into a separate object, and make all real publishers use it.


Create concrete publisher classes. Each time something important happens inside a publisher, it must notify all its subscribers.


Implement the update notification methods in concrete subscriber classes. Most subscribers would need some context data about the event. It can be passed as an argument of the notification method.
But there’s another option. Upon receiving a notification, the subscriber can fetch any data directly from the notification. In this case, the publisher must pass itself via the update method. The less flexible option is to link a publisher to the subscriber permanently via the constructor.


The client must create all necessary subscribers and register them with proper publishers.




 Open/Closed Principle. You can introduce new subscriber classes without having to change the publisher’s code (and vice versa if there’s a publisher interface).

 You can establish relations between objects at runtime.




 Subscribers are notified in random order.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let’s see how we can do that.
The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.
There’s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator’s events. When Mediator is implemented this way, it may look very similar to Observer.
When you’re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won’t resemble Observer but will still be an instance of the Mediator pattern.
Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won’t be a centralized mediator object, only a distributed set of observers.

"
139,0,strategy,"




The Context maintains a reference to one of the concrete strategies and communicates with this object only via the strategy interface.


The Strategy interface is common to all concrete strategies. It declares a method the context uses to execute a strategy.


Concrete Strategies implement different variations of an algorithm the context uses.


The context calls the execution method on the linked strategy object each time it needs to run the algorithm. The context doesn’t know what type of strategy it works with or how the algorithm is executed.


The Client creates a specific strategy object and passes it to the context. The context exposes a setter which lets clients replace the strategy associated with the context at runtime.




 Use the Strategy pattern when you want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime.

 The Strategy pattern lets you indirectly alter the object’s behavior at runtime by associating it with different sub-objects which can perform specific sub-tasks in different ways.


 Use the Strategy when you have a lot of similar classes that only differ in the way they execute some behavior.

 The Strategy pattern lets you extract the varying behavior into a separate class hierarchy and combine the original classes into one, thereby reducing duplicate code.


 Use the pattern to isolate the business logic of a class from the implementation details of algorithms that may not be as important in the context of that logic.

 The Strategy pattern lets you isolate the code, internal data, and dependencies of various algorithms from the rest of the code. Various clients get a simple interface to execute the algorithms and switch them at runtime.


 Use the pattern when your class has a massive conditional statement that switches between different variants of the same algorithm.

 The Strategy pattern lets you do away with such a conditional by extracting all algorithms into separate classes, all of which implement the same interface. The original object delegates execution to one of these objects, instead of implementing all variants of the algorithm.



In the context class, identify an algorithm that’s prone to frequent changes. It may also be a massive conditional that selects and executes a variant of the same algorithm at runtime.


Declare the strategy interface common to all variants of the algorithm.


One by one, extract all algorithms into their own classes. They should all implement the strategy interface.


In the context class, add a field for storing a reference to a strategy object. Provide a setter for replacing values of that field. The context should work with the strategy object only via the strategy interface. The context may define an interface which lets the strategy access its data.


Clients of the context must associate it with a suitable strategy that matches the way they expect the context to perform its primary job.




 You can swap algorithms used inside an object at runtime.

 You can isolate the implementation details of an algorithm from the code that uses it.

 You can replace inheritance with composition.

 Open/Closed Principle. You can introduce new strategies without having to change the context.




 If you only have a couple of algorithms and they rarely change, there’s no real reason to overcomplicate the program with new classes and interfaces that come along with the pattern.

 Clients must be aware of the differences between strategies to be able to select a proper one.

 A lot of modern programming languages have functional type support that lets you implement different versions of an algorithm inside a set of anonymous functions. Then you could use these functions exactly as you’d have used the strategy objects, but without bloating your code with extra classes and interfaces.



Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.


You can use Command to convert any operation into an object. The operation’s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.


On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.




Decorator lets you change the skin of an object, while Strategy lets you change the guts.


Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object’s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it’s static. Strategy works on the object level, letting you switch behaviors at runtime.


State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn’t restrict dependencies between concrete states, letting them alter the state of the context at will.

"
140,0,template_method,"

abstract steps must be implemented by every subclass

optional steps already have some default implementation, but still can be overridden if needed





The Abstract Class declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order. The steps may either be declared abstract or have some default implementation.


Concrete Classes can override all of the steps, but not the template method itself.




 Use the Template Method pattern when you want to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure.

 The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass.


 Use the pattern when you have several classes that contain almost identical algorithms with some minor differences. As a result, you might need to modify all classes when the algorithm changes.

 When you turn such an algorithm into a template method, you can also pull up the steps with similar implementations into a superclass, eliminating code duplication. Code that varies between subclasses can remain in subclasses.



Analyze the target algorithm to see whether you can break it into steps. Consider which steps are common to all subclasses and which ones will always be unique.


Create the abstract base class and declare the template method and a set of abstract methods representing the algorithm’s steps. Outline the algorithm’s structure in the template method by executing corresponding steps. Consider making the template method final to prevent subclasses from overriding it.


It’s okay if all the steps end up being abstract. However, some steps might benefit from having a default implementation. Subclasses don’t have to implement those methods.


Think of adding hooks between the crucial steps of the algorithm.


For each variation of the algorithm, create a new concrete subclass. It must implement all of the abstract steps, but may also override some of the optional ones.




 You can let clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm.

 You can pull the duplicate code into a superclass.




 Some clients may be limited by the provided skeleton of an algorithm.

 You might violate the Liskov Substitution Principle by suppressing a default step implementation via a subclass.

 Template methods tend to be harder to maintain the more steps they have.



Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.


Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object’s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it’s static. Strategy works on the object level, letting you switch behaviors at runtime.

"
141,0,visitor,"
If it’s a residential building, he sells medical insurance.
If it’s a bank, he sells theft insurance.
If it’s a coffee shop, he sells fire and flood insurance.





The Visitor interface declares a set of visiting methods that can take concrete elements of an object structure as arguments. These methods may have the same names if the program is written in a language that supports overloading, but the type of their parameters must be different.


Each Concrete Visitor implements several versions of the same behaviors, tailored for different concrete element classes.


The Element interface declares a method for “accepting” visitors. This method should have one parameter declared with the type of the visitor interface.


Each Concrete Element must implement the acceptance method. The purpose of this method is to redirect the call to the proper visitor’s method corresponding to the current element class. Be aware that even if a base element class implements this method, all subclasses must still override this method in their own classes and call the appropriate method on the visitor object.


The Client usually represents a collection or some other complex object (for example, a Composite tree). Usually, clients aren’t aware of all the concrete element classes because they work with objects from that collection via some abstract interface.




 Use the Visitor when you need to perform an operation on all elements of a complex object structure (for example, an object tree).

 The Visitor pattern lets you execute an operation over a set of objects with different classes by having a visitor object implement several variants of the same operation, which correspond to all target classes.


 Use the Visitor to clean up the business logic of auxiliary behaviors.

 The pattern lets you make the primary classes of your app more focused on their main jobs by extracting all other behaviors into a set of visitor classes.


 Use the pattern when a behavior makes sense only in some classes of a class hierarchy, but not in others.

 You can extract this behavior into a separate visitor class and implement only those visiting methods that accept objects of relevant classes, leaving the rest empty.



Declare the visitor interface with a set of “visiting” methods, one per each concrete element class that exists in the program.


Declare the element interface. If you’re working with an existing element class hierarchy, add the abstract “acceptance” method to the base class of the hierarchy. This method should accept a visitor object as an argument.


Implement the acceptance methods in all concrete element classes. These methods must simply redirect the call to a visiting method on the incoming visitor object which matches the class of the current element.


The element classes should only work with visitors via the visitor interface. Visitors, however, must be aware of all concrete element classes, referenced as parameter types of the visiting methods.


For each behavior that can’t be implemented inside the element hierarchy, create a new concrete visitor class and implement all of the visiting methods.
You might encounter a situation where the visitor will need access to some private members of the element class. In this case, you can either make these fields or methods public, violating the element’s encapsulation, or nest the visitor class in the element class. The latter is only possible if you’re lucky to work with a programming language that supports nested classes.


The client must create visitor objects and pass them into elements via “acceptance” methods.




 Open/Closed Principle. You can introduce a new behavior that can work with objects of different classes without changing these classes.

 Single Responsibility Principle. You can move multiple versions of the same behavior into the same class.

 A visitor object can accumulate some useful information while working with various objects. This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure.




 You need to update all visitors each time a class gets added to or removed from the element hierarchy.

 Visitors might lack the necessary access to the private fields and methods of the elements that they’re supposed to work with.



You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.


You can use Visitor to execute an operation over an entire Composite tree.


You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.


Puzzled why we can’t simply replace the Visitor pattern with method overloading? Read my article Visitor and Double Dispatch to learn about the nasty details.
"
142,0,state,"
In Draft, it moves the document to moderation.
In Moderation, it makes the document public, but only if the current user is an administrator.
In Published, it doesn’t do anything at all.

When the phone is unlocked, pressing buttons leads to executing various functions.
When the phone is locked, pressing any button leads to the unlock screen.
When the phone’s charge is low, pressing any button shows the charging screen.





Context stores a reference to one of the concrete state objects and delegates to it all state-specific work. The context communicates with the state object via the state interface. The context exposes a setter for passing it a new state object.


The State interface declares the state-specific methods. These methods should make sense for all concrete states because you don’t want some of your states to have useless methods that will never be called.


Concrete States provide their own implementations for the state-specific methods. To avoid duplication of similar code across multiple states, you may provide intermediate abstract classes that encapsulate some common behavior.
State objects may store a backreference to the context object. Through this reference, the state can fetch any required info from the context object, as well as initiate state transitions.


Both context and concrete states can set the next state of the context and perform the actual state transition by replacing the state object linked to the context.




 Use the State pattern when you have an object that behaves differently depending on its current state, the number of states is enormous, and the state-specific code changes frequently.

 The pattern suggests that you extract all state-specific code into a set of distinct classes. As a result, you can add new states or change existing ones independently of each other, reducing the maintenance cost.


 Use the pattern when you have a class polluted with massive conditionals that alter how the class behaves according to the current values of the class’s fields.

 The State pattern lets you extract branches of these conditionals into methods of corresponding state classes. While doing so, you can also clean temporary fields and helper methods involved in state-specific code out of your main class.


 Use State when you have a lot of duplicate code across similar states and transitions of a condition-based state machine.

 The State pattern lets you compose hierarchies of state classes and reduce duplication by extracting common code into abstract base classes.



Decide what class will act as the context. It could be an existing class which already has the state-dependent code; or a new class, if the state-specific code is distributed across multiple classes.


Declare the state interface. Although it may mirror all the methods declared in the context, aim only for those that may contain state-specific behavior.


For every actual state, create a class that derives from the state interface. Then go over the methods of the context and extract all code related to that state into your newly created class.
While moving the code to the state class, you might discover that it depends on private members of the context. There are several workarounds:

Make these fields or methods public.
Turn the behavior you’re extracting into a public method in the context and call it from the state class. This way is ugly but quick, and you can always fix it later.
Nest the state classes into the context class, but only if your programming language supports nesting classes.



In the context class, add a reference field of the state interface type and a public setter that allows overriding the value of that field.


Go over the method of the context again and replace empty state conditionals with calls to corresponding methods of the state object.


To switch the state of the context, create an instance of one of the state classes and pass it to the context. You can do this within the context itself, or in various states, or in the client. Wherever this is done, the class becomes dependent on the concrete state class that it instantiates.




 Single Responsibility Principle. Organize the code related to particular states into separate classes.

 Open/Closed Principle. Introduce new states without changing existing state classes or the context.

 Simplify the code of the context by eliminating bulky state machine conditionals.




 Applying the pattern can be overkill if a state machine has only a few states or rarely changes.



Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn’t restrict dependencies between concrete states, letting them alter the state of the context at will.

"
143,0,flyweight,"Extrinsic state storageFlyweight and immutabilityFlyweight factory




The Flyweight pattern is merely an optimization. Before applying it, make sure your program does have the RAM consumption problem related to having a massive number of similar objects in memory at the same time. Make sure that this problem can’t be solved in any other meaningful way.


The Flyweight class contains the portion of the original object’s state that can be shared between multiple objects. The same flyweight object can be used in many different contexts. The state stored inside a flyweight is called intrinsic. The state passed to the flyweight’s methods is called extrinsic.


The Context class contains the extrinsic state, unique across all original objects. When a context is paired with one of the flyweight objects, it represents the full state of the original object.


Usually, the behavior of the original object remains in the flyweight class. In this case, whoever calls a flyweight’s method must also pass appropriate bits of the extrinsic state into the method’s parameters. On the other hand, the behavior can be moved to the context class, which would use the linked flyweight merely as a data object.


The Client calculates or stores the extrinsic state of flyweights. From the client’s perspective, a flyweight is a template object which can be configured at runtime by passing some contextual data into parameters of its methods.


The Flyweight Factory manages a pool of existing flyweights. With the factory, clients don’t create flyweights directly. Instead, they call the factory, passing it bits of the intrinsic state of the desired flyweight. The factory looks over previously created flyweights and either returns an existing one that matches search criteria or creates a new one if nothing is found.




 Use the Flyweight pattern only when your program must support a huge number of objects which barely fit into available RAM.

 The benefit of applying the pattern depends heavily on how and where it’s used. It’s most useful when:

an application needs to spawn a huge number of similar objects
this drains all available RAM on a target device
the objects contain duplicate states which can be extracted and shared between multiple objects




Divide fields of a class that will become a flyweight into two parts:

the intrinsic state: the fields that contain unchanging data duplicated across many objects
the extrinsic state: the fields that contain contextual data unique to each object



Leave the fields that represent the intrinsic state in the class, but make sure they’re immutable. They should take their initial values only inside the constructor.


Go over methods that use fields of the extrinsic state. For each field used in the method, introduce a new parameter and use it instead of the field.


Optionally, create a factory class to manage the pool of flyweights. It should check for an existing flyweight before creating a new one. Once the factory is in place, clients must only request flyweights through it. They should describe the desired flyweight by passing its intrinsic state to the factory.


The client must store or calculate values of the extrinsic state (context) to be able to call methods of flyweight objects. For the sake of convenience, the extrinsic state along with the flyweight-referencing field may be moved to a separate context class.




 You can save lots of RAM, assuming your program has tons of similar objects.




 You might be trading RAM over CPU cycles when some of the context data needs to be recalculated each time somebody calls a flyweight method.

 The code becomes much more complicated. New team members will always be wondering why the state of an entity was separated in such a way.



You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.


"
144,0,factory_method,"




The Product declares the interface, which is common to all objects that can be produced by the creator and its subclasses.


Concrete Products are different implementations of the product interface.


The Creator class declares the factory method that returns new product objects. It’s important that the return type of this method matches the product interface.
You can declare the factory method as abstract to force all subclasses to implement their own versions of the method. As an alternative, the base factory method can return some default product type.
Note, despite its name, product creation is not the primary responsibility of the creator. Usually, the creator class already has some core business logic related to products. The factory method helps to decouple this logic from the concrete product classes. Here is an analogy: a large software development company can have a training department for programmers. However, the primary function of the company as a whole is still writing code, not producing programmers.


Concrete Creators override the base factory method so it returns a different type of product.
Note that the factory method doesn’t have to create new instances all the time. It can also return existing objects from a cache, an object pool, or another source.




 Use the Factory Method when you don’t know beforehand the exact types and dependencies of the objects your code should work with.

 The Factory Method separates product construction code from the code that actually uses the product. Therefore it’s easier to extend the product construction code independently from the rest of the code.
For example, to add a new product type to the app, you’ll only need to create a new creator subclass and override the factory method in it.


 Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.

 Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component?
The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself.
Let’s see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard Button class with a glorious RoundButton subclass. But now you need to tell the main UIFramework class to use the new button subclass instead of a default one.
To achieve this, you create a subclass UIWithRoundButtons from a base framework class and override its createButton method. While this method returns Button objects in the base class, you make your subclass return RoundButton objects. Now use the UIWithRoundButtons class instead of UIFramework. And that’s about it!


 Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time.

 You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources.
Let’s think about what has to be done to reuse an existing object:

First, you need to create some storage to keep track of all of the created objects.
When someone requests an object, the program should look for a free object inside that pool.
… and then return it to the client code.
If there are no free objects, the program should create a new one (and add it to the pool).

That’s a lot of code! And it must all be put into a single place so that you don’t pollute the program with duplicate code.
Probably the most obvious and convenient place where this code could be placed is the constructor of the class whose objects we’re trying to reuse. However, a constructor must always return new objects by definition. It can’t return existing instances.
Therefore, you need to have a regular method capable of creating new objects as well as reusing existing ones. That sounds very much like a factory method.



Make all products follow the same interface. This interface should declare methods that make sense in every product.


Add an empty factory method inside the creator class. The return type of the method should match the common product interface.


In the creator’s code find all references to product constructors. One by one, replace them with calls to the factory method, while extracting the product creation code into the factory method.
You might need to add a temporary parameter to the factory method to control the type of returned product.
At this point, the code of the factory method may look pretty ugly. It may have a large switch statement that picks which product class to instantiate. But don’t worry, we’ll fix it soon enough.


Now, create a set of creator subclasses for each type of product listed in the factory method. Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.


If there are too many product types and it doesn’t make sense to create subclasses for all of them, you can reuse the control parameter from the base class in subclasses.
For instance, imagine that you have the following hierarchy of classes: the base Mail class with a couple of subclasses: AirMail and GroundMail; the Transport classes are Plane, Truck and Train. While the AirMail class only uses Plane objects, GroundMail may work with both Truck and Train objects. You can create a new subclass (say TrainMail) to handle both cases, but there’s another option. The client code can pass an argument to the factory method of the GroundMail class to control which product it wants to receive.


If, after all of the extractions, the base factory method has become empty, you can make it abstract. If there’s something left, you can make it a default behavior of the method.




 You avoid tight coupling between the creator and the concrete products.

 Single Responsibility Principle. You can move the product creation code into one place in the program, making the code easier to support.

 Open/Closed Principle. You can introduce new types of products into the program without breaking existing client code.




 The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern. The best case scenario is when you’re introducing the pattern into an existing hierarchy of creator classes.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.


Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.


Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.


Read our Factory Comparison if you can’t figure out the difference between various factory patterns and concepts.
"
145,0,builder,"Director




The Builder interface declares product construction steps that are common to all types of builders.


Concrete Builders provide different implementations of the construction steps. Concrete builders may produce products that don’t follow the common interface.


Products are resulting objects. Products constructed by different builders don’t have to belong to the same class hierarchy or interface.


The Director class defines the order in which to call construction steps, so you can create and reuse specific configurations of products.


The Client must associate one of the builder objects with the director. Usually, it’s done just once, via parameters of the director’s constructor. Then the director uses that builder object for all further construction. However, there’s an alternative approach for when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.




 Use the Builder pattern to get rid of a “telescoping constructor”.

 Say you have a constructor with ten optional parameters. Calling such a beast is very inconvenient; therefore, you overload the constructor and create several shorter versions with fewer parameters. These constructors still refer to the main one, passing some default values into any omitted parameters.

class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...


Creating such a monster is only possible in languages that support method overloading, such as C# or Java.


The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don’t have to cram dozens of parameters into your constructors anymore.


 Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).

 The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details.
The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction.


 Use the Builder to construct Composite trees or other complex objects.

 The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree.
A builder doesn’t expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result.



Make sure that you can clearly define the common construction steps for building all available product representations. Otherwise, you won’t be able to proceed with implementing the pattern.


Declare these steps in the base builder interface.


Create a concrete builder class for each of the product representations and implement their construction steps.
Don’t forget about implementing a method for fetching the result of the construction. The reason why this method can’t be declared inside the builder interface is that various builders may construct products that don’t have a common interface. Therefore, you don’t know what would be the return type for such a method. However, if you’re dealing with products from a single hierarchy, the fetching method can be safely added to the base interface.


Think about creating a director class. It may encapsulate various ways to construct a product using the same builder object.


The client code creates both the builder and the director objects. Before construction starts, the client must pass a builder object to the director. Usually, the client does this only once, via parameters of the director’s class constructor. The director uses the builder object in all further construction. There’s an alternative approach, where the builder is passed to a specific product construction method of the director.


The construction result can be obtained directly from the director only if all products follow the same interface. Otherwise, the client should fetch the result from the builder.




 You can construct objects step-by-step, defer construction steps or run steps recursively.

 You can reuse the same construction code when building various representations of products.

 Single Responsibility Principle. You can isolate complex construction code from the business logic of the product.




 The overall complexity of the code increases since the pattern requires creating multiple new classes.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.


You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.


You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
146,0,adapter,"
The adapter gets an interface, compatible with one of the existing objects.
Using this interface, the existing object can safely call the adapter’s methods.
Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects.

Object adapter
This implementation uses the object composition principle: the adapter implements the interface of one object and wraps the other one. It can be implemented in all popular programming languages.






The Client is a class that contains the existing business logic of the program.


The Client Interface describes a protocol that other classes must follow to be able to collaborate with the client code.


The Service is some useful class (usually 3rd-party or legacy). The client can’t use this class directly because it has an incompatible interface.


The Adapter is a class that’s able to work with both the client and the service: it implements the client interface, while wrapping the service object. The adapter receives calls from the client via the adapter interface and translates them into calls to the wrapped service object in a format it can understand.


The client code doesn’t get coupled to the concrete adapter class as long as it works with the adapter via the client interface. Thanks to this, you can introduce new types of adapters into the program without breaking the existing client code. This can be useful when the interface of the service class gets changed or replaced: you can just create a new adapter class without changing the client code.

Class adapter
This implementation uses inheritance: the adapter inherits interfaces from both objects at the same time. Note that this approach can only be implemented in programming languages that support multiple inheritance, such as C++.






The Class Adapter doesn’t need to wrap any objects because it inherits behaviors from both the client and the service. The adaptation happens within the overridden methods. The resulting adapter can be used in place of an existing client class.




 Use the Adapter class when you want to use some existing class, but its interface isn’t compatible with the rest of your code.

 The Adapter pattern lets you create a middle-layer class that serves as a translator between your code and a legacy class, a 3rd-party class or any other class with a weird interface.


 Use the pattern when you want to reuse several existing subclasses that lack some common functionality that can’t be added to the superclass.

 You could extend each subclass and put the missing functionality into new child classes. However, you’ll need to duplicate the code across all of these new classes, which smells really bad.
The much more elegant solution would be to put the missing functionality into an adapter class. Then you would wrap objects with missing features inside the adapter, gaining needed features dynamically. For this to work, the target classes must have a common interface, and the adapter’s field should follow that interface. This approach looks very similar to the Decorator pattern.



Make sure that you have at least two classes with incompatible interfaces:

A useful service class, which you can’t change (often 3rd-party, legacy or with lots of existing dependencies).
One or several client classes that would benefit from using the service class.



Declare the client interface and describe how clients communicate with the service.


Create the adapter class and make it follow the client interface. Leave all the methods empty for now.


Add a field to the adapter class to store a reference to the service object. The common practice is to initialize this field via the constructor, but sometimes it’s more convenient to pass it to the adapter when calling its methods.


One by one, implement all methods of the client interface in the adapter class. The adapter should delegate most of the real work to the service object, handling only the interface or data format conversion.


Clients should use the adapter via the client interface. This will let you change or extend the adapters without affecting the client code.




 Single Responsibility Principle. You can separate the interface or data conversion code from the primary business logic of the program.

 Open/Closed Principle. You can introduce new types of adapters into the program without breaking the existing client code, as long as they work with the adapters through the client interface.




 The overall complexity of the code increases because you need to introduce a set of new interfaces and classes. Sometimes it’s simpler just to change the service class so that it matches the rest of your code.



Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.


Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.


Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.


Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.

"
147,0,abstract_factory,"

A family of related products, say: Chair + Sofa + CoffeeTable.


Several variants of this family. For example, products Chair + Sofa + CoffeeTable are available in these variants: Modern, Victorian, ArtDeco.






Abstract Products declare interfaces for a set of distinct but related products which make up a product family.


Concrete Products are various implementations of abstract products, grouped by variants. Each abstract product (chair/sofa) must be implemented in all given variants (Victorian/Modern).


The Abstract Factory interface declares a set of methods for creating each of the abstract products.


Concrete Factories implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.


Although concrete factories instantiate concrete products, signatures of their creation methods must return corresponding abstract products. This way the client code that uses a factory doesn’t get coupled to the specific variant of the product it gets from a factory. The Client can work with any concrete factory/product variant, as long as it communicates with their objects via abstract interfaces.




 Use the Abstract Factory when your code needs to work with various families of related products, but you don’t want it to depend on the concrete classes of those products—they might be unknown beforehand or you simply want to allow for future extensibility.

 The Abstract Factory provides you with an interface for creating objects from each class of the product family. As long as your code creates objects via this interface, you don’t have to worry about creating the wrong variant of a product which doesn’t match the products already created by your app.


 Consider implementing the Abstract Factory when you have a class with a set of Factory Methods that blur its primary responsibility.

 In a well-designed program each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.



Map out a matrix of distinct product types versus variants of these products.


Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.


Declare the abstract factory interface with a set of creation methods for all abstract products.


Implement a set of concrete factory classes, one for each product variant.


Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.


Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.




 You can be sure that the products you’re getting from a factory are compatible with each other.

 You avoid tight coupling between concrete products and client code.

 Single Responsibility Principle. You can extract the product creation code into one place, making the code easier to support.

 Open/Closed Principle. You can introduce new variants of products without breaking existing client code.




 The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.


Read our Factory Comparison to learn more about the differences between various factory patterns and concepts.
"
148,0,facade,"




The Facade provides convenient access to a particular part of the subsystem’s functionality. It knows where to direct the client’s request and how to operate all the moving parts.


An Additional Facade class can be created to prevent polluting a single facade with unrelated features that might make it yet another complex structure. Additional facades can be used by both clients and other facades.


The Complex Subsystem consists of dozens of various objects. To make them all do something meaningful, you have to dive deep into the subsystem’s implementation details, such as initializing objects in the correct order and supplying them with data in the proper format.
Subsystem classes aren’t aware of the facade’s existence. They operate within the system and work with each other directly.


The Client uses the facade instead of calling the subsystem objects directly.




 Use the Facade pattern when you need to have a limited but straightforward interface to a complex subsystem.

 Often, subsystems get more complex over time. Even applying design patterns typically leads to creating more classes. A subsystem may become more flexible and easier to reuse in various contexts, but the amount of configuration and boilerplate code it demands from a client grows ever larger. The Facade attempts to fix this problem by providing a shortcut to the most-used features of the subsystem which fit most client requirements.


 Use the Facade when you want to structure a subsystem into layers.

 Create facades to define entry points to each level of a subsystem. You can reduce coupling between multiple subsystems by requiring them to communicate only through facades.
For example, let’s return to our video conversion framework. It can be broken down into two layers: video- and audio-related. For each layer, you can create a facade and then make the classes of each layer communicate with each other via those facades. This approach looks very similar to the Mediator pattern.



Check whether it’s possible to provide a simpler interface than what an existing subsystem already provides. You’re on the right track if this interface makes the client code independent from many of the subsystem’s classes.


Declare and implement this interface in a new facade class. The facade should redirect the calls from the client code to appropriate objects of the subsystem. The facade should be responsible for initializing the subsystem and managing its further life cycle unless the client code already does this.


To get the full benefit from the pattern, make all the client code communicate with the subsystem only via the facade. Now the client code is protected from any changes in the subsystem code. For example, when a subsystem gets upgraded to a new version, you will only need to modify the code in the facade.


If the facade becomes too big, consider extracting part of its behavior to a new, refined facade class.




 You can isolate your code from the complexity of a subsystem.




 A facade can become a god object coupled to all classes of an app.



Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.


Facade defines a simplified interface to a subsystem of objects, but it doesn’t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

Mediator centralizes communication between components of the system. The components only know about the mediator object and don’t communicate directly.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.

"
149,0,flyweight,"Extrinsic state storageFlyweight and immutabilityFlyweight factory




The Flyweight pattern is merely an optimization. Before applying it, make sure your program does have the RAM consumption problem related to having a massive number of similar objects in memory at the same time. Make sure that this problem can’t be solved in any other meaningful way.


The Flyweight class contains the portion of the original object’s state that can be shared between multiple objects. The same flyweight object can be used in many different contexts. The state stored inside a flyweight is called intrinsic. The state passed to the flyweight’s methods is called extrinsic.


The Context class contains the extrinsic state, unique across all original objects. When a context is paired with one of the flyweight objects, it represents the full state of the original object.


Usually, the behavior of the original object remains in the flyweight class. In this case, whoever calls a flyweight’s method must also pass appropriate bits of the extrinsic state into the method’s parameters. On the other hand, the behavior can be moved to the context class, which would use the linked flyweight merely as a data object.


The Client calculates or stores the extrinsic state of flyweights. From the client’s perspective, a flyweight is a template object which can be configured at runtime by passing some contextual data into parameters of its methods.


The Flyweight Factory manages a pool of existing flyweights. With the factory, clients don’t create flyweights directly. Instead, they call the factory, passing it bits of the intrinsic state of the desired flyweight. The factory looks over previously created flyweights and either returns an existing one that matches search criteria or creates a new one if nothing is found.




 Use the Flyweight pattern only when your program must support a huge number of objects which barely fit into available RAM.

 The benefit of applying the pattern depends heavily on how and where it’s used. It’s most useful when:

an application needs to spawn a huge number of similar objects
this drains all available RAM on a target device
the objects contain duplicate states which can be extracted and shared between multiple objects




Divide fields of a class that will become a flyweight into two parts:

the intrinsic state: the fields that contain unchanging data duplicated across many objects
the extrinsic state: the fields that contain contextual data unique to each object



Leave the fields that represent the intrinsic state in the class, but make sure they’re immutable. They should take their initial values only inside the constructor.


Go over methods that use fields of the extrinsic state. For each field used in the method, introduce a new parameter and use it instead of the field.


Optionally, create a factory class to manage the pool of flyweights. It should check for an existing flyweight before creating a new one. Once the factory is in place, clients must only request flyweights through it. They should describe the desired flyweight by passing its intrinsic state to the factory.


The client must store or calculate values of the extrinsic state (context) to be able to call methods of flyweight objects. For the sake of convenience, the extrinsic state along with the flyweight-referencing field may be moved to a separate context class.




 You can save lots of RAM, assuming your program has tons of similar objects.




 You might be trading RAM over CPU cycles when some of the context data needs to be recalculated each time somebody calls a flyweight method.

 The code becomes much more complicated. New team members will always be wondering why the state of an entity was separated in such a way.



You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.


"
150,0,chain_of_responsibility,"

One of your colleagues suggested that it’s unsafe to pass raw data straight to the ordering system. So you added an extra validation step to sanitize the data in a request.


Later, somebody noticed that the system is vulnerable to brute force password cracking. To negate this, you promptly added a check that filters repeated failed requests coming from the same IP address.


Someone else suggested that you could speed up the system by returning cached results on repeated requests containing the same data. Hence, you added another check which lets the request pass through to the system only if there’s no suitable cached response.






The Handler declares the interface, common for all concrete handlers. It usually  contains just a single method for handling requests, but sometimes it may also have another method for setting the next handler on the chain.


The Base Handler is an optional class where you can put the boilerplate code that’s common to all handler classes.
Usually, this class defines a field for storing a reference to the next handler. The clients can build a chain by passing a handler to the constructor or setter of the previous handler. The class may also implement the default handling behavior: it can pass execution to the next handler after checking for its existence.


Concrete Handlers contain the actual code for processing requests. Upon receiving a request, each handler must decide whether to process it and, additionally, whether to pass it along the chain.
Handlers are usually self-contained and immutable, accepting all necessary data just once via the constructor.


The Client may compose chains just once or compose them dynamically, depending on the application’s logic. Note that a request can be sent to any handler in the chain—it doesn’t have to be the first one.




 Use the Chain of Responsibility pattern when your program is expected to process different kinds of requests in various ways, but the exact types of requests and their sequences are unknown beforehand.

 The pattern lets you link several handlers into one chain and, upon receiving a request, “ask” each handler whether it can process it. This way all handlers get a chance to process the request.


 Use the pattern when it’s essential to execute several handlers in a particular order.

 Since you can link the handlers in the chain in any order, all requests will get through the chain exactly as you planned.


 Use the CoR pattern when the set of handlers and their order are supposed to change at runtime.

 If you provide setters for a reference field inside the handler classes, you’ll be able to insert, remove or reorder handlers dynamically.



Declare the handler interface and describe the signature of a method for handling requests.
Decide how the client will pass the request data into the method. The most flexible way is to convert the request into an object and pass it to the handling method as an argument.


To eliminate duplicate boilerplate code in concrete handlers, it might be worth creating an abstract base handler class, derived from the handler interface.
This class should have a field for storing a reference to the next handler in the chain. Consider making the class immutable. However, if you plan to modify chains at runtime, you need to define a setter for altering the value of the reference field.
You can also implement the convenient default behavior for the handling method, which is to forward the request to the next object unless there’s none left. Concrete handlers will be able to use this behavior by calling the parent method.


One by one create concrete handler subclasses and implement their handling methods. Each handler should make two decisions when receiving a request:

Whether it’ll process the request.
Whether it’ll pass the request along the chain.



The client may either assemble chains on its own or receive pre-built chains from other objects. In the latter case, you must implement some factory classes to build chains according to the configuration or environment settings.


The client may trigger any handler in the chain, not just the first one. The request will be passed along the chain until some handler refuses to pass it further or until it reaches the end of the chain.


Due to the dynamic nature of the chain, the client should be ready to handle the following scenarios:

The chain may consist of a single link.
Some requests may not reach the end of the chain.
Others may reach the end of the chain unhandled.





 You can control the order of request handling.

 Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform operations.

 Open/Closed Principle. You can introduce new handlers into the app without breaking the existing client code.




 Some requests may end up unhandled.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.


Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.
However, there’s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.


Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.
The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.

"
151,0,prototype,"
Basic implementation






The Prototype interface declares the cloning methods. In most cases, it’s a single clone method.


The Concrete Prototype class implements the cloning method. In addition to copying the original object’s data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies, etc.


The Client can produce a copy of any object that follows the prototype interface.

Prototype registry implementation






The Prototype Registry provides an easy way to access frequently-used prototypes. It stores a set of pre-built objects that are ready to be copied. The simplest prototype registry is a name → prototype hash map. However, if you need better search criteria than a simple name, you can build a much more robust version of the registry.




 Use the Prototype pattern when your code shouldn’t depend on the concrete classes of objects that you need to copy.

 This happens a lot when your code works with objects passed to you from 3rd-party code via some interface. The concrete classes of these objects are unknown, and you couldn’t depend on them even if you wanted to.
The Prototype pattern provides the client code with a general interface for working with all objects that support cloning. This interface makes the client code independent from the concrete classes of objects that it clones.


 Use the pattern when you want to reduce the number of subclasses that only differ in the way they initialize their respective objects.

 Suppose you have a complex class that requires a laborious configuration before it can be used. There are several common ways to configure this class, and this code is scattered through your app. To reduce the duplication, you create several subclasses and put every common configuration code into their constructors. You solved the duplication problem, but now you have lots of dummy subclasses.
The Prototype pattern lets you use a set of pre-built objects configured in various ways as prototypes. Instead of instantiating a subclass that matches some configuration, the client can simply look for an appropriate prototype and clone it.



Create the prototype interface and declare the clone method in it. Or just add the method to all classes of an existing class hierarchy, if you have one.


A prototype class must define the alternative constructor that accepts an object of that class as an argument. The constructor must copy the values of all fields defined in the class from the passed object into the newly created instance. If you’re changing a subclass, you must call the parent constructor to let the superclass handle the cloning of its private fields.
If your programming language doesn’t support method overloading, you won’t be able to create a separate “prototype” constructor. Thus, copying the object’s data into the newly created clone will have to be performed within the clone method. Still, having this code in a regular constructor is safer because the resulting object is returned fully configured right after you call the new operator.


The cloning method usually consists of just one line: running a new operator with the prototypical version of the constructor. Note, that every class must explicitly override the cloning method and use its own class name along with the new operator. Otherwise, the cloning method may produce an object of a parent class.


Optionally, create a centralized prototype registry to store a catalog of frequently used prototypes.
You can implement the registry as a new factory class or put it in the base prototype class with a static method for fetching the prototype. This method should search for a prototype based on search criteria that the client code passes to the method. The criteria might either be a simple string tag or a complex set of search parameters. After the appropriate prototype is found, the registry should clone it and return the copy to the client.
Finally, replace the direct calls to the subclasses’ constructors with calls to the factory method of the prototype registry.




 You can clone objects without coupling to their concrete classes.

 You can get rid of repeated initialization code in favor of cloning pre-built prototypes.

 You can produce complex objects more conveniently.

 You get an alternative to inheritance when dealing with configuration presets for complex objects.




 Cloning complex objects that have circular references might be very tricky.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


Prototype can help when you need to save copies of Commands into history.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.


Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.


Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
152,0,decorator,"
Inheritance is static. You can’t alter the behavior of an existing object at runtime. You can only replace the whole object with another one that’s created from a different subclass.
Subclasses can have just one parent class. In most languages, inheritance doesn’t let a class inherit behaviors of multiple classes at the same time.





The Component declares the common interface for both wrappers and wrapped objects.


Concrete Component is a class of objects being wrapped. It defines the basic behavior, which can be altered by decorators.


The Base Decorator class has a field for referencing a wrapped object. The field’s type should be declared as the component interface so it can contain both concrete components and decorators. The base decorator delegates all operations to the wrapped object.


Concrete Decorators define extra behaviors that can be added to components dynamically. Concrete decorators override methods of the base decorator and execute their behavior either before or after calling the parent method.


The Client can wrap components in multiple layers of decorators, as long as it works with all objects via the component interface.




Just before the data is written to disk, the decorators encrypt and compress it. The original class writes the encrypted and protected data to the file without knowing about the change.


Right after the data is read from disk, it goes through the same decorators, which decompress and decode it.



 Use the Decorator pattern when you need to be able to assign extra behaviors to objects at runtime without breaking the code that uses these objects.

 The Decorator lets you structure your business logic into layers, create a decorator for each layer and compose objects with various combinations of this logic at runtime. The client code can treat all these objects in the same way, since they all follow a common interface.


 Use the pattern when it’s awkward or not possible to extend an object’s behavior using inheritance.

 Many programming languages have the final keyword that can be used to prevent further extension of a class. For a final class, the only way to reuse the existing behavior would be to wrap the class with your own wrapper, using the Decorator pattern.



Make sure your business domain can be represented as a primary component with multiple optional layers over it.


Figure out what methods are common to both the primary component and the optional layers. Create a component interface and declare those methods there.


Create a concrete component class and define the base behavior in it.


Create a base decorator class. It should have a field for storing a reference to a wrapped object. The field should be declared with the component interface type to allow linking to concrete components as well as decorators. The base decorator must delegate all work to the wrapped object.


Make sure all classes implement the component interface.


Create concrete decorators by extending them from the base decorator. A concrete decorator must execute its behavior before or after the call to the parent method (which always delegates to the wrapped object).


The client code must be responsible for creating decorators and composing them in the way the client needs.




 You can extend an object’s behavior without making a new subclass.

 You can add or remove responsibilities from an object at runtime.

 You can combine several behaviors by wrapping an object into multiple decorators.

 Single Responsibility Principle. You can divide a monolithic class that implements many possible variants of behavior into several smaller classes.




 It’s hard to remove a specific wrapper from the wrappers stack.

 It’s hard to implement a decorator in such a way that its behavior doesn’t depend on the order in the decorators stack.

 The initial configuration code of layers might look pretty ugly.



Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.


Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.
The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.


Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.
A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.
However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.


Decorator lets you change the skin of an object, while Strategy lets you change the guts.


Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.

"
153,0,composite,"




The Component interface describes operations that are common to both simple and complex elements of the tree.


The Leaf is a basic element of a tree that doesn’t have sub-elements.
Usually, leaf components end up doing most of the real work, since they don’t have anyone to delegate the work to.


The Container (aka composite) is an element that has sub-elements: leaves or other containers. A container doesn’t know the concrete classes of its children. It works with all sub-elements only via the component interface.
Upon receiving a request, a container delegates the work to its sub-elements, processes intermediate results and then returns the final result to the client.


The Client works with all elements through the component interface. As a result, the client can work in the same way with both simple or complex elements of the tree.




 Use the Composite pattern when you have to implement a tree-like object structure.

 The Composite pattern provides you with two basic element types that share a common interface: simple leaves and complex containers. A container can be composed of both leaves and other containers. This lets you construct a nested recursive object structure that resembles a tree.


 Use the pattern when you want the client code to treat both simple and complex elements uniformly.

 All elements defined by the Composite pattern share a common interface. Using this interface, the client doesn’t have to worry about the concrete class of the objects it works with.



Make sure that the core model of your app can be represented as a tree structure. Try to break it down into simple elements and containers. Remember that containers must be able to contain both simple elements and other containers.


Declare the component interface with a list of methods that make sense for both simple and complex components.


Create a leaf class to represent simple elements. A program may have multiple different leaf classes.


Create a container class to represent complex elements. In this class, provide an array field for storing references to sub-elements. The array must be able to store both leaves and containers, so make sure it’s declared with the component interface type.
While implementing the methods of the component interface, remember that a container is supposed to be delegating most of the work to sub-elements.


Finally, define the methods for adding and removal of child elements in the container.
Keep in mind that these operations can be declared in the component interface. This would violate the Interface Segregation Principle because the methods will be empty in the leaf class. However, the client will be able to treat all the elements equally, even when composing the tree.




 You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage.

 Open/Closed Principle. You can introduce new element types into the app without breaking the existing code, which now works with the object tree.




 It might be difficult to provide a common interface for classes whose functionality differs too much. In certain scenarios, you’d need to overgeneralize the component interface, making it harder to comprehend.



You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.


Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.


You can use Iterators to traverse Composite trees.


You can use Visitor to execute an operation over an entire Composite tree.


You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.
A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.
However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.

"
154,0,bridge,"Abstraction and Implementation
Have several different GUIs (for instance, tailored for regular customers or admins).
Support several different APIs (for example, to be able to launch the app under Windows, Linux, and macOS).

Abstraction: the GUI layer of the app.
Implementation: the operating systems’ APIs.





The Abstraction provides high-level control logic. It relies on the implementation object to do the actual low-level work.


The Implementation declares the interface that’s common for all concrete implementations. An abstraction can only communicate with an implementation object via methods that are declared here.
The abstraction may list the same methods as the implementation, but usually the abstraction declares some complex behaviors that rely on a wide variety of primitive operations declared by the implementation.


Concrete Implementations contain platform-specific code.


Refined Abstractions provide variants of control logic. Like their parent, they work with different implementations via the general implementation interface.


Usually, the Client is only interested in working with the abstraction. However, it’s the client’s job to link the abstraction object with one of the implementation objects.




 Use the Bridge pattern when you want to divide and organize a monolithic class that has several variants of some functionality (for example, if the class can work with various database servers).

 The bigger a class becomes, the harder it is to figure out how it works, and the longer it takes to make a change. The changes made to one of the variations of functionality may require making changes across the whole class, which often results in making errors or not addressing some critical side effects.
The Bridge pattern lets you split the monolithic class into several class hierarchies. After this, you can change the classes in each hierarchy independently of the classes in the others. This approach simplifies code maintenance and minimizes the risk of breaking existing code.


 Use the pattern when you need to extend a class in several orthogonal (independent) dimensions.

 The Bridge suggests that you extract a separate class hierarchy for each of the dimensions. The original class delegates the related work to the objects belonging to those hierarchies instead of doing everything on its own.


 Use the Bridge if you need to be able to switch implementations at runtime.

 Although it’s optional, the Bridge pattern lets you replace the implementation object inside the abstraction. It’s as easy as assigning a new value to a field.
By the way, this last item is the main reason why so many people confuse the Bridge with the Strategy pattern. Remember that a pattern is more than just a certain way to structure your classes. It may also communicate intent and a problem being addressed.



Identify the orthogonal dimensions in your classes. These independent concepts could be: abstraction/platform, domain/infrastructure, front-end/back-end, or interface/implementation.


See what operations the client needs and define them in the base abstraction class.


Determine the operations available on all platforms. Declare the ones that the abstraction needs in the general implementation interface.


For all platforms in your domain create concrete implementation classes, but make sure they all follow the implementation interface.


Inside the abstraction class, add a reference field for the implementation type. The abstraction delegates most of the work to the implementation object that’s referenced in that field.


If you have several variants of high-level logic, create refined abstractions for each variant by extending the base abstraction class.


The client code should pass an implementation object to the abstraction’s constructor to associate one with the other. After that, the client can forget about the implementation and work only with the abstraction object.




 You can create platform-independent classes and apps.

 The client code works with high-level abstractions. It isn’t exposed to the platform details.

 Open/Closed Principle. You can introduce new abstractions and implementations independently from each other.

 Single Responsibility Principle. You can focus on high-level logic in the abstraction and on platform details in the implementation.




 You might make the code more complicated by applying the pattern to a highly cohesive class.



Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.


Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.


You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.

"
155,0,singleton,"

Ensure that a class has just a single instance. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource—for example, a database or a file.
Here’s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you’ll get the one you already created.
Note that this behavior is impossible to implement with a regular constructor since a constructor call must always return a new object by design.


Make the default constructor private, to prevent other objects from using the new operator with the Singleton class.
Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.





The Singleton class declares the static method getInstance that returns the same instance of its own class.
The Singleton’s constructor should be hidden from the client code. Calling the getInstance method should be the only way of getting the Singleton object.




 Use the Singleton pattern when a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program.

 The Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created.


 Use the Singleton pattern when you need stricter control over global variables.

 Unlike global variables, the Singleton pattern guarantees that there’s just one instance of a class. Nothing, except for the Singleton class itself, can replace the cached instance.
Note that you can always adjust this limitation and allow creating any number of Singleton instances. The only piece of code that needs changing is the body of the getInstance method.



Add a private static field to the class for storing the singleton instance.


Declare a public static creation method for getting the singleton instance.


Implement “lazy initialization” inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.


Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.


Go over the client code and replace all direct calls to the singleton’s constructor with calls to its static creation method.




 You can be sure that a class has only a single instance.

 You gain a global access point to that instance.

 The singleton object is initialized only when it’s requested for the first time.




 Violates the Single Responsibility Principle. The pattern solves two problems at the time.

 The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other.

 The pattern requires special treatment in a multithreaded environment so that multiple threads won’t create a singleton object several times.

 It may be difficult to unit test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don’t write the tests. Or don’t use the Singleton pattern.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.



Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
156,0,proxy,"




The Service Interface declares the interface of the Service. The proxy must follow this interface to be able to disguise itself as a service object.


The Service is a class that provides some useful business logic.


The Proxy class has a reference field that points to a service object. After the proxy finishes its processing (e.g., lazy initialization, logging, access control, caching, etc.), it passes the request to the service object.
Usually, proxies manage the full lifecycle of their service objects.


The Client should work with both services and proxies via the same interface. This way you can pass a proxy into any code that expects a service object.



There are dozens of ways to utilize the Proxy pattern. Let’s go over the most popular uses.

 Lazy initialization (virtual proxy). This is when you have a heavyweight service object that wastes system resources by being always up, even though you only need it from time to time.

 Instead of creating the object when the app launches, you can delay the object’s initialization to a time when it’s really needed.


 Access control (protection proxy). This is when you want only specific clients to be able to use the service object; for instance, when your objects are crucial parts of an operating system and clients are various launched applications (including malicious ones).

 The proxy can pass the request to the service object only if the client’s credentials match some criteria.


 Local execution of a remote service (remote proxy). This is when the service object is located on a remote server.

 In this case, the proxy passes the client request over the network, handling all of the nasty details of working with the network.


 Logging requests (logging proxy). This is when you want to keep a history of requests to the service object.

 The proxy can log each request before passing it to the service.


 Caching request results (caching proxy). This is when you need to cache results of client requests and manage the life cycle of this cache, especially if results are quite large.

 The proxy can implement caching for recurring requests that always yield the same results. The proxy may use the parameters of requests as the cache keys.


 Smart reference. This is when you need to be able to dismiss a heavyweight object once there are no clients that use it.

 The proxy can keep track of clients that obtained a reference to the service object or its results. From time to time, the proxy may go over the clients and check whether they are still active. If the client list gets empty, the proxy might dismiss the service object and free the underlying system resources.
The proxy can also track whether the client had modified the service object. Then the unchanged objects may be reused by other clients.



If there’s no pre-existing service interface, create one to make proxy and service objects interchangeable. Extracting the interface from the service class isn’t always possible, because you’d need to change all of the service’s clients to use that interface. Plan B is to make the proxy a subclass of the service class, and this way it’ll inherit the interface of the service.


Create the proxy class. It should have a field for storing a reference to the service. Usually, proxies create and manage the whole life cycle of their services. On rare occasions, a service is passed to the proxy via a constructor by the client.


Implement the proxy methods according to their purposes. In most cases, after doing some work, the proxy should delegate the work to the service object.


Consider introducing a creation method that decides whether the client gets a proxy or a real service. This can be a simple static method in the proxy class or a full-blown factory method.


Consider implementing lazy initialization for the service object.




 You can control the service object without clients knowing about it.

 You can manage the lifecycle of the service object when clients don’t care about it.

 The proxy works even if the service object isn’t ready or is not available.

 Open/Closed Principle. You can introduce new proxies without changing the service or clients.




 The code may become more complicated since you need to introduce a lot of new classes.

 The response from the service might get delayed.



Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.


Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.

"
157,0,command,"




The Sender class (aka invoker) is responsible for initiating requests. This class must have a field for storing a reference to a command object. The sender triggers that command instead of sending the request directly to the receiver. Note that the sender isn’t responsible for creating the command object. Usually, it gets a pre-created command from the client via the constructor.


The Command interface usually declares just a single method for executing the command.


Concrete Commands implement various kinds of requests. A concrete command isn’t supposed to perform the work on its own, but rather to pass the call to one of the business logic objects. However, for the sake of simplifying the code, these classes can be merged.
Parameters required to execute a method on a receiving object can be declared as fields in the concrete command. You can make command objects immutable by only allowing the initialization of these fields via the constructor.


The Receiver class contains some business logic. Almost any object may act as a receiver. Most commands only handle the details of how a request is passed to the receiver, while the receiver itself does the actual work.


The Client creates and configures concrete command objects. The client must pass all of the request parameters, including a receiver instance, into the command’s constructor. After that, the resulting command may be associated with one or multiple senders.




 Use the Command pattern when you want to parametrize objects with operations.

 The Command pattern can turn a specific method call into a stand-alone object. This change opens up a lot of interesting uses: you can pass commands as method arguments, store them inside other objects, switch linked commands at runtime, etc.
Here’s an example: you’re developing a GUI component such as a context menu, and you want your users to be able to configure menu items that trigger operations when an end user clicks an item.


 Use the Command pattern when you want to queue operations, schedule their execution, or execute them remotely.

 As with any other object, a command can be serialized, which means converting it to a string that can be easily written to a file or a database. Later, the string can be restored as the initial command object. Thus, you can delay and schedule command execution. But there’s even more! In the same way, you can queue, log or send commands over the network.


 Use the Command pattern when you want to implement reversible operations.

 Although there are many ways to implement undo/redo, the Command pattern is perhaps the most popular of all.
To be able to revert operations, you need to implement the history of performed operations. The command history is a stack that contains all executed command objects along with related backups of the application’s state.
This method has two drawbacks. First, it isn’t that easy to save an application’s state because some of it can be private. This problem can be mitigated with the Memento pattern.
Second, the state backups may consume quite a lot of RAM. Therefore, sometimes you can resort to an alternative implementation: instead of restoring the past state, the command performs the inverse operation. The reverse operation also has a price: it may turn out to be hard or even impossible to implement.



Declare the command interface with a single execution method.


Start extracting requests into concrete command classes that implement the command interface. Each class must have a set of fields for storing the request arguments along with a reference to the actual receiver object. All these values must be initialized via the command’s constructor.


Identify classes that will act as senders. Add the fields for storing commands into these classes. Senders should communicate with their commands only via the command interface. Senders usually don’t create command objects on their own, but rather get them from the client code.


Change the senders so they execute the command instead of sending a request to the receiver directly.


The client should initialize objects in the following order:

Create receivers.
Create commands, and associate them with receivers if needed.
Create senders, and associate them with specific commands.





 Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform these operations.

 Open/Closed Principle. You can introduce new commands into the app without breaking existing client code.

 You can implement undo/redo.

 You can implement deferred execution of operations.

 You can assemble a set of simple commands into a complex one.




 The code may become more complicated since you’re introducing a whole new layer between senders and receivers.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.
However, there’s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.


You can use Command and Memento together when implementing “undo”. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.


Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.


You can use Command to convert any operation into an object. The operation’s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.


On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.




Prototype can help when you need to save copies of Commands into history.


You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.

"
158,0,iterator,"




The Iterator interface declares the operations required for traversing a collection: fetching the next element, retrieving the current position, restarting iteration, etc.


Concrete Iterators implement specific algorithms for traversing a collection. The iterator object should track the traversal progress on its own. This allows several iterators to traverse the same collection independently of each other.


The Collection interface declares one or multiple methods for getting iterators compatible with the collection. Note that the return type of the methods must be declared as the iterator interface so that the concrete collections can return various kinds of iterators.


Concrete Collections return new instances of a particular concrete iterator class each time the client requests one. You might be wondering, where’s the rest of the collection’s code? Don’t worry, it should be in the same class. It’s just that these details aren’t crucial to the actual pattern, so we’re omitting them.


The Client works with both collections and iterators via their interfaces. This way the client isn’t coupled to concrete classes, allowing you to use various collections and iterators with the same client code.
Typically, clients don’t create iterators on their own, but instead get them from collections. Yet, in certain cases, the client can create one directly; for example, when the client defines its own special iterator.




 Use the Iterator pattern when your collection has a complex data structure under the hood, but you want to hide its complexity from clients (either for convenience or security reasons).

 The iterator encapsulates the details of working with a complex data structure, providing the client with several simple methods of accessing the collection elements. While this approach is very convenient for the client, it also protects the collection from careless or malicious actions which the client would be able to perform if working with the collection directly.


 Use the pattern to reduce duplication of the traversal code across your app.

 The code of non-trivial iteration algorithms tends to be very bulky. When placed within the business logic of an app, it may blur the responsibility of the original code and make it less maintainable. Moving the traversal code to designated iterators can help you make the code of the application more lean and clean.


 Use the Iterator when you want your code to be able to traverse different data structures or when types of these structures are unknown beforehand.

 The pattern provides a couple of generic interfaces for both collections and iterators. Given that your code now uses these interfaces, it’ll still work if you pass it various kinds of collections and iterators that implement these interfaces.



Declare the iterator interface. At the very least, it must have a method for fetching the next element from a collection. But for the sake of convenience you can add a couple of other methods, such as fetching the previous element, tracking the current position, and checking the end of the iteration.


Declare the collection interface and describe a method for fetching iterators. The return type should be equal to that of the iterator interface. You may declare similar methods if you plan to have several distinct groups of iterators.


Implement concrete iterator classes for the collections that you want to be traversable with iterators. An iterator object must be linked with a single collection instance. Usually, this link is established via the iterator’s constructor.


Implement the collection interface in your collection classes. The main idea is to provide the client with a shortcut for creating iterators, tailored for a particular collection class. The collection object must pass itself to the iterator’s constructor to establish a link between them.


Go over the client code to replace all of the collection traversal code with the use of iterators. The client fetches a new iterator object each time it needs to iterate over the collection elements.




 Single Responsibility Principle. You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes.

 Open/Closed Principle. You can implement new types of collections and iterators and pass them to existing code without breaking anything.

 You can iterate over the same collection in parallel because each iterator object contains its own iteration state.

 For the same reason, you can delay an iteration and continue it when needed.




 Applying the pattern can be an overkill if your app only works with simple collections.

 Using an iterator may be less efficient than going through elements of some specialized collections directly.



You can use Iterators to traverse Composite trees.


You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.


You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.


You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.

"
159,0,mediator,"




Components are various classes that contain some business logic. Each component has a reference to a mediator, declared with the type of the mediator interface. The component isn’t aware of the actual class of the mediator, so you can reuse the component in other programs by linking it to a different mediator.


The Mediator interface declares methods of communication with components, which usually include just a single notification method. Components may pass any context as arguments of this method, including their own objects, but only in such a way that no coupling occurs between a receiving component and the sender’s class.


Concrete Mediators encapsulate relations between various components. Concrete mediators often keep references to all components they manage and sometimes even manage their lifecycle.


Components must not be aware of other components. If something important happens within or to a component, it must only notify the mediator. When the mediator receives the notification, it can easily identify the sender, which might be just enough to decide what component should be triggered in return.
From a component’s perspective, it all looks like a total black box. The sender doesn’t know who’ll end up handling its request, and the receiver doesn’t know who sent the request in the first place.




 Use the Mediator pattern when it’s hard to change some of the classes because they are tightly coupled to a bunch of other classes.

 The pattern lets you extract all the relationships between classes into a separate class, isolating any changes to a specific component from the rest of the components.


 Use the pattern when you can’t reuse a component in a different program because it’s too dependent on other components.

 After you apply the Mediator, individual components become unaware of the other components. They could still communicate with each other, albeit indirectly, through a mediator object. To reuse a component in a different app, you need to provide it with a new mediator class.


 Use the Mediator when you find yourself creating tons of component subclasses just to reuse some basic behavior in various contexts.

 Since all relations between components are contained within the mediator, it’s easy to define entirely new ways for these components to collaborate by introducing new mediator classes, without having to change the components themselves.



Identify a group of tightly coupled classes which would benefit from being more independent (e.g., for easier maintenance or simpler reuse of these classes).


Declare the mediator interface and describe the desired communication protocol between mediators and various components. In most cases, a single method for receiving notifications from components is sufficient.
This interface is crucial when you want to reuse component classes in different contexts. As long as the component works with its mediator via the generic interface, you can link the component with a different implementation of the mediator.


Implement the concrete mediator class. Consider storing references to all components inside the mediator. This way, you could call any component from the mediator’s methods.


You can go even further and make the mediator responsible for the creation and destruction of component objects. After this, the mediator may resemble a factory or a facade.


Components should store a reference to the mediator object. The connection is usually established in the component’s constructor, where a mediator object is passed as an argument.


Change the components’ code so that they call the mediator’s notification method instead of methods on other components. Extract the code that involves calling other components into the mediator class. Execute this code whenever the mediator receives notifications from that component.




 Single Responsibility Principle. You can extract the communications between various components into a single place, making it easier to comprehend and maintain.

 Open/Closed Principle. You can introduce new mediators without having to change the actual components.

 You can reduce coupling between various components of a program.

 You can reuse individual components more easily.




 Over time a mediator can evolve into a God Object.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.


Facade defines a simplified interface to a subsystem of objects, but it doesn’t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

Mediator centralizes communication between components of the system. The components only know about the mediator object and don’t communicate directly.



The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let’s see how we can do that.
The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.
There’s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator’s events. When Mediator is implemented this way, it may look very similar to Observer.
When you’re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won’t resemble Observer but will still be an instance of the Mediator pattern.
Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won’t be a centralized mediator object, only a distributed set of observers.

"
160,0,memento,"
Implementation based on nested classes
The classic implementation of the pattern relies on support for nested classes, available in many popular programming languages (such as C++, C#, and Java).






The Originator class can produce snapshots of its own state, as well as restore its state from snapshots when needed.


The Memento is a value object that acts as a snapshot of the originator’s state. It’s a common practice to make the memento immutable and pass it the data only once, via the constructor.


The Caretaker knows not only “when” and “why” to capture the originator’s state, but also when the state should be restored.
A caretaker can keep track of the originator’s history by storing a stack of mementos. When the originator has to travel back in history, the caretaker fetches the topmost memento from the stack and passes it to the originator’s restoration method.


In this implementation, the memento class is nested inside the originator. This lets the originator access the fields and methods of the memento, even though they’re declared private. On the other hand, the caretaker has very limited access to the memento’s fields and methods, which lets it store mementos in a stack but not tamper with their state.

Implementation based on an intermediate interface
There’s an alternative implementation, suitable for programming languages that don’t support nested classes (yeah, PHP, I’m talking about you).






In the absence of nested classes, you can restrict access to the memento’s fields by establishing a convention that caretakers can work with a memento only through an explicitly declared intermediary interface, which would only declare methods related to the memento’s metadata.


On the other hand, originators can work with a memento object directly, accessing fields and methods declared in the memento class. The downside of this approach is that you need to declare all members of the memento public.

Implementation with even stricter encapsulation
There’s another implementation which is useful when you don’t want to leave even the slightest chance of other classes accessing the state of the originator through the memento.






This implementation allows having multiple types of originators and mementos. Each originator works with a corresponding memento class. Neither originators nor mementos expose their state to anyone.


Caretakers are now explicitly restricted from changing the state stored in mementos. Moreover, the caretaker class becomes independent from the originator because the restoration method is now defined in the memento class.


Each memento becomes linked to the originator that produced it. The originator passes itself to the memento’s constructor, along with the values of its state. Thanks to the close relationship between these classes, a memento can restore the state of its originator, given that the latter has defined the appropriate setters.




 Use the Memento pattern when you want to produce snapshots of the object’s state to be able to restore a previous state of the object.

 The Memento pattern lets you make full copies of an object’s state, including private fields, and store them separately from the object. While most people remember this pattern thanks to the “undo” use case, it’s also indispensable when dealing with transactions (i.e., if you need to roll back an operation on error).


 Use the pattern when direct access to the object’s fields/getters/setters violates its encapsulation.

 The Memento makes the object itself responsible for creating a snapshot of its state. No other object can read the snapshot, making the original object’s state data safe and secure.



Determine what class will play the role of the originator. It’s important to know whether the program uses one central object of this type or multiple smaller ones.


Create the memento class. One by one, declare a set of fields that mirror the fields declared inside the originator class.


Make the memento class immutable. A memento should accept the data just once, via the constructor. The class should have no setters.


If your programming language supports nested classes, nest the memento inside the originator. If not, extract a blank interface from the memento class and make all other objects use it to refer to the memento. You may add some metadata operations to the interface, but nothing that exposes the originator’s state.


Add a method for producing mementos to the originator class. The originator should pass its state to the memento via one or multiple arguments of the memento’s constructor.
The return type of the method should be of the interface you extracted in the previous step (assuming that you extracted it at all). Under the hood, the memento-producing method should work directly with the memento class.


Add a method for restoring the originator’s state to its class. It should accept a memento object as an argument. If you extracted an interface in the previous step, make it the type of the parameter. In this case, you need to typecast the incoming object to the memento class, since the originator needs full access to that object.


The caretaker, whether it represents a command object, a history, or something entirely different, should know when to request new mementos from the originator, how to store them and when to restore the originator with a particular memento.


The link between caretakers and originators may be moved into the memento class. In this case, each memento must be connected to the originator that had created it. The restoration method would also move to the memento class. However, this would all make sense only if the memento class is nested into originator or the originator class provides sufficient setters for overriding its state.




 You can produce snapshots of the object’s state without violating its encapsulation.

 You can simplify the originator’s code by letting the caretaker maintain the history of the originator’s state.




 The app might consume lots of RAM if clients create mementos too often.

 Caretakers should track the originator’s lifecycle to be able to destroy obsolete mementos.

 Most dynamic programming languages, such as PHP, Python and JavaScript, can’t guarantee that the state within the memento stays untouched.



You can use Command and Memento together when implementing “undo”. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.


You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.


Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.

"
161,0,observer,"




The Publisher issues events of interest to other objects. These events occur when the publisher changes its state or executes some behaviors. Publishers contain a subscription infrastructure that lets new subscribers join and current subscribers leave the list.


When a new event happens, the publisher goes over the subscription list and calls the notification method declared in the subscriber interface on each subscriber object.


The Subscriber interface declares the notification interface. In most cases, it consists of a single update method. The method may have several parameters that let the publisher pass some event details along with the update.


Concrete Subscribers perform some actions in response to notifications issued by the publisher. All of these classes must implement the same interface so the publisher isn’t coupled to concrete classes.


Usually, subscribers need some contextual information to handle the update correctly. For this reason, publishers often pass some context data as arguments of the notification method. The publisher can pass itself as an argument, letting subscriber fetch any required data directly.


The Client creates publisher and subscriber objects separately and then registers subscribers for publisher updates.




 Use the Observer pattern when changes to the state of one object may require changing other objects, and the actual set of objects is unknown beforehand or changes dynamically.

 You can often experience this problem when working with classes of the graphical user interface. For example, you created custom button classes, and you want to let the clients hook some custom code to your buttons so that it fires whenever a user presses a button.
The Observer pattern lets any object that implements the subscriber interface subscribe for event notifications in publisher objects. You can add the subscription mechanism to your buttons, letting the clients hook up their custom code via custom subscriber classes.


 Use the pattern when some objects in your app must observe others, but only for a limited time or in specific cases.

 The subscription list is dynamic, so subscribers can join or leave the list whenever they need to.



Look over your business logic and try to break it down into two parts: the core functionality, independent from other code, will act as the publisher; the rest will turn into a set of subscriber classes.


Declare the subscriber interface. At a bare minimum, it should declare a single update method.


Declare the publisher interface and describe a pair of methods for adding a subscriber object to and removing it from the list. Remember that publishers must work with subscribers only via the subscriber interface.


Decide where to put the actual subscription list and the implementation of subscription methods. Usually, this code looks the same for all types of publishers, so the obvious place to put it is in an abstract class derived directly from the publisher interface. Concrete publishers extend that class, inheriting the subscription behavior.
However, if you’re applying the pattern to an existing class hierarchy, consider an approach based on composition: put the subscription logic into a separate object, and make all real publishers use it.


Create concrete publisher classes. Each time something important happens inside a publisher, it must notify all its subscribers.


Implement the update notification methods in concrete subscriber classes. Most subscribers would need some context data about the event. It can be passed as an argument of the notification method.
But there’s another option. Upon receiving a notification, the subscriber can fetch any data directly from the notification. In this case, the publisher must pass itself via the update method. The less flexible option is to link a publisher to the subscriber permanently via the constructor.


The client must create all necessary subscribers and register them with proper publishers.




 Open/Closed Principle. You can introduce new subscriber classes without having to change the publisher’s code (and vice versa if there’s a publisher interface).

 You can establish relations between objects at runtime.




 Subscribers are notified in random order.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let’s see how we can do that.
The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.
There’s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator’s events. When Mediator is implemented this way, it may look very similar to Observer.
When you’re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won’t resemble Observer but will still be an instance of the Mediator pattern.
Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won’t be a centralized mediator object, only a distributed set of observers.

"
162,0,state,"
In Draft, it moves the document to moderation.
In Moderation, it makes the document public, but only if the current user is an administrator.
In Published, it doesn’t do anything at all.

When the phone is unlocked, pressing buttons leads to executing various functions.
When the phone is locked, pressing any button leads to the unlock screen.
When the phone’s charge is low, pressing any button shows the charging screen.





Context stores a reference to one of the concrete state objects and delegates to it all state-specific work. The context communicates with the state object via the state interface. The context exposes a setter for passing it a new state object.


The State interface declares the state-specific methods. These methods should make sense for all concrete states because you don’t want some of your states to have useless methods that will never be called.


Concrete States provide their own implementations for the state-specific methods. To avoid duplication of similar code across multiple states, you may provide intermediate abstract classes that encapsulate some common behavior.
State objects may store a backreference to the context object. Through this reference, the state can fetch any required info from the context object, as well as initiate state transitions.


Both context and concrete states can set the next state of the context and perform the actual state transition by replacing the state object linked to the context.




 Use the State pattern when you have an object that behaves differently depending on its current state, the number of states is enormous, and the state-specific code changes frequently.

 The pattern suggests that you extract all state-specific code into a set of distinct classes. As a result, you can add new states or change existing ones independently of each other, reducing the maintenance cost.


 Use the pattern when you have a class polluted with massive conditionals that alter how the class behaves according to the current values of the class’s fields.

 The State pattern lets you extract branches of these conditionals into methods of corresponding state classes. While doing so, you can also clean temporary fields and helper methods involved in state-specific code out of your main class.


 Use State when you have a lot of duplicate code across similar states and transitions of a condition-based state machine.

 The State pattern lets you compose hierarchies of state classes and reduce duplication by extracting common code into abstract base classes.



Decide what class will act as the context. It could be an existing class which already has the state-dependent code; or a new class, if the state-specific code is distributed across multiple classes.


Declare the state interface. Although it may mirror all the methods declared in the context, aim only for those that may contain state-specific behavior.


For every actual state, create a class that derives from the state interface. Then go over the methods of the context and extract all code related to that state into your newly created class.
While moving the code to the state class, you might discover that it depends on private members of the context. There are several workarounds:

Make these fields or methods public.
Turn the behavior you’re extracting into a public method in the context and call it from the state class. This way is ugly but quick, and you can always fix it later.
Nest the state classes into the context class, but only if your programming language supports nesting classes.



In the context class, add a reference field of the state interface type and a public setter that allows overriding the value of that field.


Go over the method of the context again and replace empty state conditionals with calls to corresponding methods of the state object.


To switch the state of the context, create an instance of one of the state classes and pass it to the context. You can do this within the context itself, or in various states, or in the client. Wherever this is done, the class becomes dependent on the concrete state class that it instantiates.




 Single Responsibility Principle. Organize the code related to particular states into separate classes.

 Open/Closed Principle. Introduce new states without changing existing state classes or the context.

 Simplify the code of the context by eliminating bulky state machine conditionals.




 Applying the pattern can be overkill if a state machine has only a few states or rarely changes.



Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn’t restrict dependencies between concrete states, letting them alter the state of the context at will.

"
163,0,strategy,"




The Context maintains a reference to one of the concrete strategies and communicates with this object only via the strategy interface.


The Strategy interface is common to all concrete strategies. It declares a method the context uses to execute a strategy.


Concrete Strategies implement different variations of an algorithm the context uses.


The context calls the execution method on the linked strategy object each time it needs to run the algorithm. The context doesn’t know what type of strategy it works with or how the algorithm is executed.


The Client creates a specific strategy object and passes it to the context. The context exposes a setter which lets clients replace the strategy associated with the context at runtime.




 Use the Strategy pattern when you want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime.

 The Strategy pattern lets you indirectly alter the object’s behavior at runtime by associating it with different sub-objects which can perform specific sub-tasks in different ways.


 Use the Strategy when you have a lot of similar classes that only differ in the way they execute some behavior.

 The Strategy pattern lets you extract the varying behavior into a separate class hierarchy and combine the original classes into one, thereby reducing duplicate code.


 Use the pattern to isolate the business logic of a class from the implementation details of algorithms that may not be as important in the context of that logic.

 The Strategy pattern lets you isolate the code, internal data, and dependencies of various algorithms from the rest of the code. Various clients get a simple interface to execute the algorithms and switch them at runtime.


 Use the pattern when your class has a massive conditional statement that switches between different variants of the same algorithm.

 The Strategy pattern lets you do away with such a conditional by extracting all algorithms into separate classes, all of which implement the same interface. The original object delegates execution to one of these objects, instead of implementing all variants of the algorithm.



In the context class, identify an algorithm that’s prone to frequent changes. It may also be a massive conditional that selects and executes a variant of the same algorithm at runtime.


Declare the strategy interface common to all variants of the algorithm.


One by one, extract all algorithms into their own classes. They should all implement the strategy interface.


In the context class, add a field for storing a reference to a strategy object. Provide a setter for replacing values of that field. The context should work with the strategy object only via the strategy interface. The context may define an interface which lets the strategy access its data.


Clients of the context must associate it with a suitable strategy that matches the way they expect the context to perform its primary job.




 You can swap algorithms used inside an object at runtime.

 You can isolate the implementation details of an algorithm from the code that uses it.

 You can replace inheritance with composition.

 Open/Closed Principle. You can introduce new strategies without having to change the context.




 If you only have a couple of algorithms and they rarely change, there’s no real reason to overcomplicate the program with new classes and interfaces that come along with the pattern.

 Clients must be aware of the differences between strategies to be able to select a proper one.

 A lot of modern programming languages have functional type support that lets you implement different versions of an algorithm inside a set of anonymous functions. Then you could use these functions exactly as you’d have used the strategy objects, but without bloating your code with extra classes and interfaces.



Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.


You can use Command to convert any operation into an object. The operation’s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.


On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.




Decorator lets you change the skin of an object, while Strategy lets you change the guts.


Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object’s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it’s static. Strategy works on the object level, letting you switch behaviors at runtime.


State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn’t restrict dependencies between concrete states, letting them alter the state of the context at will.

"
164,0,template_method,"

abstract steps must be implemented by every subclass

optional steps already have some default implementation, but still can be overridden if needed





The Abstract Class declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order. The steps may either be declared abstract or have some default implementation.


Concrete Classes can override all of the steps, but not the template method itself.




 Use the Template Method pattern when you want to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure.

 The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass.


 Use the pattern when you have several classes that contain almost identical algorithms with some minor differences. As a result, you might need to modify all classes when the algorithm changes.

 When you turn such an algorithm into a template method, you can also pull up the steps with similar implementations into a superclass, eliminating code duplication. Code that varies between subclasses can remain in subclasses.



Analyze the target algorithm to see whether you can break it into steps. Consider which steps are common to all subclasses and which ones will always be unique.


Create the abstract base class and declare the template method and a set of abstract methods representing the algorithm’s steps. Outline the algorithm’s structure in the template method by executing corresponding steps. Consider making the template method final to prevent subclasses from overriding it.


It’s okay if all the steps end up being abstract. However, some steps might benefit from having a default implementation. Subclasses don’t have to implement those methods.


Think of adding hooks between the crucial steps of the algorithm.


For each variation of the algorithm, create a new concrete subclass. It must implement all of the abstract steps, but may also override some of the optional ones.




 You can let clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm.

 You can pull the duplicate code into a superclass.




 Some clients may be limited by the provided skeleton of an algorithm.

 You might violate the Liskov Substitution Principle by suppressing a default step implementation via a subclass.

 Template methods tend to be harder to maintain the more steps they have.



Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.


Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object’s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it’s static. Strategy works on the object level, letting you switch behaviors at runtime.

"
165,0,visitor,"
If it’s a residential building, he sells medical insurance.
If it’s a bank, he sells theft insurance.
If it’s a coffee shop, he sells fire and flood insurance.





The Visitor interface declares a set of visiting methods that can take concrete elements of an object structure as arguments. These methods may have the same names if the program is written in a language that supports overloading, but the type of their parameters must be different.


Each Concrete Visitor implements several versions of the same behaviors, tailored for different concrete element classes.


The Element interface declares a method for “accepting” visitors. This method should have one parameter declared with the type of the visitor interface.


Each Concrete Element must implement the acceptance method. The purpose of this method is to redirect the call to the proper visitor’s method corresponding to the current element class. Be aware that even if a base element class implements this method, all subclasses must still override this method in their own classes and call the appropriate method on the visitor object.


The Client usually represents a collection or some other complex object (for example, a Composite tree). Usually, clients aren’t aware of all the concrete element classes because they work with objects from that collection via some abstract interface.




 Use the Visitor when you need to perform an operation on all elements of a complex object structure (for example, an object tree).

 The Visitor pattern lets you execute an operation over a set of objects with different classes by having a visitor object implement several variants of the same operation, which correspond to all target classes.


 Use the Visitor to clean up the business logic of auxiliary behaviors.

 The pattern lets you make the primary classes of your app more focused on their main jobs by extracting all other behaviors into a set of visitor classes.


 Use the pattern when a behavior makes sense only in some classes of a class hierarchy, but not in others.

 You can extract this behavior into a separate visitor class and implement only those visiting methods that accept objects of relevant classes, leaving the rest empty.



Declare the visitor interface with a set of “visiting” methods, one per each concrete element class that exists in the program.


Declare the element interface. If you’re working with an existing element class hierarchy, add the abstract “acceptance” method to the base class of the hierarchy. This method should accept a visitor object as an argument.


Implement the acceptance methods in all concrete element classes. These methods must simply redirect the call to a visiting method on the incoming visitor object which matches the class of the current element.


The element classes should only work with visitors via the visitor interface. Visitors, however, must be aware of all concrete element classes, referenced as parameter types of the visiting methods.


For each behavior that can’t be implemented inside the element hierarchy, create a new concrete visitor class and implement all of the visiting methods.
You might encounter a situation where the visitor will need access to some private members of the element class. In this case, you can either make these fields or methods public, violating the element’s encapsulation, or nest the visitor class in the element class. The latter is only possible if you’re lucky to work with a programming language that supports nested classes.


The client must create visitor objects and pass them into elements via “acceptance” methods.




 Open/Closed Principle. You can introduce a new behavior that can work with objects of different classes without changing these classes.

 Single Responsibility Principle. You can move multiple versions of the same behavior into the same class.

 A visitor object can accumulate some useful information while working with various objects. This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure.




 You need to update all visitors each time a class gets added to or removed from the element hierarchy.

 Visitors might lack the necessary access to the private fields and methods of the elements that they’re supposed to work with.



You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.


You can use Visitor to execute an operation over an entire Composite tree.


You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.


Puzzled why we can’t simply replace the Visitor pattern with method overloading? Read my article Visitor and Double Dispatch to learn about the nasty details.
"
166,0,factory_method,"




The Product declares the interface, which is common to all objects that can be produced by the creator and its subclasses.


Concrete Products are different implementations of the product interface.


The Creator class declares the factory method that returns new product objects. It’s important that the return type of this method matches the product interface.
You can declare the factory method as abstract to force all subclasses to implement their own versions of the method. As an alternative, the base factory method can return some default product type.
Note, despite its name, product creation is not the primary responsibility of the creator. Usually, the creator class already has some core business logic related to products. The factory method helps to decouple this logic from the concrete product classes. Here is an analogy: a large software development company can have a training department for programmers. However, the primary function of the company as a whole is still writing code, not producing programmers.


Concrete Creators override the base factory method so it returns a different type of product.
Note that the factory method doesn’t have to create new instances all the time. It can also return existing objects from a cache, an object pool, or another source.




 Use the Factory Method when you don’t know beforehand the exact types and dependencies of the objects your code should work with.

 The Factory Method separates product construction code from the code that actually uses the product. Therefore it’s easier to extend the product construction code independently from the rest of the code.
For example, to add a new product type to the app, you’ll only need to create a new creator subclass and override the factory method in it.


 Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.

 Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component?
The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself.
Let’s see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard Button class with a glorious RoundButton subclass. But now you need to tell the main UIFramework class to use the new button subclass instead of a default one.
To achieve this, you create a subclass UIWithRoundButtons from a base framework class and override its createButton method. While this method returns Button objects in the base class, you make your subclass return RoundButton objects. Now use the UIWithRoundButtons class instead of UIFramework. And that’s about it!


 Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time.

 You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources.
Let’s think about what has to be done to reuse an existing object:

First, you need to create some storage to keep track of all of the created objects.
When someone requests an object, the program should look for a free object inside that pool.
… and then return it to the client code.
If there are no free objects, the program should create a new one (and add it to the pool).

That’s a lot of code! And it must all be put into a single place so that you don’t pollute the program with duplicate code.
Probably the most obvious and convenient place where this code could be placed is the constructor of the class whose objects we’re trying to reuse. However, a constructor must always return new objects by definition. It can’t return existing instances.
Therefore, you need to have a regular method capable of creating new objects as well as reusing existing ones. That sounds very much like a factory method.



Make all products follow the same interface. This interface should declare methods that make sense in every product.


Add an empty factory method inside the creator class. The return type of the method should match the common product interface.


In the creator’s code find all references to product constructors. One by one, replace them with calls to the factory method, while extracting the product creation code into the factory method.
You might need to add a temporary parameter to the factory method to control the type of returned product.
At this point, the code of the factory method may look pretty ugly. It may have a large switch statement that picks which product class to instantiate. But don’t worry, we’ll fix it soon enough.


Now, create a set of creator subclasses for each type of product listed in the factory method. Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.


If there are too many product types and it doesn’t make sense to create subclasses for all of them, you can reuse the control parameter from the base class in subclasses.
For instance, imagine that you have the following hierarchy of classes: the base Mail class with a couple of subclasses: AirMail and GroundMail; the Transport classes are Plane, Truck and Train. While the AirMail class only uses Plane objects, GroundMail may work with both Truck and Train objects. You can create a new subclass (say TrainMail) to handle both cases, but there’s another option. The client code can pass an argument to the factory method of the GroundMail class to control which product it wants to receive.


If, after all of the extractions, the base factory method has become empty, you can make it abstract. If there’s something left, you can make it a default behavior of the method.




 You avoid tight coupling between the creator and the concrete products.

 Single Responsibility Principle. You can move the product creation code into one place in the program, making the code easier to support.

 Open/Closed Principle. You can introduce new types of products into the program without breaking existing client code.




 The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern. The best case scenario is when you’re introducing the pattern into an existing hierarchy of creator classes.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.


Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.


Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.


Read our Factory Comparison if you can’t figure out the difference between various factory patterns and concepts.
"
167,0,builder,"Director




The Builder interface declares product construction steps that are common to all types of builders.


Concrete Builders provide different implementations of the construction steps. Concrete builders may produce products that don’t follow the common interface.


Products are resulting objects. Products constructed by different builders don’t have to belong to the same class hierarchy or interface.


The Director class defines the order in which to call construction steps, so you can create and reuse specific configurations of products.


The Client must associate one of the builder objects with the director. Usually, it’s done just once, via parameters of the director’s constructor. Then the director uses that builder object for all further construction. However, there’s an alternative approach for when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.




 Use the Builder pattern to get rid of a “telescoping constructor”.

 Say you have a constructor with ten optional parameters. Calling such a beast is very inconvenient; therefore, you overload the constructor and create several shorter versions with fewer parameters. These constructors still refer to the main one, passing some default values into any omitted parameters.

class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...


Creating such a monster is only possible in languages that support method overloading, such as C# or Java.


The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don’t have to cram dozens of parameters into your constructors anymore.


 Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).

 The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details.
The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction.


 Use the Builder to construct Composite trees or other complex objects.

 The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree.
A builder doesn’t expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result.



Make sure that you can clearly define the common construction steps for building all available product representations. Otherwise, you won’t be able to proceed with implementing the pattern.


Declare these steps in the base builder interface.


Create a concrete builder class for each of the product representations and implement their construction steps.
Don’t forget about implementing a method for fetching the result of the construction. The reason why this method can’t be declared inside the builder interface is that various builders may construct products that don’t have a common interface. Therefore, you don’t know what would be the return type for such a method. However, if you’re dealing with products from a single hierarchy, the fetching method can be safely added to the base interface.


Think about creating a director class. It may encapsulate various ways to construct a product using the same builder object.


The client code creates both the builder and the director objects. Before construction starts, the client must pass a builder object to the director. Usually, the client does this only once, via parameters of the director’s class constructor. The director uses the builder object in all further construction. There’s an alternative approach, where the builder is passed to a specific product construction method of the director.


The construction result can be obtained directly from the director only if all products follow the same interface. Otherwise, the client should fetch the result from the builder.




 You can construct objects step-by-step, defer construction steps or run steps recursively.

 You can reuse the same construction code when building various representations of products.

 Single Responsibility Principle. You can isolate complex construction code from the business logic of the product.




 The overall complexity of the code increases since the pattern requires creating multiple new classes.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.


You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.


You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
168,0,adapter,"
The adapter gets an interface, compatible with one of the existing objects.
Using this interface, the existing object can safely call the adapter’s methods.
Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects.

Object adapter
This implementation uses the object composition principle: the adapter implements the interface of one object and wraps the other one. It can be implemented in all popular programming languages.






The Client is a class that contains the existing business logic of the program.


The Client Interface describes a protocol that other classes must follow to be able to collaborate with the client code.


The Service is some useful class (usually 3rd-party or legacy). The client can’t use this class directly because it has an incompatible interface.


The Adapter is a class that’s able to work with both the client and the service: it implements the client interface, while wrapping the service object. The adapter receives calls from the client via the adapter interface and translates them into calls to the wrapped service object in a format it can understand.


The client code doesn’t get coupled to the concrete adapter class as long as it works with the adapter via the client interface. Thanks to this, you can introduce new types of adapters into the program without breaking the existing client code. This can be useful when the interface of the service class gets changed or replaced: you can just create a new adapter class without changing the client code.

Class adapter
This implementation uses inheritance: the adapter inherits interfaces from both objects at the same time. Note that this approach can only be implemented in programming languages that support multiple inheritance, such as C++.






The Class Adapter doesn’t need to wrap any objects because it inherits behaviors from both the client and the service. The adaptation happens within the overridden methods. The resulting adapter can be used in place of an existing client class.




 Use the Adapter class when you want to use some existing class, but its interface isn’t compatible with the rest of your code.

 The Adapter pattern lets you create a middle-layer class that serves as a translator between your code and a legacy class, a 3rd-party class or any other class with a weird interface.


 Use the pattern when you want to reuse several existing subclasses that lack some common functionality that can’t be added to the superclass.

 You could extend each subclass and put the missing functionality into new child classes. However, you’ll need to duplicate the code across all of these new classes, which smells really bad.
The much more elegant solution would be to put the missing functionality into an adapter class. Then you would wrap objects with missing features inside the adapter, gaining needed features dynamically. For this to work, the target classes must have a common interface, and the adapter’s field should follow that interface. This approach looks very similar to the Decorator pattern.



Make sure that you have at least two classes with incompatible interfaces:

A useful service class, which you can’t change (often 3rd-party, legacy or with lots of existing dependencies).
One or several client classes that would benefit from using the service class.



Declare the client interface and describe how clients communicate with the service.


Create the adapter class and make it follow the client interface. Leave all the methods empty for now.


Add a field to the adapter class to store a reference to the service object. The common practice is to initialize this field via the constructor, but sometimes it’s more convenient to pass it to the adapter when calling its methods.


One by one, implement all methods of the client interface in the adapter class. The adapter should delegate most of the real work to the service object, handling only the interface or data format conversion.


Clients should use the adapter via the client interface. This will let you change or extend the adapters without affecting the client code.




 Single Responsibility Principle. You can separate the interface or data conversion code from the primary business logic of the program.

 Open/Closed Principle. You can introduce new types of adapters into the program without breaking the existing client code, as long as they work with the adapters through the client interface.




 The overall complexity of the code increases because you need to introduce a set of new interfaces and classes. Sometimes it’s simpler just to change the service class so that it matches the rest of your code.



Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.


Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.


Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.


Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.

"
169,0,bridge,"Abstraction and Implementation
Have several different GUIs (for instance, tailored for regular customers or admins).
Support several different APIs (for example, to be able to launch the app under Windows, Linux, and macOS).

Abstraction: the GUI layer of the app.
Implementation: the operating systems’ APIs.





The Abstraction provides high-level control logic. It relies on the implementation object to do the actual low-level work.


The Implementation declares the interface that’s common for all concrete implementations. An abstraction can only communicate with an implementation object via methods that are declared here.
The abstraction may list the same methods as the implementation, but usually the abstraction declares some complex behaviors that rely on a wide variety of primitive operations declared by the implementation.


Concrete Implementations contain platform-specific code.


Refined Abstractions provide variants of control logic. Like their parent, they work with different implementations via the general implementation interface.


Usually, the Client is only interested in working with the abstraction. However, it’s the client’s job to link the abstraction object with one of the implementation objects.




 Use the Bridge pattern when you want to divide and organize a monolithic class that has several variants of some functionality (for example, if the class can work with various database servers).

 The bigger a class becomes, the harder it is to figure out how it works, and the longer it takes to make a change. The changes made to one of the variations of functionality may require making changes across the whole class, which often results in making errors or not addressing some critical side effects.
The Bridge pattern lets you split the monolithic class into several class hierarchies. After this, you can change the classes in each hierarchy independently of the classes in the others. This approach simplifies code maintenance and minimizes the risk of breaking existing code.


 Use the pattern when you need to extend a class in several orthogonal (independent) dimensions.

 The Bridge suggests that you extract a separate class hierarchy for each of the dimensions. The original class delegates the related work to the objects belonging to those hierarchies instead of doing everything on its own.


 Use the Bridge if you need to be able to switch implementations at runtime.

 Although it’s optional, the Bridge pattern lets you replace the implementation object inside the abstraction. It’s as easy as assigning a new value to a field.
By the way, this last item is the main reason why so many people confuse the Bridge with the Strategy pattern. Remember that a pattern is more than just a certain way to structure your classes. It may also communicate intent and a problem being addressed.



Identify the orthogonal dimensions in your classes. These independent concepts could be: abstraction/platform, domain/infrastructure, front-end/back-end, or interface/implementation.


See what operations the client needs and define them in the base abstraction class.


Determine the operations available on all platforms. Declare the ones that the abstraction needs in the general implementation interface.


For all platforms in your domain create concrete implementation classes, but make sure they all follow the implementation interface.


Inside the abstraction class, add a reference field for the implementation type. The abstraction delegates most of the work to the implementation object that’s referenced in that field.


If you have several variants of high-level logic, create refined abstractions for each variant by extending the base abstraction class.


The client code should pass an implementation object to the abstraction’s constructor to associate one with the other. After that, the client can forget about the implementation and work only with the abstraction object.




 You can create platform-independent classes and apps.

 The client code works with high-level abstractions. It isn’t exposed to the platform details.

 Open/Closed Principle. You can introduce new abstractions and implementations independently from each other.

 Single Responsibility Principle. You can focus on high-level logic in the abstraction and on platform details in the implementation.




 You might make the code more complicated by applying the pattern to a highly cohesive class.



Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.


Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.


You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.

"
170,0,singleton,"

Ensure that a class has just a single instance. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource—for example, a database or a file.
Here’s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you’ll get the one you already created.
Note that this behavior is impossible to implement with a regular constructor since a constructor call must always return a new object by design.


Make the default constructor private, to prevent other objects from using the new operator with the Singleton class.
Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.





The Singleton class declares the static method getInstance that returns the same instance of its own class.
The Singleton’s constructor should be hidden from the client code. Calling the getInstance method should be the only way of getting the Singleton object.




 Use the Singleton pattern when a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program.

 The Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created.


 Use the Singleton pattern when you need stricter control over global variables.

 Unlike global variables, the Singleton pattern guarantees that there’s just one instance of a class. Nothing, except for the Singleton class itself, can replace the cached instance.
Note that you can always adjust this limitation and allow creating any number of Singleton instances. The only piece of code that needs changing is the body of the getInstance method.



Add a private static field to the class for storing the singleton instance.


Declare a public static creation method for getting the singleton instance.


Implement “lazy initialization” inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.


Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.


Go over the client code and replace all direct calls to the singleton’s constructor with calls to its static creation method.




 You can be sure that a class has only a single instance.

 You gain a global access point to that instance.

 The singleton object is initialized only when it’s requested for the first time.




 Violates the Single Responsibility Principle. The pattern solves two problems at the time.

 The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other.

 The pattern requires special treatment in a multithreaded environment so that multiple threads won’t create a singleton object several times.

 It may be difficult to unit test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don’t write the tests. Or don’t use the Singleton pattern.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.



Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
171,0,abstract_factory,"

A family of related products, say: Chair + Sofa + CoffeeTable.


Several variants of this family. For example, products Chair + Sofa + CoffeeTable are available in these variants: Modern, Victorian, ArtDeco.






Abstract Products declare interfaces for a set of distinct but related products which make up a product family.


Concrete Products are various implementations of abstract products, grouped by variants. Each abstract product (chair/sofa) must be implemented in all given variants (Victorian/Modern).


The Abstract Factory interface declares a set of methods for creating each of the abstract products.


Concrete Factories implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.


Although concrete factories instantiate concrete products, signatures of their creation methods must return corresponding abstract products. This way the client code that uses a factory doesn’t get coupled to the specific variant of the product it gets from a factory. The Client can work with any concrete factory/product variant, as long as it communicates with their objects via abstract interfaces.




 Use the Abstract Factory when your code needs to work with various families of related products, but you don’t want it to depend on the concrete classes of those products—they might be unknown beforehand or you simply want to allow for future extensibility.

 The Abstract Factory provides you with an interface for creating objects from each class of the product family. As long as your code creates objects via this interface, you don’t have to worry about creating the wrong variant of a product which doesn’t match the products already created by your app.


 Consider implementing the Abstract Factory when you have a class with a set of Factory Methods that blur its primary responsibility.

 In a well-designed program each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.



Map out a matrix of distinct product types versus variants of these products.


Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.


Declare the abstract factory interface with a set of creation methods for all abstract products.


Implement a set of concrete factory classes, one for each product variant.


Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.


Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.




 You can be sure that the products you’re getting from a factory are compatible with each other.

 You avoid tight coupling between concrete products and client code.

 Single Responsibility Principle. You can extract the product creation code into one place, making the code easier to support.

 Open/Closed Principle. You can introduce new variants of products without breaking existing client code.




 The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.


Read our Factory Comparison to learn more about the differences between various factory patterns and concepts.
"
172,0,decorator,"
Inheritance is static. You can’t alter the behavior of an existing object at runtime. You can only replace the whole object with another one that’s created from a different subclass.
Subclasses can have just one parent class. In most languages, inheritance doesn’t let a class inherit behaviors of multiple classes at the same time.





The Component declares the common interface for both wrappers and wrapped objects.


Concrete Component is a class of objects being wrapped. It defines the basic behavior, which can be altered by decorators.


The Base Decorator class has a field for referencing a wrapped object. The field’s type should be declared as the component interface so it can contain both concrete components and decorators. The base decorator delegates all operations to the wrapped object.


Concrete Decorators define extra behaviors that can be added to components dynamically. Concrete decorators override methods of the base decorator and execute their behavior either before or after calling the parent method.


The Client can wrap components in multiple layers of decorators, as long as it works with all objects via the component interface.




Just before the data is written to disk, the decorators encrypt and compress it. The original class writes the encrypted and protected data to the file without knowing about the change.


Right after the data is read from disk, it goes through the same decorators, which decompress and decode it.



 Use the Decorator pattern when you need to be able to assign extra behaviors to objects at runtime without breaking the code that uses these objects.

 The Decorator lets you structure your business logic into layers, create a decorator for each layer and compose objects with various combinations of this logic at runtime. The client code can treat all these objects in the same way, since they all follow a common interface.


 Use the pattern when it’s awkward or not possible to extend an object’s behavior using inheritance.

 Many programming languages have the final keyword that can be used to prevent further extension of a class. For a final class, the only way to reuse the existing behavior would be to wrap the class with your own wrapper, using the Decorator pattern.



Make sure your business domain can be represented as a primary component with multiple optional layers over it.


Figure out what methods are common to both the primary component and the optional layers. Create a component interface and declare those methods there.


Create a concrete component class and define the base behavior in it.


Create a base decorator class. It should have a field for storing a reference to a wrapped object. The field should be declared with the component interface type to allow linking to concrete components as well as decorators. The base decorator must delegate all work to the wrapped object.


Make sure all classes implement the component interface.


Create concrete decorators by extending them from the base decorator. A concrete decorator must execute its behavior before or after the call to the parent method (which always delegates to the wrapped object).


The client code must be responsible for creating decorators and composing them in the way the client needs.




 You can extend an object’s behavior without making a new subclass.

 You can add or remove responsibilities from an object at runtime.

 You can combine several behaviors by wrapping an object into multiple decorators.

 Single Responsibility Principle. You can divide a monolithic class that implements many possible variants of behavior into several smaller classes.




 It’s hard to remove a specific wrapper from the wrappers stack.

 It’s hard to implement a decorator in such a way that its behavior doesn’t depend on the order in the decorators stack.

 The initial configuration code of layers might look pretty ugly.



Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.


Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.
The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.


Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.
A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.
However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.


Decorator lets you change the skin of an object, while Strategy lets you change the guts.


Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.

"
173,0,facade,"




The Facade provides convenient access to a particular part of the subsystem’s functionality. It knows where to direct the client’s request and how to operate all the moving parts.


An Additional Facade class can be created to prevent polluting a single facade with unrelated features that might make it yet another complex structure. Additional facades can be used by both clients and other facades.


The Complex Subsystem consists of dozens of various objects. To make them all do something meaningful, you have to dive deep into the subsystem’s implementation details, such as initializing objects in the correct order and supplying them with data in the proper format.
Subsystem classes aren’t aware of the facade’s existence. They operate within the system and work with each other directly.


The Client uses the facade instead of calling the subsystem objects directly.




 Use the Facade pattern when you need to have a limited but straightforward interface to a complex subsystem.

 Often, subsystems get more complex over time. Even applying design patterns typically leads to creating more classes. A subsystem may become more flexible and easier to reuse in various contexts, but the amount of configuration and boilerplate code it demands from a client grows ever larger. The Facade attempts to fix this problem by providing a shortcut to the most-used features of the subsystem which fit most client requirements.


 Use the Facade when you want to structure a subsystem into layers.

 Create facades to define entry points to each level of a subsystem. You can reduce coupling between multiple subsystems by requiring them to communicate only through facades.
For example, let’s return to our video conversion framework. It can be broken down into two layers: video- and audio-related. For each layer, you can create a facade and then make the classes of each layer communicate with each other via those facades. This approach looks very similar to the Mediator pattern.



Check whether it’s possible to provide a simpler interface than what an existing subsystem already provides. You’re on the right track if this interface makes the client code independent from many of the subsystem’s classes.


Declare and implement this interface in a new facade class. The facade should redirect the calls from the client code to appropriate objects of the subsystem. The facade should be responsible for initializing the subsystem and managing its further life cycle unless the client code already does this.


To get the full benefit from the pattern, make all the client code communicate with the subsystem only via the facade. Now the client code is protected from any changes in the subsystem code. For example, when a subsystem gets upgraded to a new version, you will only need to modify the code in the facade.


If the facade becomes too big, consider extracting part of its behavior to a new, refined facade class.




 You can isolate your code from the complexity of a subsystem.




 A facade can become a god object coupled to all classes of an app.



Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.


Facade defines a simplified interface to a subsystem of objects, but it doesn’t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

Mediator centralizes communication between components of the system. The components only know about the mediator object and don’t communicate directly.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.

"
174,0,chain_of_responsibility,"

One of your colleagues suggested that it’s unsafe to pass raw data straight to the ordering system. So you added an extra validation step to sanitize the data in a request.


Later, somebody noticed that the system is vulnerable to brute force password cracking. To negate this, you promptly added a check that filters repeated failed requests coming from the same IP address.


Someone else suggested that you could speed up the system by returning cached results on repeated requests containing the same data. Hence, you added another check which lets the request pass through to the system only if there’s no suitable cached response.






The Handler declares the interface, common for all concrete handlers. It usually  contains just a single method for handling requests, but sometimes it may also have another method for setting the next handler on the chain.


The Base Handler is an optional class where you can put the boilerplate code that’s common to all handler classes.
Usually, this class defines a field for storing a reference to the next handler. The clients can build a chain by passing a handler to the constructor or setter of the previous handler. The class may also implement the default handling behavior: it can pass execution to the next handler after checking for its existence.


Concrete Handlers contain the actual code for processing requests. Upon receiving a request, each handler must decide whether to process it and, additionally, whether to pass it along the chain.
Handlers are usually self-contained and immutable, accepting all necessary data just once via the constructor.


The Client may compose chains just once or compose them dynamically, depending on the application’s logic. Note that a request can be sent to any handler in the chain—it doesn’t have to be the first one.




 Use the Chain of Responsibility pattern when your program is expected to process different kinds of requests in various ways, but the exact types of requests and their sequences are unknown beforehand.

 The pattern lets you link several handlers into one chain and, upon receiving a request, “ask” each handler whether it can process it. This way all handlers get a chance to process the request.


 Use the pattern when it’s essential to execute several handlers in a particular order.

 Since you can link the handlers in the chain in any order, all requests will get through the chain exactly as you planned.


 Use the CoR pattern when the set of handlers and their order are supposed to change at runtime.

 If you provide setters for a reference field inside the handler classes, you’ll be able to insert, remove or reorder handlers dynamically.



Declare the handler interface and describe the signature of a method for handling requests.
Decide how the client will pass the request data into the method. The most flexible way is to convert the request into an object and pass it to the handling method as an argument.


To eliminate duplicate boilerplate code in concrete handlers, it might be worth creating an abstract base handler class, derived from the handler interface.
This class should have a field for storing a reference to the next handler in the chain. Consider making the class immutable. However, if you plan to modify chains at runtime, you need to define a setter for altering the value of the reference field.
You can also implement the convenient default behavior for the handling method, which is to forward the request to the next object unless there’s none left. Concrete handlers will be able to use this behavior by calling the parent method.


One by one create concrete handler subclasses and implement their handling methods. Each handler should make two decisions when receiving a request:

Whether it’ll process the request.
Whether it’ll pass the request along the chain.



The client may either assemble chains on its own or receive pre-built chains from other objects. In the latter case, you must implement some factory classes to build chains according to the configuration or environment settings.


The client may trigger any handler in the chain, not just the first one. The request will be passed along the chain until some handler refuses to pass it further or until it reaches the end of the chain.


Due to the dynamic nature of the chain, the client should be ready to handle the following scenarios:

The chain may consist of a single link.
Some requests may not reach the end of the chain.
Others may reach the end of the chain unhandled.





 You can control the order of request handling.

 Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform operations.

 Open/Closed Principle. You can introduce new handlers into the app without breaking the existing client code.




 Some requests may end up unhandled.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.


Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.
However, there’s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.


Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.
The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.

"
175,0,mediator,"




Components are various classes that contain some business logic. Each component has a reference to a mediator, declared with the type of the mediator interface. The component isn’t aware of the actual class of the mediator, so you can reuse the component in other programs by linking it to a different mediator.


The Mediator interface declares methods of communication with components, which usually include just a single notification method. Components may pass any context as arguments of this method, including their own objects, but only in such a way that no coupling occurs between a receiving component and the sender’s class.


Concrete Mediators encapsulate relations between various components. Concrete mediators often keep references to all components they manage and sometimes even manage their lifecycle.


Components must not be aware of other components. If something important happens within or to a component, it must only notify the mediator. When the mediator receives the notification, it can easily identify the sender, which might be just enough to decide what component should be triggered in return.
From a component’s perspective, it all looks like a total black box. The sender doesn’t know who’ll end up handling its request, and the receiver doesn’t know who sent the request in the first place.




 Use the Mediator pattern when it’s hard to change some of the classes because they are tightly coupled to a bunch of other classes.

 The pattern lets you extract all the relationships between classes into a separate class, isolating any changes to a specific component from the rest of the components.


 Use the pattern when you can’t reuse a component in a different program because it’s too dependent on other components.

 After you apply the Mediator, individual components become unaware of the other components. They could still communicate with each other, albeit indirectly, through a mediator object. To reuse a component in a different app, you need to provide it with a new mediator class.


 Use the Mediator when you find yourself creating tons of component subclasses just to reuse some basic behavior in various contexts.

 Since all relations between components are contained within the mediator, it’s easy to define entirely new ways for these components to collaborate by introducing new mediator classes, without having to change the components themselves.



Identify a group of tightly coupled classes which would benefit from being more independent (e.g., for easier maintenance or simpler reuse of these classes).


Declare the mediator interface and describe the desired communication protocol between mediators and various components. In most cases, a single method for receiving notifications from components is sufficient.
This interface is crucial when you want to reuse component classes in different contexts. As long as the component works with its mediator via the generic interface, you can link the component with a different implementation of the mediator.


Implement the concrete mediator class. Consider storing references to all components inside the mediator. This way, you could call any component from the mediator’s methods.


You can go even further and make the mediator responsible for the creation and destruction of component objects. After this, the mediator may resemble a factory or a facade.


Components should store a reference to the mediator object. The connection is usually established in the component’s constructor, where a mediator object is passed as an argument.


Change the components’ code so that they call the mediator’s notification method instead of methods on other components. Extract the code that involves calling other components into the mediator class. Execute this code whenever the mediator receives notifications from that component.




 Single Responsibility Principle. You can extract the communications between various components into a single place, making it easier to comprehend and maintain.

 Open/Closed Principle. You can introduce new mediators without having to change the actual components.

 You can reduce coupling between various components of a program.

 You can reuse individual components more easily.




 Over time a mediator can evolve into a God Object.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.


Facade defines a simplified interface to a subsystem of objects, but it doesn’t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

Mediator centralizes communication between components of the system. The components only know about the mediator object and don’t communicate directly.



The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let’s see how we can do that.
The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.
There’s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator’s events. When Mediator is implemented this way, it may look very similar to Observer.
When you’re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won’t resemble Observer but will still be an instance of the Mediator pattern.
Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won’t be a centralized mediator object, only a distributed set of observers.

"
176,0,memento,"
Implementation based on nested classes
The classic implementation of the pattern relies on support for nested classes, available in many popular programming languages (such as C++, C#, and Java).






The Originator class can produce snapshots of its own state, as well as restore its state from snapshots when needed.


The Memento is a value object that acts as a snapshot of the originator’s state. It’s a common practice to make the memento immutable and pass it the data only once, via the constructor.


The Caretaker knows not only “when” and “why” to capture the originator’s state, but also when the state should be restored.
A caretaker can keep track of the originator’s history by storing a stack of mementos. When the originator has to travel back in history, the caretaker fetches the topmost memento from the stack and passes it to the originator’s restoration method.


In this implementation, the memento class is nested inside the originator. This lets the originator access the fields and methods of the memento, even though they’re declared private. On the other hand, the caretaker has very limited access to the memento’s fields and methods, which lets it store mementos in a stack but not tamper with their state.

Implementation based on an intermediate interface
There’s an alternative implementation, suitable for programming languages that don’t support nested classes (yeah, PHP, I’m talking about you).






In the absence of nested classes, you can restrict access to the memento’s fields by establishing a convention that caretakers can work with a memento only through an explicitly declared intermediary interface, which would only declare methods related to the memento’s metadata.


On the other hand, originators can work with a memento object directly, accessing fields and methods declared in the memento class. The downside of this approach is that you need to declare all members of the memento public.

Implementation with even stricter encapsulation
There’s another implementation which is useful when you don’t want to leave even the slightest chance of other classes accessing the state of the originator through the memento.






This implementation allows having multiple types of originators and mementos. Each originator works with a corresponding memento class. Neither originators nor mementos expose their state to anyone.


Caretakers are now explicitly restricted from changing the state stored in mementos. Moreover, the caretaker class becomes independent from the originator because the restoration method is now defined in the memento class.


Each memento becomes linked to the originator that produced it. The originator passes itself to the memento’s constructor, along with the values of its state. Thanks to the close relationship between these classes, a memento can restore the state of its originator, given that the latter has defined the appropriate setters.




 Use the Memento pattern when you want to produce snapshots of the object’s state to be able to restore a previous state of the object.

 The Memento pattern lets you make full copies of an object’s state, including private fields, and store them separately from the object. While most people remember this pattern thanks to the “undo” use case, it’s also indispensable when dealing with transactions (i.e., if you need to roll back an operation on error).


 Use the pattern when direct access to the object’s fields/getters/setters violates its encapsulation.

 The Memento makes the object itself responsible for creating a snapshot of its state. No other object can read the snapshot, making the original object’s state data safe and secure.



Determine what class will play the role of the originator. It’s important to know whether the program uses one central object of this type or multiple smaller ones.


Create the memento class. One by one, declare a set of fields that mirror the fields declared inside the originator class.


Make the memento class immutable. A memento should accept the data just once, via the constructor. The class should have no setters.


If your programming language supports nested classes, nest the memento inside the originator. If not, extract a blank interface from the memento class and make all other objects use it to refer to the memento. You may add some metadata operations to the interface, but nothing that exposes the originator’s state.


Add a method for producing mementos to the originator class. The originator should pass its state to the memento via one or multiple arguments of the memento’s constructor.
The return type of the method should be of the interface you extracted in the previous step (assuming that you extracted it at all). Under the hood, the memento-producing method should work directly with the memento class.


Add a method for restoring the originator’s state to its class. It should accept a memento object as an argument. If you extracted an interface in the previous step, make it the type of the parameter. In this case, you need to typecast the incoming object to the memento class, since the originator needs full access to that object.


The caretaker, whether it represents a command object, a history, or something entirely different, should know when to request new mementos from the originator, how to store them and when to restore the originator with a particular memento.


The link between caretakers and originators may be moved into the memento class. In this case, each memento must be connected to the originator that had created it. The restoration method would also move to the memento class. However, this would all make sense only if the memento class is nested into originator or the originator class provides sufficient setters for overriding its state.




 You can produce snapshots of the object’s state without violating its encapsulation.

 You can simplify the originator’s code by letting the caretaker maintain the history of the originator’s state.




 The app might consume lots of RAM if clients create mementos too often.

 Caretakers should track the originator’s lifecycle to be able to destroy obsolete mementos.

 Most dynamic programming languages, such as PHP, Python and JavaScript, can’t guarantee that the state within the memento stays untouched.



You can use Command and Memento together when implementing “undo”. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.


You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.


Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.

"
177,0,command,"




The Sender class (aka invoker) is responsible for initiating requests. This class must have a field for storing a reference to a command object. The sender triggers that command instead of sending the request directly to the receiver. Note that the sender isn’t responsible for creating the command object. Usually, it gets a pre-created command from the client via the constructor.


The Command interface usually declares just a single method for executing the command.


Concrete Commands implement various kinds of requests. A concrete command isn’t supposed to perform the work on its own, but rather to pass the call to one of the business logic objects. However, for the sake of simplifying the code, these classes can be merged.
Parameters required to execute a method on a receiving object can be declared as fields in the concrete command. You can make command objects immutable by only allowing the initialization of these fields via the constructor.


The Receiver class contains some business logic. Almost any object may act as a receiver. Most commands only handle the details of how a request is passed to the receiver, while the receiver itself does the actual work.


The Client creates and configures concrete command objects. The client must pass all of the request parameters, including a receiver instance, into the command’s constructor. After that, the resulting command may be associated with one or multiple senders.




 Use the Command pattern when you want to parametrize objects with operations.

 The Command pattern can turn a specific method call into a stand-alone object. This change opens up a lot of interesting uses: you can pass commands as method arguments, store them inside other objects, switch linked commands at runtime, etc.
Here’s an example: you’re developing a GUI component such as a context menu, and you want your users to be able to configure menu items that trigger operations when an end user clicks an item.


 Use the Command pattern when you want to queue operations, schedule their execution, or execute them remotely.

 As with any other object, a command can be serialized, which means converting it to a string that can be easily written to a file or a database. Later, the string can be restored as the initial command object. Thus, you can delay and schedule command execution. But there’s even more! In the same way, you can queue, log or send commands over the network.


 Use the Command pattern when you want to implement reversible operations.

 Although there are many ways to implement undo/redo, the Command pattern is perhaps the most popular of all.
To be able to revert operations, you need to implement the history of performed operations. The command history is a stack that contains all executed command objects along with related backups of the application’s state.
This method has two drawbacks. First, it isn’t that easy to save an application’s state because some of it can be private. This problem can be mitigated with the Memento pattern.
Second, the state backups may consume quite a lot of RAM. Therefore, sometimes you can resort to an alternative implementation: instead of restoring the past state, the command performs the inverse operation. The reverse operation also has a price: it may turn out to be hard or even impossible to implement.



Declare the command interface with a single execution method.


Start extracting requests into concrete command classes that implement the command interface. Each class must have a set of fields for storing the request arguments along with a reference to the actual receiver object. All these values must be initialized via the command’s constructor.


Identify classes that will act as senders. Add the fields for storing commands into these classes. Senders should communicate with their commands only via the command interface. Senders usually don’t create command objects on their own, but rather get them from the client code.


Change the senders so they execute the command instead of sending a request to the receiver directly.


The client should initialize objects in the following order:

Create receivers.
Create commands, and associate them with receivers if needed.
Create senders, and associate them with specific commands.





 Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform these operations.

 Open/Closed Principle. You can introduce new commands into the app without breaking existing client code.

 You can implement undo/redo.

 You can implement deferred execution of operations.

 You can assemble a set of simple commands into a complex one.




 The code may become more complicated since you’re introducing a whole new layer between senders and receivers.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.
However, there’s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.


You can use Command and Memento together when implementing “undo”. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.


Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.


You can use Command to convert any operation into an object. The operation’s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.


On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.




Prototype can help when you need to save copies of Commands into history.


You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.

"
178,0,flyweight,"Extrinsic state storageFlyweight and immutabilityFlyweight factory




The Flyweight pattern is merely an optimization. Before applying it, make sure your program does have the RAM consumption problem related to having a massive number of similar objects in memory at the same time. Make sure that this problem can’t be solved in any other meaningful way.


The Flyweight class contains the portion of the original object’s state that can be shared between multiple objects. The same flyweight object can be used in many different contexts. The state stored inside a flyweight is called intrinsic. The state passed to the flyweight’s methods is called extrinsic.


The Context class contains the extrinsic state, unique across all original objects. When a context is paired with one of the flyweight objects, it represents the full state of the original object.


Usually, the behavior of the original object remains in the flyweight class. In this case, whoever calls a flyweight’s method must also pass appropriate bits of the extrinsic state into the method’s parameters. On the other hand, the behavior can be moved to the context class, which would use the linked flyweight merely as a data object.


The Client calculates or stores the extrinsic state of flyweights. From the client’s perspective, a flyweight is a template object which can be configured at runtime by passing some contextual data into parameters of its methods.


The Flyweight Factory manages a pool of existing flyweights. With the factory, clients don’t create flyweights directly. Instead, they call the factory, passing it bits of the intrinsic state of the desired flyweight. The factory looks over previously created flyweights and either returns an existing one that matches search criteria or creates a new one if nothing is found.




 Use the Flyweight pattern only when your program must support a huge number of objects which barely fit into available RAM.

 The benefit of applying the pattern depends heavily on how and where it’s used. It’s most useful when:

an application needs to spawn a huge number of similar objects
this drains all available RAM on a target device
the objects contain duplicate states which can be extracted and shared between multiple objects




Divide fields of a class that will become a flyweight into two parts:

the intrinsic state: the fields that contain unchanging data duplicated across many objects
the extrinsic state: the fields that contain contextual data unique to each object



Leave the fields that represent the intrinsic state in the class, but make sure they’re immutable. They should take their initial values only inside the constructor.


Go over methods that use fields of the extrinsic state. For each field used in the method, introduce a new parameter and use it instead of the field.


Optionally, create a factory class to manage the pool of flyweights. It should check for an existing flyweight before creating a new one. Once the factory is in place, clients must only request flyweights through it. They should describe the desired flyweight by passing its intrinsic state to the factory.


The client must store or calculate values of the extrinsic state (context) to be able to call methods of flyweight objects. For the sake of convenience, the extrinsic state along with the flyweight-referencing field may be moved to a separate context class.




 You can save lots of RAM, assuming your program has tons of similar objects.




 You might be trading RAM over CPU cycles when some of the context data needs to be recalculated each time somebody calls a flyweight method.

 The code becomes much more complicated. New team members will always be wondering why the state of an entity was separated in such a way.



You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.


"
179,0,iterator,"




The Iterator interface declares the operations required for traversing a collection: fetching the next element, retrieving the current position, restarting iteration, etc.


Concrete Iterators implement specific algorithms for traversing a collection. The iterator object should track the traversal progress on its own. This allows several iterators to traverse the same collection independently of each other.


The Collection interface declares one or multiple methods for getting iterators compatible with the collection. Note that the return type of the methods must be declared as the iterator interface so that the concrete collections can return various kinds of iterators.


Concrete Collections return new instances of a particular concrete iterator class each time the client requests one. You might be wondering, where’s the rest of the collection’s code? Don’t worry, it should be in the same class. It’s just that these details aren’t crucial to the actual pattern, so we’re omitting them.


The Client works with both collections and iterators via their interfaces. This way the client isn’t coupled to concrete classes, allowing you to use various collections and iterators with the same client code.
Typically, clients don’t create iterators on their own, but instead get them from collections. Yet, in certain cases, the client can create one directly; for example, when the client defines its own special iterator.




 Use the Iterator pattern when your collection has a complex data structure under the hood, but you want to hide its complexity from clients (either for convenience or security reasons).

 The iterator encapsulates the details of working with a complex data structure, providing the client with several simple methods of accessing the collection elements. While this approach is very convenient for the client, it also protects the collection from careless or malicious actions which the client would be able to perform if working with the collection directly.


 Use the pattern to reduce duplication of the traversal code across your app.

 The code of non-trivial iteration algorithms tends to be very bulky. When placed within the business logic of an app, it may blur the responsibility of the original code and make it less maintainable. Moving the traversal code to designated iterators can help you make the code of the application more lean and clean.


 Use the Iterator when you want your code to be able to traverse different data structures or when types of these structures are unknown beforehand.

 The pattern provides a couple of generic interfaces for both collections and iterators. Given that your code now uses these interfaces, it’ll still work if you pass it various kinds of collections and iterators that implement these interfaces.



Declare the iterator interface. At the very least, it must have a method for fetching the next element from a collection. But for the sake of convenience you can add a couple of other methods, such as fetching the previous element, tracking the current position, and checking the end of the iteration.


Declare the collection interface and describe a method for fetching iterators. The return type should be equal to that of the iterator interface. You may declare similar methods if you plan to have several distinct groups of iterators.


Implement concrete iterator classes for the collections that you want to be traversable with iterators. An iterator object must be linked with a single collection instance. Usually, this link is established via the iterator’s constructor.


Implement the collection interface in your collection classes. The main idea is to provide the client with a shortcut for creating iterators, tailored for a particular collection class. The collection object must pass itself to the iterator’s constructor to establish a link between them.


Go over the client code to replace all of the collection traversal code with the use of iterators. The client fetches a new iterator object each time it needs to iterate over the collection elements.




 Single Responsibility Principle. You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes.

 Open/Closed Principle. You can implement new types of collections and iterators and pass them to existing code without breaking anything.

 You can iterate over the same collection in parallel because each iterator object contains its own iteration state.

 For the same reason, you can delay an iteration and continue it when needed.




 Applying the pattern can be an overkill if your app only works with simple collections.

 Using an iterator may be less efficient than going through elements of some specialized collections directly.



You can use Iterators to traverse Composite trees.


You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.


You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.


You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.

"
180,0,proxy,"




The Service Interface declares the interface of the Service. The proxy must follow this interface to be able to disguise itself as a service object.


The Service is a class that provides some useful business logic.


The Proxy class has a reference field that points to a service object. After the proxy finishes its processing (e.g., lazy initialization, logging, access control, caching, etc.), it passes the request to the service object.
Usually, proxies manage the full lifecycle of their service objects.


The Client should work with both services and proxies via the same interface. This way you can pass a proxy into any code that expects a service object.



There are dozens of ways to utilize the Proxy pattern. Let’s go over the most popular uses.

 Lazy initialization (virtual proxy). This is when you have a heavyweight service object that wastes system resources by being always up, even though you only need it from time to time.

 Instead of creating the object when the app launches, you can delay the object’s initialization to a time when it’s really needed.


 Access control (protection proxy). This is when you want only specific clients to be able to use the service object; for instance, when your objects are crucial parts of an operating system and clients are various launched applications (including malicious ones).

 The proxy can pass the request to the service object only if the client’s credentials match some criteria.


 Local execution of a remote service (remote proxy). This is when the service object is located on a remote server.

 In this case, the proxy passes the client request over the network, handling all of the nasty details of working with the network.


 Logging requests (logging proxy). This is when you want to keep a history of requests to the service object.

 The proxy can log each request before passing it to the service.


 Caching request results (caching proxy). This is when you need to cache results of client requests and manage the life cycle of this cache, especially if results are quite large.

 The proxy can implement caching for recurring requests that always yield the same results. The proxy may use the parameters of requests as the cache keys.


 Smart reference. This is when you need to be able to dismiss a heavyweight object once there are no clients that use it.

 The proxy can keep track of clients that obtained a reference to the service object or its results. From time to time, the proxy may go over the clients and check whether they are still active. If the client list gets empty, the proxy might dismiss the service object and free the underlying system resources.
The proxy can also track whether the client had modified the service object. Then the unchanged objects may be reused by other clients.



If there’s no pre-existing service interface, create one to make proxy and service objects interchangeable. Extracting the interface from the service class isn’t always possible, because you’d need to change all of the service’s clients to use that interface. Plan B is to make the proxy a subclass of the service class, and this way it’ll inherit the interface of the service.


Create the proxy class. It should have a field for storing a reference to the service. Usually, proxies create and manage the whole life cycle of their services. On rare occasions, a service is passed to the proxy via a constructor by the client.


Implement the proxy methods according to their purposes. In most cases, after doing some work, the proxy should delegate the work to the service object.


Consider introducing a creation method that decides whether the client gets a proxy or a real service. This can be a simple static method in the proxy class or a full-blown factory method.


Consider implementing lazy initialization for the service object.




 You can control the service object without clients knowing about it.

 You can manage the lifecycle of the service object when clients don’t care about it.

 The proxy works even if the service object isn’t ready or is not available.

 Open/Closed Principle. You can introduce new proxies without changing the service or clients.




 The code may become more complicated since you need to introduce a lot of new classes.

 The response from the service might get delayed.



Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.


Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.

"
181,0,observer,"




The Publisher issues events of interest to other objects. These events occur when the publisher changes its state or executes some behaviors. Publishers contain a subscription infrastructure that lets new subscribers join and current subscribers leave the list.


When a new event happens, the publisher goes over the subscription list and calls the notification method declared in the subscriber interface on each subscriber object.


The Subscriber interface declares the notification interface. In most cases, it consists of a single update method. The method may have several parameters that let the publisher pass some event details along with the update.


Concrete Subscribers perform some actions in response to notifications issued by the publisher. All of these classes must implement the same interface so the publisher isn’t coupled to concrete classes.


Usually, subscribers need some contextual information to handle the update correctly. For this reason, publishers often pass some context data as arguments of the notification method. The publisher can pass itself as an argument, letting subscriber fetch any required data directly.


The Client creates publisher and subscriber objects separately and then registers subscribers for publisher updates.




 Use the Observer pattern when changes to the state of one object may require changing other objects, and the actual set of objects is unknown beforehand or changes dynamically.

 You can often experience this problem when working with classes of the graphical user interface. For example, you created custom button classes, and you want to let the clients hook some custom code to your buttons so that it fires whenever a user presses a button.
The Observer pattern lets any object that implements the subscriber interface subscribe for event notifications in publisher objects. You can add the subscription mechanism to your buttons, letting the clients hook up their custom code via custom subscriber classes.


 Use the pattern when some objects in your app must observe others, but only for a limited time or in specific cases.

 The subscription list is dynamic, so subscribers can join or leave the list whenever they need to.



Look over your business logic and try to break it down into two parts: the core functionality, independent from other code, will act as the publisher; the rest will turn into a set of subscriber classes.


Declare the subscriber interface. At a bare minimum, it should declare a single update method.


Declare the publisher interface and describe a pair of methods for adding a subscriber object to and removing it from the list. Remember that publishers must work with subscribers only via the subscriber interface.


Decide where to put the actual subscription list and the implementation of subscription methods. Usually, this code looks the same for all types of publishers, so the obvious place to put it is in an abstract class derived directly from the publisher interface. Concrete publishers extend that class, inheriting the subscription behavior.
However, if you’re applying the pattern to an existing class hierarchy, consider an approach based on composition: put the subscription logic into a separate object, and make all real publishers use it.


Create concrete publisher classes. Each time something important happens inside a publisher, it must notify all its subscribers.


Implement the update notification methods in concrete subscriber classes. Most subscribers would need some context data about the event. It can be passed as an argument of the notification method.
But there’s another option. Upon receiving a notification, the subscriber can fetch any data directly from the notification. In this case, the publisher must pass itself via the update method. The less flexible option is to link a publisher to the subscriber permanently via the constructor.


The client must create all necessary subscribers and register them with proper publishers.




 Open/Closed Principle. You can introduce new subscriber classes without having to change the publisher’s code (and vice versa if there’s a publisher interface).

 You can establish relations between objects at runtime.




 Subscribers are notified in random order.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let’s see how we can do that.
The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.
There’s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator’s events. When Mediator is implemented this way, it may look very similar to Observer.
When you’re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won’t resemble Observer but will still be an instance of the Mediator pattern.
Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won’t be a centralized mediator object, only a distributed set of observers.

"
182,0,composite,"




The Component interface describes operations that are common to both simple and complex elements of the tree.


The Leaf is a basic element of a tree that doesn’t have sub-elements.
Usually, leaf components end up doing most of the real work, since they don’t have anyone to delegate the work to.


The Container (aka composite) is an element that has sub-elements: leaves or other containers. A container doesn’t know the concrete classes of its children. It works with all sub-elements only via the component interface.
Upon receiving a request, a container delegates the work to its sub-elements, processes intermediate results and then returns the final result to the client.


The Client works with all elements through the component interface. As a result, the client can work in the same way with both simple or complex elements of the tree.




 Use the Composite pattern when you have to implement a tree-like object structure.

 The Composite pattern provides you with two basic element types that share a common interface: simple leaves and complex containers. A container can be composed of both leaves and other containers. This lets you construct a nested recursive object structure that resembles a tree.


 Use the pattern when you want the client code to treat both simple and complex elements uniformly.

 All elements defined by the Composite pattern share a common interface. Using this interface, the client doesn’t have to worry about the concrete class of the objects it works with.



Make sure that the core model of your app can be represented as a tree structure. Try to break it down into simple elements and containers. Remember that containers must be able to contain both simple elements and other containers.


Declare the component interface with a list of methods that make sense for both simple and complex components.


Create a leaf class to represent simple elements. A program may have multiple different leaf classes.


Create a container class to represent complex elements. In this class, provide an array field for storing references to sub-elements. The array must be able to store both leaves and containers, so make sure it’s declared with the component interface type.
While implementing the methods of the component interface, remember that a container is supposed to be delegating most of the work to sub-elements.


Finally, define the methods for adding and removal of child elements in the container.
Keep in mind that these operations can be declared in the component interface. This would violate the Interface Segregation Principle because the methods will be empty in the leaf class. However, the client will be able to treat all the elements equally, even when composing the tree.




 You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage.

 Open/Closed Principle. You can introduce new element types into the app without breaking the existing code, which now works with the object tree.




 It might be difficult to provide a common interface for classes whose functionality differs too much. In certain scenarios, you’d need to overgeneralize the component interface, making it harder to comprehend.



You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.


Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.


You can use Iterators to traverse Composite trees.


You can use Visitor to execute an operation over an entire Composite tree.


You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.
A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.
However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.

"
183,0,prototype,"
Basic implementation






The Prototype interface declares the cloning methods. In most cases, it’s a single clone method.


The Concrete Prototype class implements the cloning method. In addition to copying the original object’s data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies, etc.


The Client can produce a copy of any object that follows the prototype interface.

Prototype registry implementation






The Prototype Registry provides an easy way to access frequently-used prototypes. It stores a set of pre-built objects that are ready to be copied. The simplest prototype registry is a name → prototype hash map. However, if you need better search criteria than a simple name, you can build a much more robust version of the registry.




 Use the Prototype pattern when your code shouldn’t depend on the concrete classes of objects that you need to copy.

 This happens a lot when your code works with objects passed to you from 3rd-party code via some interface. The concrete classes of these objects are unknown, and you couldn’t depend on them even if you wanted to.
The Prototype pattern provides the client code with a general interface for working with all objects that support cloning. This interface makes the client code independent from the concrete classes of objects that it clones.


 Use the pattern when you want to reduce the number of subclasses that only differ in the way they initialize their respective objects.

 Suppose you have a complex class that requires a laborious configuration before it can be used. There are several common ways to configure this class, and this code is scattered through your app. To reduce the duplication, you create several subclasses and put every common configuration code into their constructors. You solved the duplication problem, but now you have lots of dummy subclasses.
The Prototype pattern lets you use a set of pre-built objects configured in various ways as prototypes. Instead of instantiating a subclass that matches some configuration, the client can simply look for an appropriate prototype and clone it.



Create the prototype interface and declare the clone method in it. Or just add the method to all classes of an existing class hierarchy, if you have one.


A prototype class must define the alternative constructor that accepts an object of that class as an argument. The constructor must copy the values of all fields defined in the class from the passed object into the newly created instance. If you’re changing a subclass, you must call the parent constructor to let the superclass handle the cloning of its private fields.
If your programming language doesn’t support method overloading, you won’t be able to create a separate “prototype” constructor. Thus, copying the object’s data into the newly created clone will have to be performed within the clone method. Still, having this code in a regular constructor is safer because the resulting object is returned fully configured right after you call the new operator.


The cloning method usually consists of just one line: running a new operator with the prototypical version of the constructor. Note, that every class must explicitly override the cloning method and use its own class name along with the new operator. Otherwise, the cloning method may produce an object of a parent class.


Optionally, create a centralized prototype registry to store a catalog of frequently used prototypes.
You can implement the registry as a new factory class or put it in the base prototype class with a static method for fetching the prototype. This method should search for a prototype based on search criteria that the client code passes to the method. The criteria might either be a simple string tag or a complex set of search parameters. After the appropriate prototype is found, the registry should clone it and return the copy to the client.
Finally, replace the direct calls to the subclasses’ constructors with calls to the factory method of the prototype registry.




 You can clone objects without coupling to their concrete classes.

 You can get rid of repeated initialization code in favor of cloning pre-built prototypes.

 You can produce complex objects more conveniently.

 You get an alternative to inheritance when dealing with configuration presets for complex objects.




 Cloning complex objects that have circular references might be very tricky.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


Prototype can help when you need to save copies of Commands into history.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.


Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.


Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
184,0,state,"
In Draft, it moves the document to moderation.
In Moderation, it makes the document public, but only if the current user is an administrator.
In Published, it doesn’t do anything at all.

When the phone is unlocked, pressing buttons leads to executing various functions.
When the phone is locked, pressing any button leads to the unlock screen.
When the phone’s charge is low, pressing any button shows the charging screen.





Context stores a reference to one of the concrete state objects and delegates to it all state-specific work. The context communicates with the state object via the state interface. The context exposes a setter for passing it a new state object.


The State interface declares the state-specific methods. These methods should make sense for all concrete states because you don’t want some of your states to have useless methods that will never be called.


Concrete States provide their own implementations for the state-specific methods. To avoid duplication of similar code across multiple states, you may provide intermediate abstract classes that encapsulate some common behavior.
State objects may store a backreference to the context object. Through this reference, the state can fetch any required info from the context object, as well as initiate state transitions.


Both context and concrete states can set the next state of the context and perform the actual state transition by replacing the state object linked to the context.




 Use the State pattern when you have an object that behaves differently depending on its current state, the number of states is enormous, and the state-specific code changes frequently.

 The pattern suggests that you extract all state-specific code into a set of distinct classes. As a result, you can add new states or change existing ones independently of each other, reducing the maintenance cost.


 Use the pattern when you have a class polluted with massive conditionals that alter how the class behaves according to the current values of the class’s fields.

 The State pattern lets you extract branches of these conditionals into methods of corresponding state classes. While doing so, you can also clean temporary fields and helper methods involved in state-specific code out of your main class.


 Use State when you have a lot of duplicate code across similar states and transitions of a condition-based state machine.

 The State pattern lets you compose hierarchies of state classes and reduce duplication by extracting common code into abstract base classes.



Decide what class will act as the context. It could be an existing class which already has the state-dependent code; or a new class, if the state-specific code is distributed across multiple classes.


Declare the state interface. Although it may mirror all the methods declared in the context, aim only for those that may contain state-specific behavior.


For every actual state, create a class that derives from the state interface. Then go over the methods of the context and extract all code related to that state into your newly created class.
While moving the code to the state class, you might discover that it depends on private members of the context. There are several workarounds:

Make these fields or methods public.
Turn the behavior you’re extracting into a public method in the context and call it from the state class. This way is ugly but quick, and you can always fix it later.
Nest the state classes into the context class, but only if your programming language supports nesting classes.



In the context class, add a reference field of the state interface type and a public setter that allows overriding the value of that field.


Go over the method of the context again and replace empty state conditionals with calls to corresponding methods of the state object.


To switch the state of the context, create an instance of one of the state classes and pass it to the context. You can do this within the context itself, or in various states, or in the client. Wherever this is done, the class becomes dependent on the concrete state class that it instantiates.




 Single Responsibility Principle. Organize the code related to particular states into separate classes.

 Open/Closed Principle. Introduce new states without changing existing state classes or the context.

 Simplify the code of the context by eliminating bulky state machine conditionals.




 Applying the pattern can be overkill if a state machine has only a few states or rarely changes.



Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn’t restrict dependencies between concrete states, letting them alter the state of the context at will.

"
185,0,strategy,"




The Context maintains a reference to one of the concrete strategies and communicates with this object only via the strategy interface.


The Strategy interface is common to all concrete strategies. It declares a method the context uses to execute a strategy.


Concrete Strategies implement different variations of an algorithm the context uses.


The context calls the execution method on the linked strategy object each time it needs to run the algorithm. The context doesn’t know what type of strategy it works with or how the algorithm is executed.


The Client creates a specific strategy object and passes it to the context. The context exposes a setter which lets clients replace the strategy associated with the context at runtime.




 Use the Strategy pattern when you want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime.

 The Strategy pattern lets you indirectly alter the object’s behavior at runtime by associating it with different sub-objects which can perform specific sub-tasks in different ways.


 Use the Strategy when you have a lot of similar classes that only differ in the way they execute some behavior.

 The Strategy pattern lets you extract the varying behavior into a separate class hierarchy and combine the original classes into one, thereby reducing duplicate code.


 Use the pattern to isolate the business logic of a class from the implementation details of algorithms that may not be as important in the context of that logic.

 The Strategy pattern lets you isolate the code, internal data, and dependencies of various algorithms from the rest of the code. Various clients get a simple interface to execute the algorithms and switch them at runtime.


 Use the pattern when your class has a massive conditional statement that switches between different variants of the same algorithm.

 The Strategy pattern lets you do away with such a conditional by extracting all algorithms into separate classes, all of which implement the same interface. The original object delegates execution to one of these objects, instead of implementing all variants of the algorithm.



In the context class, identify an algorithm that’s prone to frequent changes. It may also be a massive conditional that selects and executes a variant of the same algorithm at runtime.


Declare the strategy interface common to all variants of the algorithm.


One by one, extract all algorithms into their own classes. They should all implement the strategy interface.


In the context class, add a field for storing a reference to a strategy object. Provide a setter for replacing values of that field. The context should work with the strategy object only via the strategy interface. The context may define an interface which lets the strategy access its data.


Clients of the context must associate it with a suitable strategy that matches the way they expect the context to perform its primary job.




 You can swap algorithms used inside an object at runtime.

 You can isolate the implementation details of an algorithm from the code that uses it.

 You can replace inheritance with composition.

 Open/Closed Principle. You can introduce new strategies without having to change the context.




 If you only have a couple of algorithms and they rarely change, there’s no real reason to overcomplicate the program with new classes and interfaces that come along with the pattern.

 Clients must be aware of the differences between strategies to be able to select a proper one.

 A lot of modern programming languages have functional type support that lets you implement different versions of an algorithm inside a set of anonymous functions. Then you could use these functions exactly as you’d have used the strategy objects, but without bloating your code with extra classes and interfaces.



Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.


You can use Command to convert any operation into an object. The operation’s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.


On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.




Decorator lets you change the skin of an object, while Strategy lets you change the guts.


Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object’s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it’s static. Strategy works on the object level, letting you switch behaviors at runtime.


State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn’t restrict dependencies between concrete states, letting them alter the state of the context at will.

"
186,0,template_method,"

abstract steps must be implemented by every subclass

optional steps already have some default implementation, but still can be overridden if needed





The Abstract Class declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order. The steps may either be declared abstract or have some default implementation.


Concrete Classes can override all of the steps, but not the template method itself.




 Use the Template Method pattern when you want to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure.

 The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass.


 Use the pattern when you have several classes that contain almost identical algorithms with some minor differences. As a result, you might need to modify all classes when the algorithm changes.

 When you turn such an algorithm into a template method, you can also pull up the steps with similar implementations into a superclass, eliminating code duplication. Code that varies between subclasses can remain in subclasses.



Analyze the target algorithm to see whether you can break it into steps. Consider which steps are common to all subclasses and which ones will always be unique.


Create the abstract base class and declare the template method and a set of abstract methods representing the algorithm’s steps. Outline the algorithm’s structure in the template method by executing corresponding steps. Consider making the template method final to prevent subclasses from overriding it.


It’s okay if all the steps end up being abstract. However, some steps might benefit from having a default implementation. Subclasses don’t have to implement those methods.


Think of adding hooks between the crucial steps of the algorithm.


For each variation of the algorithm, create a new concrete subclass. It must implement all of the abstract steps, but may also override some of the optional ones.




 You can let clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm.

 You can pull the duplicate code into a superclass.




 Some clients may be limited by the provided skeleton of an algorithm.

 You might violate the Liskov Substitution Principle by suppressing a default step implementation via a subclass.

 Template methods tend to be harder to maintain the more steps they have.



Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.


Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object’s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it’s static. Strategy works on the object level, letting you switch behaviors at runtime.

"
187,0,visitor,"
If it’s a residential building, he sells medical insurance.
If it’s a bank, he sells theft insurance.
If it’s a coffee shop, he sells fire and flood insurance.





The Visitor interface declares a set of visiting methods that can take concrete elements of an object structure as arguments. These methods may have the same names if the program is written in a language that supports overloading, but the type of their parameters must be different.


Each Concrete Visitor implements several versions of the same behaviors, tailored for different concrete element classes.


The Element interface declares a method for “accepting” visitors. This method should have one parameter declared with the type of the visitor interface.


Each Concrete Element must implement the acceptance method. The purpose of this method is to redirect the call to the proper visitor’s method corresponding to the current element class. Be aware that even if a base element class implements this method, all subclasses must still override this method in their own classes and call the appropriate method on the visitor object.


The Client usually represents a collection or some other complex object (for example, a Composite tree). Usually, clients aren’t aware of all the concrete element classes because they work with objects from that collection via some abstract interface.




 Use the Visitor when you need to perform an operation on all elements of a complex object structure (for example, an object tree).

 The Visitor pattern lets you execute an operation over a set of objects with different classes by having a visitor object implement several variants of the same operation, which correspond to all target classes.


 Use the Visitor to clean up the business logic of auxiliary behaviors.

 The pattern lets you make the primary classes of your app more focused on their main jobs by extracting all other behaviors into a set of visitor classes.


 Use the pattern when a behavior makes sense only in some classes of a class hierarchy, but not in others.

 You can extract this behavior into a separate visitor class and implement only those visiting methods that accept objects of relevant classes, leaving the rest empty.



Declare the visitor interface with a set of “visiting” methods, one per each concrete element class that exists in the program.


Declare the element interface. If you’re working with an existing element class hierarchy, add the abstract “acceptance” method to the base class of the hierarchy. This method should accept a visitor object as an argument.


Implement the acceptance methods in all concrete element classes. These methods must simply redirect the call to a visiting method on the incoming visitor object which matches the class of the current element.


The element classes should only work with visitors via the visitor interface. Visitors, however, must be aware of all concrete element classes, referenced as parameter types of the visiting methods.


For each behavior that can’t be implemented inside the element hierarchy, create a new concrete visitor class and implement all of the visiting methods.
You might encounter a situation where the visitor will need access to some private members of the element class. In this case, you can either make these fields or methods public, violating the element’s encapsulation, or nest the visitor class in the element class. The latter is only possible if you’re lucky to work with a programming language that supports nested classes.


The client must create visitor objects and pass them into elements via “acceptance” methods.




 Open/Closed Principle. You can introduce a new behavior that can work with objects of different classes without changing these classes.

 Single Responsibility Principle. You can move multiple versions of the same behavior into the same class.

 A visitor object can accumulate some useful information while working with various objects. This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure.




 You need to update all visitors each time a class gets added to or removed from the element hierarchy.

 Visitors might lack the necessary access to the private fields and methods of the elements that they’re supposed to work with.



You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.


You can use Visitor to execute an operation over an entire Composite tree.


You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.


Puzzled why we can’t simply replace the Visitor pattern with method overloading? Read my article Visitor and Double Dispatch to learn about the nasty details.
"
188,0,factory_method,"




The Product declares the interface, which is common to all objects that can be produced by the creator and its subclasses.


Concrete Products are different implementations of the product interface.


The Creator class declares the factory method that returns new product objects. It’s important that the return type of this method matches the product interface.
You can declare the factory method as abstract to force all subclasses to implement their own versions of the method. As an alternative, the base factory method can return some default product type.
Note, despite its name, product creation is not the primary responsibility of the creator. Usually, the creator class already has some core business logic related to products. The factory method helps to decouple this logic from the concrete product classes. Here is an analogy: a large software development company can have a training department for programmers. However, the primary function of the company as a whole is still writing code, not producing programmers.


Concrete Creators override the base factory method so it returns a different type of product.
Note that the factory method doesn’t have to create new instances all the time. It can also return existing objects from a cache, an object pool, or another source.




 Use the Factory Method when you don’t know beforehand the exact types and dependencies of the objects your code should work with.

 The Factory Method separates product construction code from the code that actually uses the product. Therefore it’s easier to extend the product construction code independently from the rest of the code.
For example, to add a new product type to the app, you’ll only need to create a new creator subclass and override the factory method in it.


 Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.

 Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component?
The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself.
Let’s see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard Button class with a glorious RoundButton subclass. But now you need to tell the main UIFramework class to use the new button subclass instead of a default one.
To achieve this, you create a subclass UIWithRoundButtons from a base framework class and override its createButton method. While this method returns Button objects in the base class, you make your subclass return RoundButton objects. Now use the UIWithRoundButtons class instead of UIFramework. And that’s about it!


 Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time.

 You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources.
Let’s think about what has to be done to reuse an existing object:

First, you need to create some storage to keep track of all of the created objects.
When someone requests an object, the program should look for a free object inside that pool.
… and then return it to the client code.
If there are no free objects, the program should create a new one (and add it to the pool).

That’s a lot of code! And it must all be put into a single place so that you don’t pollute the program with duplicate code.
Probably the most obvious and convenient place where this code could be placed is the constructor of the class whose objects we’re trying to reuse. However, a constructor must always return new objects by definition. It can’t return existing instances.
Therefore, you need to have a regular method capable of creating new objects as well as reusing existing ones. That sounds very much like a factory method.



Make all products follow the same interface. This interface should declare methods that make sense in every product.


Add an empty factory method inside the creator class. The return type of the method should match the common product interface.


In the creator’s code find all references to product constructors. One by one, replace them with calls to the factory method, while extracting the product creation code into the factory method.
You might need to add a temporary parameter to the factory method to control the type of returned product.
At this point, the code of the factory method may look pretty ugly. It may have a large switch statement that picks which product class to instantiate. But don’t worry, we’ll fix it soon enough.


Now, create a set of creator subclasses for each type of product listed in the factory method. Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.


If there are too many product types and it doesn’t make sense to create subclasses for all of them, you can reuse the control parameter from the base class in subclasses.
For instance, imagine that you have the following hierarchy of classes: the base Mail class with a couple of subclasses: AirMail and GroundMail; the Transport classes are Plane, Truck and Train. While the AirMail class only uses Plane objects, GroundMail may work with both Truck and Train objects. You can create a new subclass (say TrainMail) to handle both cases, but there’s another option. The client code can pass an argument to the factory method of the GroundMail class to control which product it wants to receive.


If, after all of the extractions, the base factory method has become empty, you can make it abstract. If there’s something left, you can make it a default behavior of the method.




 You avoid tight coupling between the creator and the concrete products.

 Single Responsibility Principle. You can move the product creation code into one place in the program, making the code easier to support.

 Open/Closed Principle. You can introduce new types of products into the program without breaking existing client code.




 The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern. The best case scenario is when you’re introducing the pattern into an existing hierarchy of creator classes.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.


Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.


Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.


Read our Factory Comparison if you can’t figure out the difference between various factory patterns and concepts.
"
189,0,decorator,"
Inheritance is static. You can’t alter the behavior of an existing object at runtime. You can only replace the whole object with another one that’s created from a different subclass.
Subclasses can have just one parent class. In most languages, inheritance doesn’t let a class inherit behaviors of multiple classes at the same time.





The Component declares the common interface for both wrappers and wrapped objects.


Concrete Component is a class of objects being wrapped. It defines the basic behavior, which can be altered by decorators.


The Base Decorator class has a field for referencing a wrapped object. The field’s type should be declared as the component interface so it can contain both concrete components and decorators. The base decorator delegates all operations to the wrapped object.


Concrete Decorators define extra behaviors that can be added to components dynamically. Concrete decorators override methods of the base decorator and execute their behavior either before or after calling the parent method.


The Client can wrap components in multiple layers of decorators, as long as it works with all objects via the component interface.




Just before the data is written to disk, the decorators encrypt and compress it. The original class writes the encrypted and protected data to the file without knowing about the change.


Right after the data is read from disk, it goes through the same decorators, which decompress and decode it.



 Use the Decorator pattern when you need to be able to assign extra behaviors to objects at runtime without breaking the code that uses these objects.

 The Decorator lets you structure your business logic into layers, create a decorator for each layer and compose objects with various combinations of this logic at runtime. The client code can treat all these objects in the same way, since they all follow a common interface.


 Use the pattern when it’s awkward or not possible to extend an object’s behavior using inheritance.

 Many programming languages have the final keyword that can be used to prevent further extension of a class. For a final class, the only way to reuse the existing behavior would be to wrap the class with your own wrapper, using the Decorator pattern.



Make sure your business domain can be represented as a primary component with multiple optional layers over it.


Figure out what methods are common to both the primary component and the optional layers. Create a component interface and declare those methods there.


Create a concrete component class and define the base behavior in it.


Create a base decorator class. It should have a field for storing a reference to a wrapped object. The field should be declared with the component interface type to allow linking to concrete components as well as decorators. The base decorator must delegate all work to the wrapped object.


Make sure all classes implement the component interface.


Create concrete decorators by extending them from the base decorator. A concrete decorator must execute its behavior before or after the call to the parent method (which always delegates to the wrapped object).


The client code must be responsible for creating decorators and composing them in the way the client needs.




 You can extend an object’s behavior without making a new subclass.

 You can add or remove responsibilities from an object at runtime.

 You can combine several behaviors by wrapping an object into multiple decorators.

 Single Responsibility Principle. You can divide a monolithic class that implements many possible variants of behavior into several smaller classes.




 It’s hard to remove a specific wrapper from the wrappers stack.

 It’s hard to implement a decorator in such a way that its behavior doesn’t depend on the order in the decorators stack.

 The initial configuration code of layers might look pretty ugly.



Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.


Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.
The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.


Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.
A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.
However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.


Decorator lets you change the skin of an object, while Strategy lets you change the guts.


Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.

"
190,0,prototype,"
Basic implementation






The Prototype interface declares the cloning methods. In most cases, it’s a single clone method.


The Concrete Prototype class implements the cloning method. In addition to copying the original object’s data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies, etc.


The Client can produce a copy of any object that follows the prototype interface.

Prototype registry implementation






The Prototype Registry provides an easy way to access frequently-used prototypes. It stores a set of pre-built objects that are ready to be copied. The simplest prototype registry is a name → prototype hash map. However, if you need better search criteria than a simple name, you can build a much more robust version of the registry.




 Use the Prototype pattern when your code shouldn’t depend on the concrete classes of objects that you need to copy.

 This happens a lot when your code works with objects passed to you from 3rd-party code via some interface. The concrete classes of these objects are unknown, and you couldn’t depend on them even if you wanted to.
The Prototype pattern provides the client code with a general interface for working with all objects that support cloning. This interface makes the client code independent from the concrete classes of objects that it clones.


 Use the pattern when you want to reduce the number of subclasses that only differ in the way they initialize their respective objects.

 Suppose you have a complex class that requires a laborious configuration before it can be used. There are several common ways to configure this class, and this code is scattered through your app. To reduce the duplication, you create several subclasses and put every common configuration code into their constructors. You solved the duplication problem, but now you have lots of dummy subclasses.
The Prototype pattern lets you use a set of pre-built objects configured in various ways as prototypes. Instead of instantiating a subclass that matches some configuration, the client can simply look for an appropriate prototype and clone it.



Create the prototype interface and declare the clone method in it. Or just add the method to all classes of an existing class hierarchy, if you have one.


A prototype class must define the alternative constructor that accepts an object of that class as an argument. The constructor must copy the values of all fields defined in the class from the passed object into the newly created instance. If you’re changing a subclass, you must call the parent constructor to let the superclass handle the cloning of its private fields.
If your programming language doesn’t support method overloading, you won’t be able to create a separate “prototype” constructor. Thus, copying the object’s data into the newly created clone will have to be performed within the clone method. Still, having this code in a regular constructor is safer because the resulting object is returned fully configured right after you call the new operator.


The cloning method usually consists of just one line: running a new operator with the prototypical version of the constructor. Note, that every class must explicitly override the cloning method and use its own class name along with the new operator. Otherwise, the cloning method may produce an object of a parent class.


Optionally, create a centralized prototype registry to store a catalog of frequently used prototypes.
You can implement the registry as a new factory class or put it in the base prototype class with a static method for fetching the prototype. This method should search for a prototype based on search criteria that the client code passes to the method. The criteria might either be a simple string tag or a complex set of search parameters. After the appropriate prototype is found, the registry should clone it and return the copy to the client.
Finally, replace the direct calls to the subclasses’ constructors with calls to the factory method of the prototype registry.




 You can clone objects without coupling to their concrete classes.

 You can get rid of repeated initialization code in favor of cloning pre-built prototypes.

 You can produce complex objects more conveniently.

 You get an alternative to inheritance when dealing with configuration presets for complex objects.




 Cloning complex objects that have circular references might be very tricky.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


Prototype can help when you need to save copies of Commands into history.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.


Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.


Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
191,0,builder,"Director




The Builder interface declares product construction steps that are common to all types of builders.


Concrete Builders provide different implementations of the construction steps. Concrete builders may produce products that don’t follow the common interface.


Products are resulting objects. Products constructed by different builders don’t have to belong to the same class hierarchy or interface.


The Director class defines the order in which to call construction steps, so you can create and reuse specific configurations of products.


The Client must associate one of the builder objects with the director. Usually, it’s done just once, via parameters of the director’s constructor. Then the director uses that builder object for all further construction. However, there’s an alternative approach for when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.




 Use the Builder pattern to get rid of a “telescoping constructor”.

 Say you have a constructor with ten optional parameters. Calling such a beast is very inconvenient; therefore, you overload the constructor and create several shorter versions with fewer parameters. These constructors still refer to the main one, passing some default values into any omitted parameters.

class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...


Creating such a monster is only possible in languages that support method overloading, such as C# or Java.


The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don’t have to cram dozens of parameters into your constructors anymore.


 Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).

 The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details.
The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction.


 Use the Builder to construct Composite trees or other complex objects.

 The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree.
A builder doesn’t expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result.



Make sure that you can clearly define the common construction steps for building all available product representations. Otherwise, you won’t be able to proceed with implementing the pattern.


Declare these steps in the base builder interface.


Create a concrete builder class for each of the product representations and implement their construction steps.
Don’t forget about implementing a method for fetching the result of the construction. The reason why this method can’t be declared inside the builder interface is that various builders may construct products that don’t have a common interface. Therefore, you don’t know what would be the return type for such a method. However, if you’re dealing with products from a single hierarchy, the fetching method can be safely added to the base interface.


Think about creating a director class. It may encapsulate various ways to construct a product using the same builder object.


The client code creates both the builder and the director objects. Before construction starts, the client must pass a builder object to the director. Usually, the client does this only once, via parameters of the director’s class constructor. The director uses the builder object in all further construction. There’s an alternative approach, where the builder is passed to a specific product construction method of the director.


The construction result can be obtained directly from the director only if all products follow the same interface. Otherwise, the client should fetch the result from the builder.




 You can construct objects step-by-step, defer construction steps or run steps recursively.

 You can reuse the same construction code when building various representations of products.

 Single Responsibility Principle. You can isolate complex construction code from the business logic of the product.




 The overall complexity of the code increases since the pattern requires creating multiple new classes.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.


You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.


You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
192,0,abstract_factory,"

A family of related products, say: Chair + Sofa + CoffeeTable.


Several variants of this family. For example, products Chair + Sofa + CoffeeTable are available in these variants: Modern, Victorian, ArtDeco.






Abstract Products declare interfaces for a set of distinct but related products which make up a product family.


Concrete Products are various implementations of abstract products, grouped by variants. Each abstract product (chair/sofa) must be implemented in all given variants (Victorian/Modern).


The Abstract Factory interface declares a set of methods for creating each of the abstract products.


Concrete Factories implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.


Although concrete factories instantiate concrete products, signatures of their creation methods must return corresponding abstract products. This way the client code that uses a factory doesn’t get coupled to the specific variant of the product it gets from a factory. The Client can work with any concrete factory/product variant, as long as it communicates with their objects via abstract interfaces.




 Use the Abstract Factory when your code needs to work with various families of related products, but you don’t want it to depend on the concrete classes of those products—they might be unknown beforehand or you simply want to allow for future extensibility.

 The Abstract Factory provides you with an interface for creating objects from each class of the product family. As long as your code creates objects via this interface, you don’t have to worry about creating the wrong variant of a product which doesn’t match the products already created by your app.


 Consider implementing the Abstract Factory when you have a class with a set of Factory Methods that blur its primary responsibility.

 In a well-designed program each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.



Map out a matrix of distinct product types versus variants of these products.


Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.


Declare the abstract factory interface with a set of creation methods for all abstract products.


Implement a set of concrete factory classes, one for each product variant.


Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.


Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.




 You can be sure that the products you’re getting from a factory are compatible with each other.

 You avoid tight coupling between concrete products and client code.

 Single Responsibility Principle. You can extract the product creation code into one place, making the code easier to support.

 Open/Closed Principle. You can introduce new variants of products without breaking existing client code.




 The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.


Read our Factory Comparison to learn more about the differences between various factory patterns and concepts.
"
193,0,singleton,"

Ensure that a class has just a single instance. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource—for example, a database or a file.
Here’s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you’ll get the one you already created.
Note that this behavior is impossible to implement with a regular constructor since a constructor call must always return a new object by design.


Make the default constructor private, to prevent other objects from using the new operator with the Singleton class.
Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.





The Singleton class declares the static method getInstance that returns the same instance of its own class.
The Singleton’s constructor should be hidden from the client code. Calling the getInstance method should be the only way of getting the Singleton object.




 Use the Singleton pattern when a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program.

 The Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created.


 Use the Singleton pattern when you need stricter control over global variables.

 Unlike global variables, the Singleton pattern guarantees that there’s just one instance of a class. Nothing, except for the Singleton class itself, can replace the cached instance.
Note that you can always adjust this limitation and allow creating any number of Singleton instances. The only piece of code that needs changing is the body of the getInstance method.



Add a private static field to the class for storing the singleton instance.


Declare a public static creation method for getting the singleton instance.


Implement “lazy initialization” inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.


Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.


Go over the client code and replace all direct calls to the singleton’s constructor with calls to its static creation method.




 You can be sure that a class has only a single instance.

 You gain a global access point to that instance.

 The singleton object is initialized only when it’s requested for the first time.




 Violates the Single Responsibility Principle. The pattern solves two problems at the time.

 The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other.

 The pattern requires special treatment in a multithreaded environment so that multiple threads won’t create a singleton object several times.

 It may be difficult to unit test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don’t write the tests. Or don’t use the Singleton pattern.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.



Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
194,0,adapter,"
The adapter gets an interface, compatible with one of the existing objects.
Using this interface, the existing object can safely call the adapter’s methods.
Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects.

Object adapter
This implementation uses the object composition principle: the adapter implements the interface of one object and wraps the other one. It can be implemented in all popular programming languages.






The Client is a class that contains the existing business logic of the program.


The Client Interface describes a protocol that other classes must follow to be able to collaborate with the client code.


The Service is some useful class (usually 3rd-party or legacy). The client can’t use this class directly because it has an incompatible interface.


The Adapter is a class that’s able to work with both the client and the service: it implements the client interface, while wrapping the service object. The adapter receives calls from the client via the adapter interface and translates them into calls to the wrapped service object in a format it can understand.


The client code doesn’t get coupled to the concrete adapter class as long as it works with the adapter via the client interface. Thanks to this, you can introduce new types of adapters into the program without breaking the existing client code. This can be useful when the interface of the service class gets changed or replaced: you can just create a new adapter class without changing the client code.

Class adapter
This implementation uses inheritance: the adapter inherits interfaces from both objects at the same time. Note that this approach can only be implemented in programming languages that support multiple inheritance, such as C++.






The Class Adapter doesn’t need to wrap any objects because it inherits behaviors from both the client and the service. The adaptation happens within the overridden methods. The resulting adapter can be used in place of an existing client class.




 Use the Adapter class when you want to use some existing class, but its interface isn’t compatible with the rest of your code.

 The Adapter pattern lets you create a middle-layer class that serves as a translator between your code and a legacy class, a 3rd-party class or any other class with a weird interface.


 Use the pattern when you want to reuse several existing subclasses that lack some common functionality that can’t be added to the superclass.

 You could extend each subclass and put the missing functionality into new child classes. However, you’ll need to duplicate the code across all of these new classes, which smells really bad.
The much more elegant solution would be to put the missing functionality into an adapter class. Then you would wrap objects with missing features inside the adapter, gaining needed features dynamically. For this to work, the target classes must have a common interface, and the adapter’s field should follow that interface. This approach looks very similar to the Decorator pattern.



Make sure that you have at least two classes with incompatible interfaces:

A useful service class, which you can’t change (often 3rd-party, legacy or with lots of existing dependencies).
One or several client classes that would benefit from using the service class.



Declare the client interface and describe how clients communicate with the service.


Create the adapter class and make it follow the client interface. Leave all the methods empty for now.


Add a field to the adapter class to store a reference to the service object. The common practice is to initialize this field via the constructor, but sometimes it’s more convenient to pass it to the adapter when calling its methods.


One by one, implement all methods of the client interface in the adapter class. The adapter should delegate most of the real work to the service object, handling only the interface or data format conversion.


Clients should use the adapter via the client interface. This will let you change or extend the adapters without affecting the client code.




 Single Responsibility Principle. You can separate the interface or data conversion code from the primary business logic of the program.

 Open/Closed Principle. You can introduce new types of adapters into the program without breaking the existing client code, as long as they work with the adapters through the client interface.




 The overall complexity of the code increases because you need to introduce a set of new interfaces and classes. Sometimes it’s simpler just to change the service class so that it matches the rest of your code.



Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.


Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.


Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.


Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.

"
195,0,bridge,"Abstraction and Implementation
Have several different GUIs (for instance, tailored for regular customers or admins).
Support several different APIs (for example, to be able to launch the app under Windows, Linux, and macOS).

Abstraction: the GUI layer of the app.
Implementation: the operating systems’ APIs.





The Abstraction provides high-level control logic. It relies on the implementation object to do the actual low-level work.


The Implementation declares the interface that’s common for all concrete implementations. An abstraction can only communicate with an implementation object via methods that are declared here.
The abstraction may list the same methods as the implementation, but usually the abstraction declares some complex behaviors that rely on a wide variety of primitive operations declared by the implementation.


Concrete Implementations contain platform-specific code.


Refined Abstractions provide variants of control logic. Like their parent, they work with different implementations via the general implementation interface.


Usually, the Client is only interested in working with the abstraction. However, it’s the client’s job to link the abstraction object with one of the implementation objects.




 Use the Bridge pattern when you want to divide and organize a monolithic class that has several variants of some functionality (for example, if the class can work with various database servers).

 The bigger a class becomes, the harder it is to figure out how it works, and the longer it takes to make a change. The changes made to one of the variations of functionality may require making changes across the whole class, which often results in making errors or not addressing some critical side effects.
The Bridge pattern lets you split the monolithic class into several class hierarchies. After this, you can change the classes in each hierarchy independently of the classes in the others. This approach simplifies code maintenance and minimizes the risk of breaking existing code.


 Use the pattern when you need to extend a class in several orthogonal (independent) dimensions.

 The Bridge suggests that you extract a separate class hierarchy for each of the dimensions. The original class delegates the related work to the objects belonging to those hierarchies instead of doing everything on its own.


 Use the Bridge if you need to be able to switch implementations at runtime.

 Although it’s optional, the Bridge pattern lets you replace the implementation object inside the abstraction. It’s as easy as assigning a new value to a field.
By the way, this last item is the main reason why so many people confuse the Bridge with the Strategy pattern. Remember that a pattern is more than just a certain way to structure your classes. It may also communicate intent and a problem being addressed.



Identify the orthogonal dimensions in your classes. These independent concepts could be: abstraction/platform, domain/infrastructure, front-end/back-end, or interface/implementation.


See what operations the client needs and define them in the base abstraction class.


Determine the operations available on all platforms. Declare the ones that the abstraction needs in the general implementation interface.


For all platforms in your domain create concrete implementation classes, but make sure they all follow the implementation interface.


Inside the abstraction class, add a reference field for the implementation type. The abstraction delegates most of the work to the implementation object that’s referenced in that field.


If you have several variants of high-level logic, create refined abstractions for each variant by extending the base abstraction class.


The client code should pass an implementation object to the abstraction’s constructor to associate one with the other. After that, the client can forget about the implementation and work only with the abstraction object.




 You can create platform-independent classes and apps.

 The client code works with high-level abstractions. It isn’t exposed to the platform details.

 Open/Closed Principle. You can introduce new abstractions and implementations independently from each other.

 Single Responsibility Principle. You can focus on high-level logic in the abstraction and on platform details in the implementation.




 You might make the code more complicated by applying the pattern to a highly cohesive class.



Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.


Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.


You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.

"
196,0,facade,"




The Facade provides convenient access to a particular part of the subsystem’s functionality. It knows where to direct the client’s request and how to operate all the moving parts.


An Additional Facade class can be created to prevent polluting a single facade with unrelated features that might make it yet another complex structure. Additional facades can be used by both clients and other facades.


The Complex Subsystem consists of dozens of various objects. To make them all do something meaningful, you have to dive deep into the subsystem’s implementation details, such as initializing objects in the correct order and supplying them with data in the proper format.
Subsystem classes aren’t aware of the facade’s existence. They operate within the system and work with each other directly.


The Client uses the facade instead of calling the subsystem objects directly.




 Use the Facade pattern when you need to have a limited but straightforward interface to a complex subsystem.

 Often, subsystems get more complex over time. Even applying design patterns typically leads to creating more classes. A subsystem may become more flexible and easier to reuse in various contexts, but the amount of configuration and boilerplate code it demands from a client grows ever larger. The Facade attempts to fix this problem by providing a shortcut to the most-used features of the subsystem which fit most client requirements.


 Use the Facade when you want to structure a subsystem into layers.

 Create facades to define entry points to each level of a subsystem. You can reduce coupling between multiple subsystems by requiring them to communicate only through facades.
For example, let’s return to our video conversion framework. It can be broken down into two layers: video- and audio-related. For each layer, you can create a facade and then make the classes of each layer communicate with each other via those facades. This approach looks very similar to the Mediator pattern.



Check whether it’s possible to provide a simpler interface than what an existing subsystem already provides. You’re on the right track if this interface makes the client code independent from many of the subsystem’s classes.


Declare and implement this interface in a new facade class. The facade should redirect the calls from the client code to appropriate objects of the subsystem. The facade should be responsible for initializing the subsystem and managing its further life cycle unless the client code already does this.


To get the full benefit from the pattern, make all the client code communicate with the subsystem only via the facade. Now the client code is protected from any changes in the subsystem code. For example, when a subsystem gets upgraded to a new version, you will only need to modify the code in the facade.


If the facade becomes too big, consider extracting part of its behavior to a new, refined facade class.




 You can isolate your code from the complexity of a subsystem.




 A facade can become a god object coupled to all classes of an app.



Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.


Facade defines a simplified interface to a subsystem of objects, but it doesn’t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

Mediator centralizes communication between components of the system. The components only know about the mediator object and don’t communicate directly.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.

"
197,0,flyweight,"Extrinsic state storageFlyweight and immutabilityFlyweight factory




The Flyweight pattern is merely an optimization. Before applying it, make sure your program does have the RAM consumption problem related to having a massive number of similar objects in memory at the same time. Make sure that this problem can’t be solved in any other meaningful way.


The Flyweight class contains the portion of the original object’s state that can be shared between multiple objects. The same flyweight object can be used in many different contexts. The state stored inside a flyweight is called intrinsic. The state passed to the flyweight’s methods is called extrinsic.


The Context class contains the extrinsic state, unique across all original objects. When a context is paired with one of the flyweight objects, it represents the full state of the original object.


Usually, the behavior of the original object remains in the flyweight class. In this case, whoever calls a flyweight’s method must also pass appropriate bits of the extrinsic state into the method’s parameters. On the other hand, the behavior can be moved to the context class, which would use the linked flyweight merely as a data object.


The Client calculates or stores the extrinsic state of flyweights. From the client’s perspective, a flyweight is a template object which can be configured at runtime by passing some contextual data into parameters of its methods.


The Flyweight Factory manages a pool of existing flyweights. With the factory, clients don’t create flyweights directly. Instead, they call the factory, passing it bits of the intrinsic state of the desired flyweight. The factory looks over previously created flyweights and either returns an existing one that matches search criteria or creates a new one if nothing is found.




 Use the Flyweight pattern only when your program must support a huge number of objects which barely fit into available RAM.

 The benefit of applying the pattern depends heavily on how and where it’s used. It’s most useful when:

an application needs to spawn a huge number of similar objects
this drains all available RAM on a target device
the objects contain duplicate states which can be extracted and shared between multiple objects




Divide fields of a class that will become a flyweight into two parts:

the intrinsic state: the fields that contain unchanging data duplicated across many objects
the extrinsic state: the fields that contain contextual data unique to each object



Leave the fields that represent the intrinsic state in the class, but make sure they’re immutable. They should take their initial values only inside the constructor.


Go over methods that use fields of the extrinsic state. For each field used in the method, introduce a new parameter and use it instead of the field.


Optionally, create a factory class to manage the pool of flyweights. It should check for an existing flyweight before creating a new one. Once the factory is in place, clients must only request flyweights through it. They should describe the desired flyweight by passing its intrinsic state to the factory.


The client must store or calculate values of the extrinsic state (context) to be able to call methods of flyweight objects. For the sake of convenience, the extrinsic state along with the flyweight-referencing field may be moved to a separate context class.




 You can save lots of RAM, assuming your program has tons of similar objects.




 You might be trading RAM over CPU cycles when some of the context data needs to be recalculated each time somebody calls a flyweight method.

 The code becomes much more complicated. New team members will always be wondering why the state of an entity was separated in such a way.



You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.


"
198,0,proxy,"




The Service Interface declares the interface of the Service. The proxy must follow this interface to be able to disguise itself as a service object.


The Service is a class that provides some useful business logic.


The Proxy class has a reference field that points to a service object. After the proxy finishes its processing (e.g., lazy initialization, logging, access control, caching, etc.), it passes the request to the service object.
Usually, proxies manage the full lifecycle of their service objects.


The Client should work with both services and proxies via the same interface. This way you can pass a proxy into any code that expects a service object.



There are dozens of ways to utilize the Proxy pattern. Let’s go over the most popular uses.

 Lazy initialization (virtual proxy). This is when you have a heavyweight service object that wastes system resources by being always up, even though you only need it from time to time.

 Instead of creating the object when the app launches, you can delay the object’s initialization to a time when it’s really needed.


 Access control (protection proxy). This is when you want only specific clients to be able to use the service object; for instance, when your objects are crucial parts of an operating system and clients are various launched applications (including malicious ones).

 The proxy can pass the request to the service object only if the client’s credentials match some criteria.


 Local execution of a remote service (remote proxy). This is when the service object is located on a remote server.

 In this case, the proxy passes the client request over the network, handling all of the nasty details of working with the network.


 Logging requests (logging proxy). This is when you want to keep a history of requests to the service object.

 The proxy can log each request before passing it to the service.


 Caching request results (caching proxy). This is when you need to cache results of client requests and manage the life cycle of this cache, especially if results are quite large.

 The proxy can implement caching for recurring requests that always yield the same results. The proxy may use the parameters of requests as the cache keys.


 Smart reference. This is when you need to be able to dismiss a heavyweight object once there are no clients that use it.

 The proxy can keep track of clients that obtained a reference to the service object or its results. From time to time, the proxy may go over the clients and check whether they are still active. If the client list gets empty, the proxy might dismiss the service object and free the underlying system resources.
The proxy can also track whether the client had modified the service object. Then the unchanged objects may be reused by other clients.



If there’s no pre-existing service interface, create one to make proxy and service objects interchangeable. Extracting the interface from the service class isn’t always possible, because you’d need to change all of the service’s clients to use that interface. Plan B is to make the proxy a subclass of the service class, and this way it’ll inherit the interface of the service.


Create the proxy class. It should have a field for storing a reference to the service. Usually, proxies create and manage the whole life cycle of their services. On rare occasions, a service is passed to the proxy via a constructor by the client.


Implement the proxy methods according to their purposes. In most cases, after doing some work, the proxy should delegate the work to the service object.


Consider introducing a creation method that decides whether the client gets a proxy or a real service. This can be a simple static method in the proxy class or a full-blown factory method.


Consider implementing lazy initialization for the service object.




 You can control the service object without clients knowing about it.

 You can manage the lifecycle of the service object when clients don’t care about it.

 The proxy works even if the service object isn’t ready or is not available.

 Open/Closed Principle. You can introduce new proxies without changing the service or clients.




 The code may become more complicated since you need to introduce a lot of new classes.

 The response from the service might get delayed.



Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.


Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.

"
199,0,iterator,"




The Iterator interface declares the operations required for traversing a collection: fetching the next element, retrieving the current position, restarting iteration, etc.


Concrete Iterators implement specific algorithms for traversing a collection. The iterator object should track the traversal progress on its own. This allows several iterators to traverse the same collection independently of each other.


The Collection interface declares one or multiple methods for getting iterators compatible with the collection. Note that the return type of the methods must be declared as the iterator interface so that the concrete collections can return various kinds of iterators.


Concrete Collections return new instances of a particular concrete iterator class each time the client requests one. You might be wondering, where’s the rest of the collection’s code? Don’t worry, it should be in the same class. It’s just that these details aren’t crucial to the actual pattern, so we’re omitting them.


The Client works with both collections and iterators via their interfaces. This way the client isn’t coupled to concrete classes, allowing you to use various collections and iterators with the same client code.
Typically, clients don’t create iterators on their own, but instead get them from collections. Yet, in certain cases, the client can create one directly; for example, when the client defines its own special iterator.




 Use the Iterator pattern when your collection has a complex data structure under the hood, but you want to hide its complexity from clients (either for convenience or security reasons).

 The iterator encapsulates the details of working with a complex data structure, providing the client with several simple methods of accessing the collection elements. While this approach is very convenient for the client, it also protects the collection from careless or malicious actions which the client would be able to perform if working with the collection directly.


 Use the pattern to reduce duplication of the traversal code across your app.

 The code of non-trivial iteration algorithms tends to be very bulky. When placed within the business logic of an app, it may blur the responsibility of the original code and make it less maintainable. Moving the traversal code to designated iterators can help you make the code of the application more lean and clean.


 Use the Iterator when you want your code to be able to traverse different data structures or when types of these structures are unknown beforehand.

 The pattern provides a couple of generic interfaces for both collections and iterators. Given that your code now uses these interfaces, it’ll still work if you pass it various kinds of collections and iterators that implement these interfaces.



Declare the iterator interface. At the very least, it must have a method for fetching the next element from a collection. But for the sake of convenience you can add a couple of other methods, such as fetching the previous element, tracking the current position, and checking the end of the iteration.


Declare the collection interface and describe a method for fetching iterators. The return type should be equal to that of the iterator interface. You may declare similar methods if you plan to have several distinct groups of iterators.


Implement concrete iterator classes for the collections that you want to be traversable with iterators. An iterator object must be linked with a single collection instance. Usually, this link is established via the iterator’s constructor.


Implement the collection interface in your collection classes. The main idea is to provide the client with a shortcut for creating iterators, tailored for a particular collection class. The collection object must pass itself to the iterator’s constructor to establish a link between them.


Go over the client code to replace all of the collection traversal code with the use of iterators. The client fetches a new iterator object each time it needs to iterate over the collection elements.




 Single Responsibility Principle. You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes.

 Open/Closed Principle. You can implement new types of collections and iterators and pass them to existing code without breaking anything.

 You can iterate over the same collection in parallel because each iterator object contains its own iteration state.

 For the same reason, you can delay an iteration and continue it when needed.




 Applying the pattern can be an overkill if your app only works with simple collections.

 Using an iterator may be less efficient than going through elements of some specialized collections directly.



You can use Iterators to traverse Composite trees.


You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.


You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.


You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.

"
200,0,chain_of_responsibility,"

One of your colleagues suggested that it’s unsafe to pass raw data straight to the ordering system. So you added an extra validation step to sanitize the data in a request.


Later, somebody noticed that the system is vulnerable to brute force password cracking. To negate this, you promptly added a check that filters repeated failed requests coming from the same IP address.


Someone else suggested that you could speed up the system by returning cached results on repeated requests containing the same data. Hence, you added another check which lets the request pass through to the system only if there’s no suitable cached response.






The Handler declares the interface, common for all concrete handlers. It usually  contains just a single method for handling requests, but sometimes it may also have another method for setting the next handler on the chain.


The Base Handler is an optional class where you can put the boilerplate code that’s common to all handler classes.
Usually, this class defines a field for storing a reference to the next handler. The clients can build a chain by passing a handler to the constructor or setter of the previous handler. The class may also implement the default handling behavior: it can pass execution to the next handler after checking for its existence.


Concrete Handlers contain the actual code for processing requests. Upon receiving a request, each handler must decide whether to process it and, additionally, whether to pass it along the chain.
Handlers are usually self-contained and immutable, accepting all necessary data just once via the constructor.


The Client may compose chains just once or compose them dynamically, depending on the application’s logic. Note that a request can be sent to any handler in the chain—it doesn’t have to be the first one.




 Use the Chain of Responsibility pattern when your program is expected to process different kinds of requests in various ways, but the exact types of requests and their sequences are unknown beforehand.

 The pattern lets you link several handlers into one chain and, upon receiving a request, “ask” each handler whether it can process it. This way all handlers get a chance to process the request.


 Use the pattern when it’s essential to execute several handlers in a particular order.

 Since you can link the handlers in the chain in any order, all requests will get through the chain exactly as you planned.


 Use the CoR pattern when the set of handlers and their order are supposed to change at runtime.

 If you provide setters for a reference field inside the handler classes, you’ll be able to insert, remove or reorder handlers dynamically.



Declare the handler interface and describe the signature of a method for handling requests.
Decide how the client will pass the request data into the method. The most flexible way is to convert the request into an object and pass it to the handling method as an argument.


To eliminate duplicate boilerplate code in concrete handlers, it might be worth creating an abstract base handler class, derived from the handler interface.
This class should have a field for storing a reference to the next handler in the chain. Consider making the class immutable. However, if you plan to modify chains at runtime, you need to define a setter for altering the value of the reference field.
You can also implement the convenient default behavior for the handling method, which is to forward the request to the next object unless there’s none left. Concrete handlers will be able to use this behavior by calling the parent method.


One by one create concrete handler subclasses and implement their handling methods. Each handler should make two decisions when receiving a request:

Whether it’ll process the request.
Whether it’ll pass the request along the chain.



The client may either assemble chains on its own or receive pre-built chains from other objects. In the latter case, you must implement some factory classes to build chains according to the configuration or environment settings.


The client may trigger any handler in the chain, not just the first one. The request will be passed along the chain until some handler refuses to pass it further or until it reaches the end of the chain.


Due to the dynamic nature of the chain, the client should be ready to handle the following scenarios:

The chain may consist of a single link.
Some requests may not reach the end of the chain.
Others may reach the end of the chain unhandled.





 You can control the order of request handling.

 Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform operations.

 Open/Closed Principle. You can introduce new handlers into the app without breaking the existing client code.




 Some requests may end up unhandled.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.


Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.
However, there’s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.


Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.
The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.

"
201,0,mediator,"




Components are various classes that contain some business logic. Each component has a reference to a mediator, declared with the type of the mediator interface. The component isn’t aware of the actual class of the mediator, so you can reuse the component in other programs by linking it to a different mediator.


The Mediator interface declares methods of communication with components, which usually include just a single notification method. Components may pass any context as arguments of this method, including their own objects, but only in such a way that no coupling occurs between a receiving component and the sender’s class.


Concrete Mediators encapsulate relations between various components. Concrete mediators often keep references to all components they manage and sometimes even manage their lifecycle.


Components must not be aware of other components. If something important happens within or to a component, it must only notify the mediator. When the mediator receives the notification, it can easily identify the sender, which might be just enough to decide what component should be triggered in return.
From a component’s perspective, it all looks like a total black box. The sender doesn’t know who’ll end up handling its request, and the receiver doesn’t know who sent the request in the first place.




 Use the Mediator pattern when it’s hard to change some of the classes because they are tightly coupled to a bunch of other classes.

 The pattern lets you extract all the relationships between classes into a separate class, isolating any changes to a specific component from the rest of the components.


 Use the pattern when you can’t reuse a component in a different program because it’s too dependent on other components.

 After you apply the Mediator, individual components become unaware of the other components. They could still communicate with each other, albeit indirectly, through a mediator object. To reuse a component in a different app, you need to provide it with a new mediator class.


 Use the Mediator when you find yourself creating tons of component subclasses just to reuse some basic behavior in various contexts.

 Since all relations between components are contained within the mediator, it’s easy to define entirely new ways for these components to collaborate by introducing new mediator classes, without having to change the components themselves.



Identify a group of tightly coupled classes which would benefit from being more independent (e.g., for easier maintenance or simpler reuse of these classes).


Declare the mediator interface and describe the desired communication protocol between mediators and various components. In most cases, a single method for receiving notifications from components is sufficient.
This interface is crucial when you want to reuse component classes in different contexts. As long as the component works with its mediator via the generic interface, you can link the component with a different implementation of the mediator.


Implement the concrete mediator class. Consider storing references to all components inside the mediator. This way, you could call any component from the mediator’s methods.


You can go even further and make the mediator responsible for the creation and destruction of component objects. After this, the mediator may resemble a factory or a facade.


Components should store a reference to the mediator object. The connection is usually established in the component’s constructor, where a mediator object is passed as an argument.


Change the components’ code so that they call the mediator’s notification method instead of methods on other components. Extract the code that involves calling other components into the mediator class. Execute this code whenever the mediator receives notifications from that component.




 Single Responsibility Principle. You can extract the communications between various components into a single place, making it easier to comprehend and maintain.

 Open/Closed Principle. You can introduce new mediators without having to change the actual components.

 You can reduce coupling between various components of a program.

 You can reuse individual components more easily.




 Over time a mediator can evolve into a God Object.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.


Facade defines a simplified interface to a subsystem of objects, but it doesn’t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

Mediator centralizes communication between components of the system. The components only know about the mediator object and don’t communicate directly.



The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let’s see how we can do that.
The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.
There’s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator’s events. When Mediator is implemented this way, it may look very similar to Observer.
When you’re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won’t resemble Observer but will still be an instance of the Mediator pattern.
Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won’t be a centralized mediator object, only a distributed set of observers.

"
202,0,command,"




The Sender class (aka invoker) is responsible for initiating requests. This class must have a field for storing a reference to a command object. The sender triggers that command instead of sending the request directly to the receiver. Note that the sender isn’t responsible for creating the command object. Usually, it gets a pre-created command from the client via the constructor.


The Command interface usually declares just a single method for executing the command.


Concrete Commands implement various kinds of requests. A concrete command isn’t supposed to perform the work on its own, but rather to pass the call to one of the business logic objects. However, for the sake of simplifying the code, these classes can be merged.
Parameters required to execute a method on a receiving object can be declared as fields in the concrete command. You can make command objects immutable by only allowing the initialization of these fields via the constructor.


The Receiver class contains some business logic. Almost any object may act as a receiver. Most commands only handle the details of how a request is passed to the receiver, while the receiver itself does the actual work.


The Client creates and configures concrete command objects. The client must pass all of the request parameters, including a receiver instance, into the command’s constructor. After that, the resulting command may be associated with one or multiple senders.




 Use the Command pattern when you want to parametrize objects with operations.

 The Command pattern can turn a specific method call into a stand-alone object. This change opens up a lot of interesting uses: you can pass commands as method arguments, store them inside other objects, switch linked commands at runtime, etc.
Here’s an example: you’re developing a GUI component such as a context menu, and you want your users to be able to configure menu items that trigger operations when an end user clicks an item.


 Use the Command pattern when you want to queue operations, schedule their execution, or execute them remotely.

 As with any other object, a command can be serialized, which means converting it to a string that can be easily written to a file or a database. Later, the string can be restored as the initial command object. Thus, you can delay and schedule command execution. But there’s even more! In the same way, you can queue, log or send commands over the network.


 Use the Command pattern when you want to implement reversible operations.

 Although there are many ways to implement undo/redo, the Command pattern is perhaps the most popular of all.
To be able to revert operations, you need to implement the history of performed operations. The command history is a stack that contains all executed command objects along with related backups of the application’s state.
This method has two drawbacks. First, it isn’t that easy to save an application’s state because some of it can be private. This problem can be mitigated with the Memento pattern.
Second, the state backups may consume quite a lot of RAM. Therefore, sometimes you can resort to an alternative implementation: instead of restoring the past state, the command performs the inverse operation. The reverse operation also has a price: it may turn out to be hard or even impossible to implement.



Declare the command interface with a single execution method.


Start extracting requests into concrete command classes that implement the command interface. Each class must have a set of fields for storing the request arguments along with a reference to the actual receiver object. All these values must be initialized via the command’s constructor.


Identify classes that will act as senders. Add the fields for storing commands into these classes. Senders should communicate with their commands only via the command interface. Senders usually don’t create command objects on their own, but rather get them from the client code.


Change the senders so they execute the command instead of sending a request to the receiver directly.


The client should initialize objects in the following order:

Create receivers.
Create commands, and associate them with receivers if needed.
Create senders, and associate them with specific commands.





 Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform these operations.

 Open/Closed Principle. You can introduce new commands into the app without breaking existing client code.

 You can implement undo/redo.

 You can implement deferred execution of operations.

 You can assemble a set of simple commands into a complex one.




 The code may become more complicated since you’re introducing a whole new layer between senders and receivers.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.
However, there’s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.


You can use Command and Memento together when implementing “undo”. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.


Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.


You can use Command to convert any operation into an object. The operation’s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.


On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.




Prototype can help when you need to save copies of Commands into history.


You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.

"
203,0,memento,"
Implementation based on nested classes
The classic implementation of the pattern relies on support for nested classes, available in many popular programming languages (such as C++, C#, and Java).






The Originator class can produce snapshots of its own state, as well as restore its state from snapshots when needed.


The Memento is a value object that acts as a snapshot of the originator’s state. It’s a common practice to make the memento immutable and pass it the data only once, via the constructor.


The Caretaker knows not only “when” and “why” to capture the originator’s state, but also when the state should be restored.
A caretaker can keep track of the originator’s history by storing a stack of mementos. When the originator has to travel back in history, the caretaker fetches the topmost memento from the stack and passes it to the originator’s restoration method.


In this implementation, the memento class is nested inside the originator. This lets the originator access the fields and methods of the memento, even though they’re declared private. On the other hand, the caretaker has very limited access to the memento’s fields and methods, which lets it store mementos in a stack but not tamper with their state.

Implementation based on an intermediate interface
There’s an alternative implementation, suitable for programming languages that don’t support nested classes (yeah, PHP, I’m talking about you).






In the absence of nested classes, you can restrict access to the memento’s fields by establishing a convention that caretakers can work with a memento only through an explicitly declared intermediary interface, which would only declare methods related to the memento’s metadata.


On the other hand, originators can work with a memento object directly, accessing fields and methods declared in the memento class. The downside of this approach is that you need to declare all members of the memento public.

Implementation with even stricter encapsulation
There’s another implementation which is useful when you don’t want to leave even the slightest chance of other classes accessing the state of the originator through the memento.






This implementation allows having multiple types of originators and mementos. Each originator works with a corresponding memento class. Neither originators nor mementos expose their state to anyone.


Caretakers are now explicitly restricted from changing the state stored in mementos. Moreover, the caretaker class becomes independent from the originator because the restoration method is now defined in the memento class.


Each memento becomes linked to the originator that produced it. The originator passes itself to the memento’s constructor, along with the values of its state. Thanks to the close relationship between these classes, a memento can restore the state of its originator, given that the latter has defined the appropriate setters.




 Use the Memento pattern when you want to produce snapshots of the object’s state to be able to restore a previous state of the object.

 The Memento pattern lets you make full copies of an object’s state, including private fields, and store them separately from the object. While most people remember this pattern thanks to the “undo” use case, it’s also indispensable when dealing with transactions (i.e., if you need to roll back an operation on error).


 Use the pattern when direct access to the object’s fields/getters/setters violates its encapsulation.

 The Memento makes the object itself responsible for creating a snapshot of its state. No other object can read the snapshot, making the original object’s state data safe and secure.



Determine what class will play the role of the originator. It’s important to know whether the program uses one central object of this type or multiple smaller ones.


Create the memento class. One by one, declare a set of fields that mirror the fields declared inside the originator class.


Make the memento class immutable. A memento should accept the data just once, via the constructor. The class should have no setters.


If your programming language supports nested classes, nest the memento inside the originator. If not, extract a blank interface from the memento class and make all other objects use it to refer to the memento. You may add some metadata operations to the interface, but nothing that exposes the originator’s state.


Add a method for producing mementos to the originator class. The originator should pass its state to the memento via one or multiple arguments of the memento’s constructor.
The return type of the method should be of the interface you extracted in the previous step (assuming that you extracted it at all). Under the hood, the memento-producing method should work directly with the memento class.


Add a method for restoring the originator’s state to its class. It should accept a memento object as an argument. If you extracted an interface in the previous step, make it the type of the parameter. In this case, you need to typecast the incoming object to the memento class, since the originator needs full access to that object.


The caretaker, whether it represents a command object, a history, or something entirely different, should know when to request new mementos from the originator, how to store them and when to restore the originator with a particular memento.


The link between caretakers and originators may be moved into the memento class. In this case, each memento must be connected to the originator that had created it. The restoration method would also move to the memento class. However, this would all make sense only if the memento class is nested into originator or the originator class provides sufficient setters for overriding its state.




 You can produce snapshots of the object’s state without violating its encapsulation.

 You can simplify the originator’s code by letting the caretaker maintain the history of the originator’s state.




 The app might consume lots of RAM if clients create mementos too often.

 Caretakers should track the originator’s lifecycle to be able to destroy obsolete mementos.

 Most dynamic programming languages, such as PHP, Python and JavaScript, can’t guarantee that the state within the memento stays untouched.



You can use Command and Memento together when implementing “undo”. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.


You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.


Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.

"
204,0,observer,"




The Publisher issues events of interest to other objects. These events occur when the publisher changes its state or executes some behaviors. Publishers contain a subscription infrastructure that lets new subscribers join and current subscribers leave the list.


When a new event happens, the publisher goes over the subscription list and calls the notification method declared in the subscriber interface on each subscriber object.


The Subscriber interface declares the notification interface. In most cases, it consists of a single update method. The method may have several parameters that let the publisher pass some event details along with the update.


Concrete Subscribers perform some actions in response to notifications issued by the publisher. All of these classes must implement the same interface so the publisher isn’t coupled to concrete classes.


Usually, subscribers need some contextual information to handle the update correctly. For this reason, publishers often pass some context data as arguments of the notification method. The publisher can pass itself as an argument, letting subscriber fetch any required data directly.


The Client creates publisher and subscriber objects separately and then registers subscribers for publisher updates.




 Use the Observer pattern when changes to the state of one object may require changing other objects, and the actual set of objects is unknown beforehand or changes dynamically.

 You can often experience this problem when working with classes of the graphical user interface. For example, you created custom button classes, and you want to let the clients hook some custom code to your buttons so that it fires whenever a user presses a button.
The Observer pattern lets any object that implements the subscriber interface subscribe for event notifications in publisher objects. You can add the subscription mechanism to your buttons, letting the clients hook up their custom code via custom subscriber classes.


 Use the pattern when some objects in your app must observe others, but only for a limited time or in specific cases.

 The subscription list is dynamic, so subscribers can join or leave the list whenever they need to.



Look over your business logic and try to break it down into two parts: the core functionality, independent from other code, will act as the publisher; the rest will turn into a set of subscriber classes.


Declare the subscriber interface. At a bare minimum, it should declare a single update method.


Declare the publisher interface and describe a pair of methods for adding a subscriber object to and removing it from the list. Remember that publishers must work with subscribers only via the subscriber interface.


Decide where to put the actual subscription list and the implementation of subscription methods. Usually, this code looks the same for all types of publishers, so the obvious place to put it is in an abstract class derived directly from the publisher interface. Concrete publishers extend that class, inheriting the subscription behavior.
However, if you’re applying the pattern to an existing class hierarchy, consider an approach based on composition: put the subscription logic into a separate object, and make all real publishers use it.


Create concrete publisher classes. Each time something important happens inside a publisher, it must notify all its subscribers.


Implement the update notification methods in concrete subscriber classes. Most subscribers would need some context data about the event. It can be passed as an argument of the notification method.
But there’s another option. Upon receiving a notification, the subscriber can fetch any data directly from the notification. In this case, the publisher must pass itself via the update method. The less flexible option is to link a publisher to the subscriber permanently via the constructor.


The client must create all necessary subscribers and register them with proper publishers.




 Open/Closed Principle. You can introduce new subscriber classes without having to change the publisher’s code (and vice versa if there’s a publisher interface).

 You can establish relations between objects at runtime.




 Subscribers are notified in random order.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let’s see how we can do that.
The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.
There’s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator’s events. When Mediator is implemented this way, it may look very similar to Observer.
When you’re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won’t resemble Observer but will still be an instance of the Mediator pattern.
Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won’t be a centralized mediator object, only a distributed set of observers.

"
205,0,composite,"




The Component interface describes operations that are common to both simple and complex elements of the tree.


The Leaf is a basic element of a tree that doesn’t have sub-elements.
Usually, leaf components end up doing most of the real work, since they don’t have anyone to delegate the work to.


The Container (aka composite) is an element that has sub-elements: leaves or other containers. A container doesn’t know the concrete classes of its children. It works with all sub-elements only via the component interface.
Upon receiving a request, a container delegates the work to its sub-elements, processes intermediate results and then returns the final result to the client.


The Client works with all elements through the component interface. As a result, the client can work in the same way with both simple or complex elements of the tree.




 Use the Composite pattern when you have to implement a tree-like object structure.

 The Composite pattern provides you with two basic element types that share a common interface: simple leaves and complex containers. A container can be composed of both leaves and other containers. This lets you construct a nested recursive object structure that resembles a tree.


 Use the pattern when you want the client code to treat both simple and complex elements uniformly.

 All elements defined by the Composite pattern share a common interface. Using this interface, the client doesn’t have to worry about the concrete class of the objects it works with.



Make sure that the core model of your app can be represented as a tree structure. Try to break it down into simple elements and containers. Remember that containers must be able to contain both simple elements and other containers.


Declare the component interface with a list of methods that make sense for both simple and complex components.


Create a leaf class to represent simple elements. A program may have multiple different leaf classes.


Create a container class to represent complex elements. In this class, provide an array field for storing references to sub-elements. The array must be able to store both leaves and containers, so make sure it’s declared with the component interface type.
While implementing the methods of the component interface, remember that a container is supposed to be delegating most of the work to sub-elements.


Finally, define the methods for adding and removal of child elements in the container.
Keep in mind that these operations can be declared in the component interface. This would violate the Interface Segregation Principle because the methods will be empty in the leaf class. However, the client will be able to treat all the elements equally, even when composing the tree.




 You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage.

 Open/Closed Principle. You can introduce new element types into the app without breaking the existing code, which now works with the object tree.




 It might be difficult to provide a common interface for classes whose functionality differs too much. In certain scenarios, you’d need to overgeneralize the component interface, making it harder to comprehend.



You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.


Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.


You can use Iterators to traverse Composite trees.


You can use Visitor to execute an operation over an entire Composite tree.


You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.
A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.
However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.

"
206,0,strategy,"




The Context maintains a reference to one of the concrete strategies and communicates with this object only via the strategy interface.


The Strategy interface is common to all concrete strategies. It declares a method the context uses to execute a strategy.


Concrete Strategies implement different variations of an algorithm the context uses.


The context calls the execution method on the linked strategy object each time it needs to run the algorithm. The context doesn’t know what type of strategy it works with or how the algorithm is executed.


The Client creates a specific strategy object and passes it to the context. The context exposes a setter which lets clients replace the strategy associated with the context at runtime.




 Use the Strategy pattern when you want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime.

 The Strategy pattern lets you indirectly alter the object’s behavior at runtime by associating it with different sub-objects which can perform specific sub-tasks in different ways.


 Use the Strategy when you have a lot of similar classes that only differ in the way they execute some behavior.

 The Strategy pattern lets you extract the varying behavior into a separate class hierarchy and combine the original classes into one, thereby reducing duplicate code.


 Use the pattern to isolate the business logic of a class from the implementation details of algorithms that may not be as important in the context of that logic.

 The Strategy pattern lets you isolate the code, internal data, and dependencies of various algorithms from the rest of the code. Various clients get a simple interface to execute the algorithms and switch them at runtime.


 Use the pattern when your class has a massive conditional statement that switches between different variants of the same algorithm.

 The Strategy pattern lets you do away with such a conditional by extracting all algorithms into separate classes, all of which implement the same interface. The original object delegates execution to one of these objects, instead of implementing all variants of the algorithm.



In the context class, identify an algorithm that’s prone to frequent changes. It may also be a massive conditional that selects and executes a variant of the same algorithm at runtime.


Declare the strategy interface common to all variants of the algorithm.


One by one, extract all algorithms into their own classes. They should all implement the strategy interface.


In the context class, add a field for storing a reference to a strategy object. Provide a setter for replacing values of that field. The context should work with the strategy object only via the strategy interface. The context may define an interface which lets the strategy access its data.


Clients of the context must associate it with a suitable strategy that matches the way they expect the context to perform its primary job.




 You can swap algorithms used inside an object at runtime.

 You can isolate the implementation details of an algorithm from the code that uses it.

 You can replace inheritance with composition.

 Open/Closed Principle. You can introduce new strategies without having to change the context.




 If you only have a couple of algorithms and they rarely change, there’s no real reason to overcomplicate the program with new classes and interfaces that come along with the pattern.

 Clients must be aware of the differences between strategies to be able to select a proper one.

 A lot of modern programming languages have functional type support that lets you implement different versions of an algorithm inside a set of anonymous functions. Then you could use these functions exactly as you’d have used the strategy objects, but without bloating your code with extra classes and interfaces.



Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.


You can use Command to convert any operation into an object. The operation’s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.


On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.




Decorator lets you change the skin of an object, while Strategy lets you change the guts.


Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object’s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it’s static. Strategy works on the object level, letting you switch behaviors at runtime.


State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn’t restrict dependencies between concrete states, letting them alter the state of the context at will.

"
207,0,template_method,"

abstract steps must be implemented by every subclass

optional steps already have some default implementation, but still can be overridden if needed





The Abstract Class declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order. The steps may either be declared abstract or have some default implementation.


Concrete Classes can override all of the steps, but not the template method itself.




 Use the Template Method pattern when you want to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure.

 The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass.


 Use the pattern when you have several classes that contain almost identical algorithms with some minor differences. As a result, you might need to modify all classes when the algorithm changes.

 When you turn such an algorithm into a template method, you can also pull up the steps with similar implementations into a superclass, eliminating code duplication. Code that varies between subclasses can remain in subclasses.



Analyze the target algorithm to see whether you can break it into steps. Consider which steps are common to all subclasses and which ones will always be unique.


Create the abstract base class and declare the template method and a set of abstract methods representing the algorithm’s steps. Outline the algorithm’s structure in the template method by executing corresponding steps. Consider making the template method final to prevent subclasses from overriding it.


It’s okay if all the steps end up being abstract. However, some steps might benefit from having a default implementation. Subclasses don’t have to implement those methods.


Think of adding hooks between the crucial steps of the algorithm.


For each variation of the algorithm, create a new concrete subclass. It must implement all of the abstract steps, but may also override some of the optional ones.




 You can let clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm.

 You can pull the duplicate code into a superclass.




 Some clients may be limited by the provided skeleton of an algorithm.

 You might violate the Liskov Substitution Principle by suppressing a default step implementation via a subclass.

 Template methods tend to be harder to maintain the more steps they have.



Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.


Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object’s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it’s static. Strategy works on the object level, letting you switch behaviors at runtime.

"
208,0,visitor,"
If it’s a residential building, he sells medical insurance.
If it’s a bank, he sells theft insurance.
If it’s a coffee shop, he sells fire and flood insurance.





The Visitor interface declares a set of visiting methods that can take concrete elements of an object structure as arguments. These methods may have the same names if the program is written in a language that supports overloading, but the type of their parameters must be different.


Each Concrete Visitor implements several versions of the same behaviors, tailored for different concrete element classes.


The Element interface declares a method for “accepting” visitors. This method should have one parameter declared with the type of the visitor interface.


Each Concrete Element must implement the acceptance method. The purpose of this method is to redirect the call to the proper visitor’s method corresponding to the current element class. Be aware that even if a base element class implements this method, all subclasses must still override this method in their own classes and call the appropriate method on the visitor object.


The Client usually represents a collection or some other complex object (for example, a Composite tree). Usually, clients aren’t aware of all the concrete element classes because they work with objects from that collection via some abstract interface.




 Use the Visitor when you need to perform an operation on all elements of a complex object structure (for example, an object tree).

 The Visitor pattern lets you execute an operation over a set of objects with different classes by having a visitor object implement several variants of the same operation, which correspond to all target classes.


 Use the Visitor to clean up the business logic of auxiliary behaviors.

 The pattern lets you make the primary classes of your app more focused on their main jobs by extracting all other behaviors into a set of visitor classes.


 Use the pattern when a behavior makes sense only in some classes of a class hierarchy, but not in others.

 You can extract this behavior into a separate visitor class and implement only those visiting methods that accept objects of relevant classes, leaving the rest empty.



Declare the visitor interface with a set of “visiting” methods, one per each concrete element class that exists in the program.


Declare the element interface. If you’re working with an existing element class hierarchy, add the abstract “acceptance” method to the base class of the hierarchy. This method should accept a visitor object as an argument.


Implement the acceptance methods in all concrete element classes. These methods must simply redirect the call to a visiting method on the incoming visitor object which matches the class of the current element.


The element classes should only work with visitors via the visitor interface. Visitors, however, must be aware of all concrete element classes, referenced as parameter types of the visiting methods.


For each behavior that can’t be implemented inside the element hierarchy, create a new concrete visitor class and implement all of the visiting methods.
You might encounter a situation where the visitor will need access to some private members of the element class. In this case, you can either make these fields or methods public, violating the element’s encapsulation, or nest the visitor class in the element class. The latter is only possible if you’re lucky to work with a programming language that supports nested classes.


The client must create visitor objects and pass them into elements via “acceptance” methods.




 Open/Closed Principle. You can introduce a new behavior that can work with objects of different classes without changing these classes.

 Single Responsibility Principle. You can move multiple versions of the same behavior into the same class.

 A visitor object can accumulate some useful information while working with various objects. This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure.




 You need to update all visitors each time a class gets added to or removed from the element hierarchy.

 Visitors might lack the necessary access to the private fields and methods of the elements that they’re supposed to work with.



You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.


You can use Visitor to execute an operation over an entire Composite tree.


You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.


Puzzled why we can’t simply replace the Visitor pattern with method overloading? Read my article Visitor and Double Dispatch to learn about the nasty details.
"
209,0,state,"
In Draft, it moves the document to moderation.
In Moderation, it makes the document public, but only if the current user is an administrator.
In Published, it doesn’t do anything at all.

When the phone is unlocked, pressing buttons leads to executing various functions.
When the phone is locked, pressing any button leads to the unlock screen.
When the phone’s charge is low, pressing any button shows the charging screen.





Context stores a reference to one of the concrete state objects and delegates to it all state-specific work. The context communicates with the state object via the state interface. The context exposes a setter for passing it a new state object.


The State interface declares the state-specific methods. These methods should make sense for all concrete states because you don’t want some of your states to have useless methods that will never be called.


Concrete States provide their own implementations for the state-specific methods. To avoid duplication of similar code across multiple states, you may provide intermediate abstract classes that encapsulate some common behavior.
State objects may store a backreference to the context object. Through this reference, the state can fetch any required info from the context object, as well as initiate state transitions.


Both context and concrete states can set the next state of the context and perform the actual state transition by replacing the state object linked to the context.




 Use the State pattern when you have an object that behaves differently depending on its current state, the number of states is enormous, and the state-specific code changes frequently.

 The pattern suggests that you extract all state-specific code into a set of distinct classes. As a result, you can add new states or change existing ones independently of each other, reducing the maintenance cost.


 Use the pattern when you have a class polluted with massive conditionals that alter how the class behaves according to the current values of the class’s fields.

 The State pattern lets you extract branches of these conditionals into methods of corresponding state classes. While doing so, you can also clean temporary fields and helper methods involved in state-specific code out of your main class.


 Use State when you have a lot of duplicate code across similar states and transitions of a condition-based state machine.

 The State pattern lets you compose hierarchies of state classes and reduce duplication by extracting common code into abstract base classes.



Decide what class will act as the context. It could be an existing class which already has the state-dependent code; or a new class, if the state-specific code is distributed across multiple classes.


Declare the state interface. Although it may mirror all the methods declared in the context, aim only for those that may contain state-specific behavior.


For every actual state, create a class that derives from the state interface. Then go over the methods of the context and extract all code related to that state into your newly created class.
While moving the code to the state class, you might discover that it depends on private members of the context. There are several workarounds:

Make these fields or methods public.
Turn the behavior you’re extracting into a public method in the context and call it from the state class. This way is ugly but quick, and you can always fix it later.
Nest the state classes into the context class, but only if your programming language supports nesting classes.



In the context class, add a reference field of the state interface type and a public setter that allows overriding the value of that field.


Go over the method of the context again and replace empty state conditionals with calls to corresponding methods of the state object.


To switch the state of the context, create an instance of one of the state classes and pass it to the context. You can do this within the context itself, or in various states, or in the client. Wherever this is done, the class becomes dependent on the concrete state class that it instantiates.




 Single Responsibility Principle. Organize the code related to particular states into separate classes.

 Open/Closed Principle. Introduce new states without changing existing state classes or the context.

 Simplify the code of the context by eliminating bulky state machine conditionals.




 Applying the pattern can be overkill if a state machine has only a few states or rarely changes.



Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn’t restrict dependencies between concrete states, letting them alter the state of the context at will.

"
210,0,factory_method,"




The Product declares the interface, which is common to all objects that can be produced by the creator and its subclasses.


Concrete Products are different implementations of the product interface.


The Creator class declares the factory method that returns new product objects. It’s important that the return type of this method matches the product interface.
You can declare the factory method as abstract to force all subclasses to implement their own versions of the method. As an alternative, the base factory method can return some default product type.
Note, despite its name, product creation is not the primary responsibility of the creator. Usually, the creator class already has some core business logic related to products. The factory method helps to decouple this logic from the concrete product classes. Here is an analogy: a large software development company can have a training department for programmers. However, the primary function of the company as a whole is still writing code, not producing programmers.


Concrete Creators override the base factory method so it returns a different type of product.
Note that the factory method doesn’t have to create new instances all the time. It can also return existing objects from a cache, an object pool, or another source.




 Use the Factory Method when you don’t know beforehand the exact types and dependencies of the objects your code should work with.

 The Factory Method separates product construction code from the code that actually uses the product. Therefore it’s easier to extend the product construction code independently from the rest of the code.
For example, to add a new product type to the app, you’ll only need to create a new creator subclass and override the factory method in it.


 Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.

 Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component?
The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself.
Let’s see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard Button class with a glorious RoundButton subclass. But now you need to tell the main UIFramework class to use the new button subclass instead of a default one.
To achieve this, you create a subclass UIWithRoundButtons from a base framework class and override its createButton method. While this method returns Button objects in the base class, you make your subclass return RoundButton objects. Now use the UIWithRoundButtons class instead of UIFramework. And that’s about it!


 Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time.

 You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources.
Let’s think about what has to be done to reuse an existing object:

First, you need to create some storage to keep track of all of the created objects.
When someone requests an object, the program should look for a free object inside that pool.
… and then return it to the client code.
If there are no free objects, the program should create a new one (and add it to the pool).

That’s a lot of code! And it must all be put into a single place so that you don’t pollute the program with duplicate code.
Probably the most obvious and convenient place where this code could be placed is the constructor of the class whose objects we’re trying to reuse. However, a constructor must always return new objects by definition. It can’t return existing instances.
Therefore, you need to have a regular method capable of creating new objects as well as reusing existing ones. That sounds very much like a factory method.



Make all products follow the same interface. This interface should declare methods that make sense in every product.


Add an empty factory method inside the creator class. The return type of the method should match the common product interface.


In the creator’s code find all references to product constructors. One by one, replace them with calls to the factory method, while extracting the product creation code into the factory method.
You might need to add a temporary parameter to the factory method to control the type of returned product.
At this point, the code of the factory method may look pretty ugly. It may have a large switch statement that picks which product class to instantiate. But don’t worry, we’ll fix it soon enough.


Now, create a set of creator subclasses for each type of product listed in the factory method. Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.


If there are too many product types and it doesn’t make sense to create subclasses for all of them, you can reuse the control parameter from the base class in subclasses.
For instance, imagine that you have the following hierarchy of classes: the base Mail class with a couple of subclasses: AirMail and GroundMail; the Transport classes are Plane, Truck and Train. While the AirMail class only uses Plane objects, GroundMail may work with both Truck and Train objects. You can create a new subclass (say TrainMail) to handle both cases, but there’s another option. The client code can pass an argument to the factory method of the GroundMail class to control which product it wants to receive.


If, after all of the extractions, the base factory method has become empty, you can make it abstract. If there’s something left, you can make it a default behavior of the method.




 You avoid tight coupling between the creator and the concrete products.

 Single Responsibility Principle. You can move the product creation code into one place in the program, making the code easier to support.

 Open/Closed Principle. You can introduce new types of products into the program without breaking existing client code.




 The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern. The best case scenario is when you’re introducing the pattern into an existing hierarchy of creator classes.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.


Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.


Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.


Read our Factory Comparison if you can’t figure out the difference between various factory patterns and concepts.
"
211,0,prototype,"
Basic implementation






The Prototype interface declares the cloning methods. In most cases, it’s a single clone method.


The Concrete Prototype class implements the cloning method. In addition to copying the original object’s data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies, etc.


The Client can produce a copy of any object that follows the prototype interface.

Prototype registry implementation






The Prototype Registry provides an easy way to access frequently-used prototypes. It stores a set of pre-built objects that are ready to be copied. The simplest prototype registry is a name → prototype hash map. However, if you need better search criteria than a simple name, you can build a much more robust version of the registry.




 Use the Prototype pattern when your code shouldn’t depend on the concrete classes of objects that you need to copy.

 This happens a lot when your code works with objects passed to you from 3rd-party code via some interface. The concrete classes of these objects are unknown, and you couldn’t depend on them even if you wanted to.
The Prototype pattern provides the client code with a general interface for working with all objects that support cloning. This interface makes the client code independent from the concrete classes of objects that it clones.


 Use the pattern when you want to reduce the number of subclasses that only differ in the way they initialize their respective objects.

 Suppose you have a complex class that requires a laborious configuration before it can be used. There are several common ways to configure this class, and this code is scattered through your app. To reduce the duplication, you create several subclasses and put every common configuration code into their constructors. You solved the duplication problem, but now you have lots of dummy subclasses.
The Prototype pattern lets you use a set of pre-built objects configured in various ways as prototypes. Instead of instantiating a subclass that matches some configuration, the client can simply look for an appropriate prototype and clone it.



Create the prototype interface and declare the clone method in it. Or just add the method to all classes of an existing class hierarchy, if you have one.


A prototype class must define the alternative constructor that accepts an object of that class as an argument. The constructor must copy the values of all fields defined in the class from the passed object into the newly created instance. If you’re changing a subclass, you must call the parent constructor to let the superclass handle the cloning of its private fields.
If your programming language doesn’t support method overloading, you won’t be able to create a separate “prototype” constructor. Thus, copying the object’s data into the newly created clone will have to be performed within the clone method. Still, having this code in a regular constructor is safer because the resulting object is returned fully configured right after you call the new operator.


The cloning method usually consists of just one line: running a new operator with the prototypical version of the constructor. Note, that every class must explicitly override the cloning method and use its own class name along with the new operator. Otherwise, the cloning method may produce an object of a parent class.


Optionally, create a centralized prototype registry to store a catalog of frequently used prototypes.
You can implement the registry as a new factory class or put it in the base prototype class with a static method for fetching the prototype. This method should search for a prototype based on search criteria that the client code passes to the method. The criteria might either be a simple string tag or a complex set of search parameters. After the appropriate prototype is found, the registry should clone it and return the copy to the client.
Finally, replace the direct calls to the subclasses’ constructors with calls to the factory method of the prototype registry.




 You can clone objects without coupling to their concrete classes.

 You can get rid of repeated initialization code in favor of cloning pre-built prototypes.

 You can produce complex objects more conveniently.

 You get an alternative to inheritance when dealing with configuration presets for complex objects.




 Cloning complex objects that have circular references might be very tricky.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


Prototype can help when you need to save copies of Commands into history.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.


Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.


Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
212,0,adapter,"
The adapter gets an interface, compatible with one of the existing objects.
Using this interface, the existing object can safely call the adapter’s methods.
Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects.

Object adapter
This implementation uses the object composition principle: the adapter implements the interface of one object and wraps the other one. It can be implemented in all popular programming languages.






The Client is a class that contains the existing business logic of the program.


The Client Interface describes a protocol that other classes must follow to be able to collaborate with the client code.


The Service is some useful class (usually 3rd-party or legacy). The client can’t use this class directly because it has an incompatible interface.


The Adapter is a class that’s able to work with both the client and the service: it implements the client interface, while wrapping the service object. The adapter receives calls from the client via the adapter interface and translates them into calls to the wrapped service object in a format it can understand.


The client code doesn’t get coupled to the concrete adapter class as long as it works with the adapter via the client interface. Thanks to this, you can introduce new types of adapters into the program without breaking the existing client code. This can be useful when the interface of the service class gets changed or replaced: you can just create a new adapter class without changing the client code.

Class adapter
This implementation uses inheritance: the adapter inherits interfaces from both objects at the same time. Note that this approach can only be implemented in programming languages that support multiple inheritance, such as C++.






The Class Adapter doesn’t need to wrap any objects because it inherits behaviors from both the client and the service. The adaptation happens within the overridden methods. The resulting adapter can be used in place of an existing client class.




 Use the Adapter class when you want to use some existing class, but its interface isn’t compatible with the rest of your code.

 The Adapter pattern lets you create a middle-layer class that serves as a translator between your code and a legacy class, a 3rd-party class or any other class with a weird interface.


 Use the pattern when you want to reuse several existing subclasses that lack some common functionality that can’t be added to the superclass.

 You could extend each subclass and put the missing functionality into new child classes. However, you’ll need to duplicate the code across all of these new classes, which smells really bad.
The much more elegant solution would be to put the missing functionality into an adapter class. Then you would wrap objects with missing features inside the adapter, gaining needed features dynamically. For this to work, the target classes must have a common interface, and the adapter’s field should follow that interface. This approach looks very similar to the Decorator pattern.



Make sure that you have at least two classes with incompatible interfaces:

A useful service class, which you can’t change (often 3rd-party, legacy or with lots of existing dependencies).
One or several client classes that would benefit from using the service class.



Declare the client interface and describe how clients communicate with the service.


Create the adapter class and make it follow the client interface. Leave all the methods empty for now.


Add a field to the adapter class to store a reference to the service object. The common practice is to initialize this field via the constructor, but sometimes it’s more convenient to pass it to the adapter when calling its methods.


One by one, implement all methods of the client interface in the adapter class. The adapter should delegate most of the real work to the service object, handling only the interface or data format conversion.


Clients should use the adapter via the client interface. This will let you change or extend the adapters without affecting the client code.




 Single Responsibility Principle. You can separate the interface or data conversion code from the primary business logic of the program.

 Open/Closed Principle. You can introduce new types of adapters into the program without breaking the existing client code, as long as they work with the adapters through the client interface.




 The overall complexity of the code increases because you need to introduce a set of new interfaces and classes. Sometimes it’s simpler just to change the service class so that it matches the rest of your code.



Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.


Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.


Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.


Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.

"
213,0,decorator,"
Inheritance is static. You can’t alter the behavior of an existing object at runtime. You can only replace the whole object with another one that’s created from a different subclass.
Subclasses can have just one parent class. In most languages, inheritance doesn’t let a class inherit behaviors of multiple classes at the same time.





The Component declares the common interface for both wrappers and wrapped objects.


Concrete Component is a class of objects being wrapped. It defines the basic behavior, which can be altered by decorators.


The Base Decorator class has a field for referencing a wrapped object. The field’s type should be declared as the component interface so it can contain both concrete components and decorators. The base decorator delegates all operations to the wrapped object.


Concrete Decorators define extra behaviors that can be added to components dynamically. Concrete decorators override methods of the base decorator and execute their behavior either before or after calling the parent method.


The Client can wrap components in multiple layers of decorators, as long as it works with all objects via the component interface.




Just before the data is written to disk, the decorators encrypt and compress it. The original class writes the encrypted and protected data to the file without knowing about the change.


Right after the data is read from disk, it goes through the same decorators, which decompress and decode it.



 Use the Decorator pattern when you need to be able to assign extra behaviors to objects at runtime without breaking the code that uses these objects.

 The Decorator lets you structure your business logic into layers, create a decorator for each layer and compose objects with various combinations of this logic at runtime. The client code can treat all these objects in the same way, since they all follow a common interface.


 Use the pattern when it’s awkward or not possible to extend an object’s behavior using inheritance.

 Many programming languages have the final keyword that can be used to prevent further extension of a class. For a final class, the only way to reuse the existing behavior would be to wrap the class with your own wrapper, using the Decorator pattern.



Make sure your business domain can be represented as a primary component with multiple optional layers over it.


Figure out what methods are common to both the primary component and the optional layers. Create a component interface and declare those methods there.


Create a concrete component class and define the base behavior in it.


Create a base decorator class. It should have a field for storing a reference to a wrapped object. The field should be declared with the component interface type to allow linking to concrete components as well as decorators. The base decorator must delegate all work to the wrapped object.


Make sure all classes implement the component interface.


Create concrete decorators by extending them from the base decorator. A concrete decorator must execute its behavior before or after the call to the parent method (which always delegates to the wrapped object).


The client code must be responsible for creating decorators and composing them in the way the client needs.




 You can extend an object’s behavior without making a new subclass.

 You can add or remove responsibilities from an object at runtime.

 You can combine several behaviors by wrapping an object into multiple decorators.

 Single Responsibility Principle. You can divide a monolithic class that implements many possible variants of behavior into several smaller classes.




 It’s hard to remove a specific wrapper from the wrappers stack.

 It’s hard to implement a decorator in such a way that its behavior doesn’t depend on the order in the decorators stack.

 The initial configuration code of layers might look pretty ugly.



Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.


Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.
The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.


Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.
A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.
However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.


Decorator lets you change the skin of an object, while Strategy lets you change the guts.


Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.

"
214,0,singleton,"

Ensure that a class has just a single instance. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource—for example, a database or a file.
Here’s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you’ll get the one you already created.
Note that this behavior is impossible to implement with a regular constructor since a constructor call must always return a new object by design.


Make the default constructor private, to prevent other objects from using the new operator with the Singleton class.
Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.





The Singleton class declares the static method getInstance that returns the same instance of its own class.
The Singleton’s constructor should be hidden from the client code. Calling the getInstance method should be the only way of getting the Singleton object.




 Use the Singleton pattern when a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program.

 The Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created.


 Use the Singleton pattern when you need stricter control over global variables.

 Unlike global variables, the Singleton pattern guarantees that there’s just one instance of a class. Nothing, except for the Singleton class itself, can replace the cached instance.
Note that you can always adjust this limitation and allow creating any number of Singleton instances. The only piece of code that needs changing is the body of the getInstance method.



Add a private static field to the class for storing the singleton instance.


Declare a public static creation method for getting the singleton instance.


Implement “lazy initialization” inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.


Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.


Go over the client code and replace all direct calls to the singleton’s constructor with calls to its static creation method.




 You can be sure that a class has only a single instance.

 You gain a global access point to that instance.

 The singleton object is initialized only when it’s requested for the first time.




 Violates the Single Responsibility Principle. The pattern solves two problems at the time.

 The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other.

 The pattern requires special treatment in a multithreaded environment so that multiple threads won’t create a singleton object several times.

 It may be difficult to unit test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don’t write the tests. Or don’t use the Singleton pattern.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.



Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
215,0,bridge,"Abstraction and Implementation
Have several different GUIs (for instance, tailored for regular customers or admins).
Support several different APIs (for example, to be able to launch the app under Windows, Linux, and macOS).

Abstraction: the GUI layer of the app.
Implementation: the operating systems’ APIs.





The Abstraction provides high-level control logic. It relies on the implementation object to do the actual low-level work.


The Implementation declares the interface that’s common for all concrete implementations. An abstraction can only communicate with an implementation object via methods that are declared here.
The abstraction may list the same methods as the implementation, but usually the abstraction declares some complex behaviors that rely on a wide variety of primitive operations declared by the implementation.


Concrete Implementations contain platform-specific code.


Refined Abstractions provide variants of control logic. Like their parent, they work with different implementations via the general implementation interface.


Usually, the Client is only interested in working with the abstraction. However, it’s the client’s job to link the abstraction object with one of the implementation objects.




 Use the Bridge pattern when you want to divide and organize a monolithic class that has several variants of some functionality (for example, if the class can work with various database servers).

 The bigger a class becomes, the harder it is to figure out how it works, and the longer it takes to make a change. The changes made to one of the variations of functionality may require making changes across the whole class, which often results in making errors or not addressing some critical side effects.
The Bridge pattern lets you split the monolithic class into several class hierarchies. After this, you can change the classes in each hierarchy independently of the classes in the others. This approach simplifies code maintenance and minimizes the risk of breaking existing code.


 Use the pattern when you need to extend a class in several orthogonal (independent) dimensions.

 The Bridge suggests that you extract a separate class hierarchy for each of the dimensions. The original class delegates the related work to the objects belonging to those hierarchies instead of doing everything on its own.


 Use the Bridge if you need to be able to switch implementations at runtime.

 Although it’s optional, the Bridge pattern lets you replace the implementation object inside the abstraction. It’s as easy as assigning a new value to a field.
By the way, this last item is the main reason why so many people confuse the Bridge with the Strategy pattern. Remember that a pattern is more than just a certain way to structure your classes. It may also communicate intent and a problem being addressed.



Identify the orthogonal dimensions in your classes. These independent concepts could be: abstraction/platform, domain/infrastructure, front-end/back-end, or interface/implementation.


See what operations the client needs and define them in the base abstraction class.


Determine the operations available on all platforms. Declare the ones that the abstraction needs in the general implementation interface.


For all platforms in your domain create concrete implementation classes, but make sure they all follow the implementation interface.


Inside the abstraction class, add a reference field for the implementation type. The abstraction delegates most of the work to the implementation object that’s referenced in that field.


If you have several variants of high-level logic, create refined abstractions for each variant by extending the base abstraction class.


The client code should pass an implementation object to the abstraction’s constructor to associate one with the other. After that, the client can forget about the implementation and work only with the abstraction object.




 You can create platform-independent classes and apps.

 The client code works with high-level abstractions. It isn’t exposed to the platform details.

 Open/Closed Principle. You can introduce new abstractions and implementations independently from each other.

 Single Responsibility Principle. You can focus on high-level logic in the abstraction and on platform details in the implementation.




 You might make the code more complicated by applying the pattern to a highly cohesive class.



Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.


Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.


You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.

"
216,0,abstract_factory,"

A family of related products, say: Chair + Sofa + CoffeeTable.


Several variants of this family. For example, products Chair + Sofa + CoffeeTable are available in these variants: Modern, Victorian, ArtDeco.






Abstract Products declare interfaces for a set of distinct but related products which make up a product family.


Concrete Products are various implementations of abstract products, grouped by variants. Each abstract product (chair/sofa) must be implemented in all given variants (Victorian/Modern).


The Abstract Factory interface declares a set of methods for creating each of the abstract products.


Concrete Factories implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.


Although concrete factories instantiate concrete products, signatures of their creation methods must return corresponding abstract products. This way the client code that uses a factory doesn’t get coupled to the specific variant of the product it gets from a factory. The Client can work with any concrete factory/product variant, as long as it communicates with their objects via abstract interfaces.




 Use the Abstract Factory when your code needs to work with various families of related products, but you don’t want it to depend on the concrete classes of those products—they might be unknown beforehand or you simply want to allow for future extensibility.

 The Abstract Factory provides you with an interface for creating objects from each class of the product family. As long as your code creates objects via this interface, you don’t have to worry about creating the wrong variant of a product which doesn’t match the products already created by your app.


 Consider implementing the Abstract Factory when you have a class with a set of Factory Methods that blur its primary responsibility.

 In a well-designed program each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.



Map out a matrix of distinct product types versus variants of these products.


Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.


Declare the abstract factory interface with a set of creation methods for all abstract products.


Implement a set of concrete factory classes, one for each product variant.


Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.


Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.




 You can be sure that the products you’re getting from a factory are compatible with each other.

 You avoid tight coupling between concrete products and client code.

 Single Responsibility Principle. You can extract the product creation code into one place, making the code easier to support.

 Open/Closed Principle. You can introduce new variants of products without breaking existing client code.




 The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.


Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.


Read our Factory Comparison to learn more about the differences between various factory patterns and concepts.
"
217,0,builder,"Director




The Builder interface declares product construction steps that are common to all types of builders.


Concrete Builders provide different implementations of the construction steps. Concrete builders may produce products that don’t follow the common interface.


Products are resulting objects. Products constructed by different builders don’t have to belong to the same class hierarchy or interface.


The Director class defines the order in which to call construction steps, so you can create and reuse specific configurations of products.


The Client must associate one of the builder objects with the director. Usually, it’s done just once, via parameters of the director’s constructor. Then the director uses that builder object for all further construction. However, there’s an alternative approach for when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.




 Use the Builder pattern to get rid of a “telescoping constructor”.

 Say you have a constructor with ten optional parameters. Calling such a beast is very inconvenient; therefore, you overload the constructor and create several shorter versions with fewer parameters. These constructors still refer to the main one, passing some default values into any omitted parameters.

class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...


Creating such a monster is only possible in languages that support method overloading, such as C# or Java.


The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don’t have to cram dozens of parameters into your constructors anymore.


 Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).

 The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details.
The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction.


 Use the Builder to construct Composite trees or other complex objects.

 The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree.
A builder doesn’t expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result.



Make sure that you can clearly define the common construction steps for building all available product representations. Otherwise, you won’t be able to proceed with implementing the pattern.


Declare these steps in the base builder interface.


Create a concrete builder class for each of the product representations and implement their construction steps.
Don’t forget about implementing a method for fetching the result of the construction. The reason why this method can’t be declared inside the builder interface is that various builders may construct products that don’t have a common interface. Therefore, you don’t know what would be the return type for such a method. However, if you’re dealing with products from a single hierarchy, the fetching method can be safely added to the base interface.


Think about creating a director class. It may encapsulate various ways to construct a product using the same builder object.


The client code creates both the builder and the director objects. Before construction starts, the client must pass a builder object to the director. Usually, the client does this only once, via parameters of the director’s class constructor. The director uses the builder object in all further construction. There’s an alternative approach, where the builder is passed to a specific product construction method of the director.


The construction result can be obtained directly from the director only if all products follow the same interface. Otherwise, the client should fetch the result from the builder.




 You can construct objects step-by-step, defer construction steps or run steps recursively.

 You can reuse the same construction code when building various representations of products.

 Single Responsibility Principle. You can isolate complex construction code from the business logic of the product.




 The overall complexity of the code increases since the pattern requires creating multiple new classes.



Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).


Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.


You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.


You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.


Abstract Factories, Builders and Prototypes can all be implemented as Singletons.

"
218,0,composite,"




The Component interface describes operations that are common to both simple and complex elements of the tree.


The Leaf is a basic element of a tree that doesn’t have sub-elements.
Usually, leaf components end up doing most of the real work, since they don’t have anyone to delegate the work to.


The Container (aka composite) is an element that has sub-elements: leaves or other containers. A container doesn’t know the concrete classes of its children. It works with all sub-elements only via the component interface.
Upon receiving a request, a container delegates the work to its sub-elements, processes intermediate results and then returns the final result to the client.


The Client works with all elements through the component interface. As a result, the client can work in the same way with both simple or complex elements of the tree.




 Use the Composite pattern when you have to implement a tree-like object structure.

 The Composite pattern provides you with two basic element types that share a common interface: simple leaves and complex containers. A container can be composed of both leaves and other containers. This lets you construct a nested recursive object structure that resembles a tree.


 Use the pattern when you want the client code to treat both simple and complex elements uniformly.

 All elements defined by the Composite pattern share a common interface. Using this interface, the client doesn’t have to worry about the concrete class of the objects it works with.



Make sure that the core model of your app can be represented as a tree structure. Try to break it down into simple elements and containers. Remember that containers must be able to contain both simple elements and other containers.


Declare the component interface with a list of methods that make sense for both simple and complex components.


Create a leaf class to represent simple elements. A program may have multiple different leaf classes.


Create a container class to represent complex elements. In this class, provide an array field for storing references to sub-elements. The array must be able to store both leaves and containers, so make sure it’s declared with the component interface type.
While implementing the methods of the component interface, remember that a container is supposed to be delegating most of the work to sub-elements.


Finally, define the methods for adding and removal of child elements in the container.
Keep in mind that these operations can be declared in the component interface. This would violate the Interface Segregation Principle because the methods will be empty in the leaf class. However, the client will be able to treat all the elements equally, even when composing the tree.




 You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage.

 Open/Closed Principle. You can introduce new element types into the app without breaking the existing code, which now works with the object tree.




 It might be difficult to provide a common interface for classes whose functionality differs too much. In certain scenarios, you’d need to overgeneralize the component interface, making it harder to comprehend.



You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.


Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.


You can use Iterators to traverse Composite trees.


You can use Visitor to execute an operation over an entire Composite tree.


You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.
A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.
However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.


Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.

"
219,0,memento,"
Implementation based on nested classes
The classic implementation of the pattern relies on support for nested classes, available in many popular programming languages (such as C++, C#, and Java).






The Originator class can produce snapshots of its own state, as well as restore its state from snapshots when needed.


The Memento is a value object that acts as a snapshot of the originator’s state. It’s a common practice to make the memento immutable and pass it the data only once, via the constructor.


The Caretaker knows not only “when” and “why” to capture the originator’s state, but also when the state should be restored.
A caretaker can keep track of the originator’s history by storing a stack of mementos. When the originator has to travel back in history, the caretaker fetches the topmost memento from the stack and passes it to the originator’s restoration method.


In this implementation, the memento class is nested inside the originator. This lets the originator access the fields and methods of the memento, even though they’re declared private. On the other hand, the caretaker has very limited access to the memento’s fields and methods, which lets it store mementos in a stack but not tamper with their state.

Implementation based on an intermediate interface
There’s an alternative implementation, suitable for programming languages that don’t support nested classes (yeah, PHP, I’m talking about you).






In the absence of nested classes, you can restrict access to the memento’s fields by establishing a convention that caretakers can work with a memento only through an explicitly declared intermediary interface, which would only declare methods related to the memento’s metadata.


On the other hand, originators can work with a memento object directly, accessing fields and methods declared in the memento class. The downside of this approach is that you need to declare all members of the memento public.

Implementation with even stricter encapsulation
There’s another implementation which is useful when you don’t want to leave even the slightest chance of other classes accessing the state of the originator through the memento.






This implementation allows having multiple types of originators and mementos. Each originator works with a corresponding memento class. Neither originators nor mementos expose their state to anyone.


Caretakers are now explicitly restricted from changing the state stored in mementos. Moreover, the caretaker class becomes independent from the originator because the restoration method is now defined in the memento class.


Each memento becomes linked to the originator that produced it. The originator passes itself to the memento’s constructor, along with the values of its state. Thanks to the close relationship between these classes, a memento can restore the state of its originator, given that the latter has defined the appropriate setters.




 Use the Memento pattern when you want to produce snapshots of the object’s state to be able to restore a previous state of the object.

 The Memento pattern lets you make full copies of an object’s state, including private fields, and store them separately from the object. While most people remember this pattern thanks to the “undo” use case, it’s also indispensable when dealing with transactions (i.e., if you need to roll back an operation on error).


 Use the pattern when direct access to the object’s fields/getters/setters violates its encapsulation.

 The Memento makes the object itself responsible for creating a snapshot of its state. No other object can read the snapshot, making the original object’s state data safe and secure.



Determine what class will play the role of the originator. It’s important to know whether the program uses one central object of this type or multiple smaller ones.


Create the memento class. One by one, declare a set of fields that mirror the fields declared inside the originator class.


Make the memento class immutable. A memento should accept the data just once, via the constructor. The class should have no setters.


If your programming language supports nested classes, nest the memento inside the originator. If not, extract a blank interface from the memento class and make all other objects use it to refer to the memento. You may add some metadata operations to the interface, but nothing that exposes the originator’s state.


Add a method for producing mementos to the originator class. The originator should pass its state to the memento via one or multiple arguments of the memento’s constructor.
The return type of the method should be of the interface you extracted in the previous step (assuming that you extracted it at all). Under the hood, the memento-producing method should work directly with the memento class.


Add a method for restoring the originator’s state to its class. It should accept a memento object as an argument. If you extracted an interface in the previous step, make it the type of the parameter. In this case, you need to typecast the incoming object to the memento class, since the originator needs full access to that object.


The caretaker, whether it represents a command object, a history, or something entirely different, should know when to request new mementos from the originator, how to store them and when to restore the originator with a particular memento.


The link between caretakers and originators may be moved into the memento class. In this case, each memento must be connected to the originator that had created it. The restoration method would also move to the memento class. However, this would all make sense only if the memento class is nested into originator or the originator class provides sufficient setters for overriding its state.




 You can produce snapshots of the object’s state without violating its encapsulation.

 You can simplify the originator’s code by letting the caretaker maintain the history of the originator’s state.




 The app might consume lots of RAM if clients create mementos too often.

 Caretakers should track the originator’s lifecycle to be able to destroy obsolete mementos.

 Most dynamic programming languages, such as PHP, Python and JavaScript, can’t guarantee that the state within the memento stays untouched.



You can use Command and Memento together when implementing “undo”. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.


You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.


Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.

"
220,0,facade,"




The Facade provides convenient access to a particular part of the subsystem’s functionality. It knows where to direct the client’s request and how to operate all the moving parts.


An Additional Facade class can be created to prevent polluting a single facade with unrelated features that might make it yet another complex structure. Additional facades can be used by both clients and other facades.


The Complex Subsystem consists of dozens of various objects. To make them all do something meaningful, you have to dive deep into the subsystem’s implementation details, such as initializing objects in the correct order and supplying them with data in the proper format.
Subsystem classes aren’t aware of the facade’s existence. They operate within the system and work with each other directly.


The Client uses the facade instead of calling the subsystem objects directly.




 Use the Facade pattern when you need to have a limited but straightforward interface to a complex subsystem.

 Often, subsystems get more complex over time. Even applying design patterns typically leads to creating more classes. A subsystem may become more flexible and easier to reuse in various contexts, but the amount of configuration and boilerplate code it demands from a client grows ever larger. The Facade attempts to fix this problem by providing a shortcut to the most-used features of the subsystem which fit most client requirements.


 Use the Facade when you want to structure a subsystem into layers.

 Create facades to define entry points to each level of a subsystem. You can reduce coupling between multiple subsystems by requiring them to communicate only through facades.
For example, let’s return to our video conversion framework. It can be broken down into two layers: video- and audio-related. For each layer, you can create a facade and then make the classes of each layer communicate with each other via those facades. This approach looks very similar to the Mediator pattern.



Check whether it’s possible to provide a simpler interface than what an existing subsystem already provides. You’re on the right track if this interface makes the client code independent from many of the subsystem’s classes.


Declare and implement this interface in a new facade class. The facade should redirect the calls from the client code to appropriate objects of the subsystem. The facade should be responsible for initializing the subsystem and managing its further life cycle unless the client code already does this.


To get the full benefit from the pattern, make all the client code communicate with the subsystem only via the facade. Now the client code is protected from any changes in the subsystem code. For example, when a subsystem gets upgraded to a new version, you will only need to modify the code in the facade.


If the facade becomes too big, consider extracting part of its behavior to a new, refined facade class.




 You can isolate your code from the complexity of a subsystem.




 A facade can become a god object coupled to all classes of an app.



Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.


Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.


Facade defines a simplified interface to a subsystem of objects, but it doesn’t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

Mediator centralizes communication between components of the system. The components only know about the mediator object and don’t communicate directly.



A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.


Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.

"
221,0,flyweight,"Extrinsic state storageFlyweight and immutabilityFlyweight factory




The Flyweight pattern is merely an optimization. Before applying it, make sure your program does have the RAM consumption problem related to having a massive number of similar objects in memory at the same time. Make sure that this problem can’t be solved in any other meaningful way.


The Flyweight class contains the portion of the original object’s state that can be shared between multiple objects. The same flyweight object can be used in many different contexts. The state stored inside a flyweight is called intrinsic. The state passed to the flyweight’s methods is called extrinsic.


The Context class contains the extrinsic state, unique across all original objects. When a context is paired with one of the flyweight objects, it represents the full state of the original object.


Usually, the behavior of the original object remains in the flyweight class. In this case, whoever calls a flyweight’s method must also pass appropriate bits of the extrinsic state into the method’s parameters. On the other hand, the behavior can be moved to the context class, which would use the linked flyweight merely as a data object.


The Client calculates or stores the extrinsic state of flyweights. From the client’s perspective, a flyweight is a template object which can be configured at runtime by passing some contextual data into parameters of its methods.


The Flyweight Factory manages a pool of existing flyweights. With the factory, clients don’t create flyweights directly. Instead, they call the factory, passing it bits of the intrinsic state of the desired flyweight. The factory looks over previously created flyweights and either returns an existing one that matches search criteria or creates a new one if nothing is found.




 Use the Flyweight pattern only when your program must support a huge number of objects which barely fit into available RAM.

 The benefit of applying the pattern depends heavily on how and where it’s used. It’s most useful when:

an application needs to spawn a huge number of similar objects
this drains all available RAM on a target device
the objects contain duplicate states which can be extracted and shared between multiple objects




Divide fields of a class that will become a flyweight into two parts:

the intrinsic state: the fields that contain unchanging data duplicated across many objects
the extrinsic state: the fields that contain contextual data unique to each object



Leave the fields that represent the intrinsic state in the class, but make sure they’re immutable. They should take their initial values only inside the constructor.


Go over methods that use fields of the extrinsic state. For each field used in the method, introduce a new parameter and use it instead of the field.


Optionally, create a factory class to manage the pool of flyweights. It should check for an existing flyweight before creating a new one. Once the factory is in place, clients must only request flyweights through it. They should describe the desired flyweight by passing its intrinsic state to the factory.


The client must store or calculate values of the extrinsic state (context) to be able to call methods of flyweight objects. For the sake of convenience, the extrinsic state along with the flyweight-referencing field may be moved to a separate context class.




 You can save lots of RAM, assuming your program has tons of similar objects.




 You might be trading RAM over CPU cycles when some of the context data needs to be recalculated each time somebody calls a flyweight method.

 The code becomes much more complicated. New team members will always be wondering why the state of an entity was separated in such a way.



You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.


Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.


Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.
The Singleton object can be mutable. Flyweight objects are immutable.


"
222,0,chain_of_responsibility,"

One of your colleagues suggested that it’s unsafe to pass raw data straight to the ordering system. So you added an extra validation step to sanitize the data in a request.


Later, somebody noticed that the system is vulnerable to brute force password cracking. To negate this, you promptly added a check that filters repeated failed requests coming from the same IP address.


Someone else suggested that you could speed up the system by returning cached results on repeated requests containing the same data. Hence, you added another check which lets the request pass through to the system only if there’s no suitable cached response.






The Handler declares the interface, common for all concrete handlers. It usually  contains just a single method for handling requests, but sometimes it may also have another method for setting the next handler on the chain.


The Base Handler is an optional class where you can put the boilerplate code that’s common to all handler classes.
Usually, this class defines a field for storing a reference to the next handler. The clients can build a chain by passing a handler to the constructor or setter of the previous handler. The class may also implement the default handling behavior: it can pass execution to the next handler after checking for its existence.


Concrete Handlers contain the actual code for processing requests. Upon receiving a request, each handler must decide whether to process it and, additionally, whether to pass it along the chain.
Handlers are usually self-contained and immutable, accepting all necessary data just once via the constructor.


The Client may compose chains just once or compose them dynamically, depending on the application’s logic. Note that a request can be sent to any handler in the chain—it doesn’t have to be the first one.




 Use the Chain of Responsibility pattern when your program is expected to process different kinds of requests in various ways, but the exact types of requests and their sequences are unknown beforehand.

 The pattern lets you link several handlers into one chain and, upon receiving a request, “ask” each handler whether it can process it. This way all handlers get a chance to process the request.


 Use the pattern when it’s essential to execute several handlers in a particular order.

 Since you can link the handlers in the chain in any order, all requests will get through the chain exactly as you planned.


 Use the CoR pattern when the set of handlers and their order are supposed to change at runtime.

 If you provide setters for a reference field inside the handler classes, you’ll be able to insert, remove or reorder handlers dynamically.



Declare the handler interface and describe the signature of a method for handling requests.
Decide how the client will pass the request data into the method. The most flexible way is to convert the request into an object and pass it to the handling method as an argument.


To eliminate duplicate boilerplate code in concrete handlers, it might be worth creating an abstract base handler class, derived from the handler interface.
This class should have a field for storing a reference to the next handler in the chain. Consider making the class immutable. However, if you plan to modify chains at runtime, you need to define a setter for altering the value of the reference field.
You can also implement the convenient default behavior for the handling method, which is to forward the request to the next object unless there’s none left. Concrete handlers will be able to use this behavior by calling the parent method.


One by one create concrete handler subclasses and implement their handling methods. Each handler should make two decisions when receiving a request:

Whether it’ll process the request.
Whether it’ll pass the request along the chain.



The client may either assemble chains on its own or receive pre-built chains from other objects. In the latter case, you must implement some factory classes to build chains according to the configuration or environment settings.


The client may trigger any handler in the chain, not just the first one. The request will be passed along the chain until some handler refuses to pass it further or until it reaches the end of the chain.


Due to the dynamic nature of the chain, the client should be ready to handle the following scenarios:

The chain may consist of a single link.
Some requests may not reach the end of the chain.
Others may reach the end of the chain unhandled.





 You can control the order of request handling.

 Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform operations.

 Open/Closed Principle. You can introduce new handlers into the app without breaking the existing client code.




 Some requests may end up unhandled.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.


Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.
However, there’s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.


Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.
The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.

"
223,0,mediator,"




Components are various classes that contain some business logic. Each component has a reference to a mediator, declared with the type of the mediator interface. The component isn’t aware of the actual class of the mediator, so you can reuse the component in other programs by linking it to a different mediator.


The Mediator interface declares methods of communication with components, which usually include just a single notification method. Components may pass any context as arguments of this method, including their own objects, but only in such a way that no coupling occurs between a receiving component and the sender’s class.


Concrete Mediators encapsulate relations between various components. Concrete mediators often keep references to all components they manage and sometimes even manage their lifecycle.


Components must not be aware of other components. If something important happens within or to a component, it must only notify the mediator. When the mediator receives the notification, it can easily identify the sender, which might be just enough to decide what component should be triggered in return.
From a component’s perspective, it all looks like a total black box. The sender doesn’t know who’ll end up handling its request, and the receiver doesn’t know who sent the request in the first place.




 Use the Mediator pattern when it’s hard to change some of the classes because they are tightly coupled to a bunch of other classes.

 The pattern lets you extract all the relationships between classes into a separate class, isolating any changes to a specific component from the rest of the components.


 Use the pattern when you can’t reuse a component in a different program because it’s too dependent on other components.

 After you apply the Mediator, individual components become unaware of the other components. They could still communicate with each other, albeit indirectly, through a mediator object. To reuse a component in a different app, you need to provide it with a new mediator class.


 Use the Mediator when you find yourself creating tons of component subclasses just to reuse some basic behavior in various contexts.

 Since all relations between components are contained within the mediator, it’s easy to define entirely new ways for these components to collaborate by introducing new mediator classes, without having to change the components themselves.



Identify a group of tightly coupled classes which would benefit from being more independent (e.g., for easier maintenance or simpler reuse of these classes).


Declare the mediator interface and describe the desired communication protocol between mediators and various components. In most cases, a single method for receiving notifications from components is sufficient.
This interface is crucial when you want to reuse component classes in different contexts. As long as the component works with its mediator via the generic interface, you can link the component with a different implementation of the mediator.


Implement the concrete mediator class. Consider storing references to all components inside the mediator. This way, you could call any component from the mediator’s methods.


You can go even further and make the mediator responsible for the creation and destruction of component objects. After this, the mediator may resemble a factory or a facade.


Components should store a reference to the mediator object. The connection is usually established in the component’s constructor, where a mediator object is passed as an argument.


Change the components’ code so that they call the mediator’s notification method instead of methods on other components. Extract the code that involves calling other components into the mediator class. Execute this code whenever the mediator receives notifications from that component.




 Single Responsibility Principle. You can extract the communications between various components into a single place, making it easier to comprehend and maintain.

 Open/Closed Principle. You can introduce new mediators without having to change the actual components.

 You can reduce coupling between various components of a program.

 You can reuse individual components more easily.




 Over time a mediator can evolve into a God Object.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.


Facade defines a simplified interface to a subsystem of objects, but it doesn’t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

Mediator centralizes communication between components of the system. The components only know about the mediator object and don’t communicate directly.



The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let’s see how we can do that.
The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.
There’s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator’s events. When Mediator is implemented this way, it may look very similar to Observer.
When you’re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won’t resemble Observer but will still be an instance of the Mediator pattern.
Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won’t be a centralized mediator object, only a distributed set of observers.

"
224,0,iterator,"




The Iterator interface declares the operations required for traversing a collection: fetching the next element, retrieving the current position, restarting iteration, etc.


Concrete Iterators implement specific algorithms for traversing a collection. The iterator object should track the traversal progress on its own. This allows several iterators to traverse the same collection independently of each other.


The Collection interface declares one or multiple methods for getting iterators compatible with the collection. Note that the return type of the methods must be declared as the iterator interface so that the concrete collections can return various kinds of iterators.


Concrete Collections return new instances of a particular concrete iterator class each time the client requests one. You might be wondering, where’s the rest of the collection’s code? Don’t worry, it should be in the same class. It’s just that these details aren’t crucial to the actual pattern, so we’re omitting them.


The Client works with both collections and iterators via their interfaces. This way the client isn’t coupled to concrete classes, allowing you to use various collections and iterators with the same client code.
Typically, clients don’t create iterators on their own, but instead get them from collections. Yet, in certain cases, the client can create one directly; for example, when the client defines its own special iterator.




 Use the Iterator pattern when your collection has a complex data structure under the hood, but you want to hide its complexity from clients (either for convenience or security reasons).

 The iterator encapsulates the details of working with a complex data structure, providing the client with several simple methods of accessing the collection elements. While this approach is very convenient for the client, it also protects the collection from careless or malicious actions which the client would be able to perform if working with the collection directly.


 Use the pattern to reduce duplication of the traversal code across your app.

 The code of non-trivial iteration algorithms tends to be very bulky. When placed within the business logic of an app, it may blur the responsibility of the original code and make it less maintainable. Moving the traversal code to designated iterators can help you make the code of the application more lean and clean.


 Use the Iterator when you want your code to be able to traverse different data structures or when types of these structures are unknown beforehand.

 The pattern provides a couple of generic interfaces for both collections and iterators. Given that your code now uses these interfaces, it’ll still work if you pass it various kinds of collections and iterators that implement these interfaces.



Declare the iterator interface. At the very least, it must have a method for fetching the next element from a collection. But for the sake of convenience you can add a couple of other methods, such as fetching the previous element, tracking the current position, and checking the end of the iteration.


Declare the collection interface and describe a method for fetching iterators. The return type should be equal to that of the iterator interface. You may declare similar methods if you plan to have several distinct groups of iterators.


Implement concrete iterator classes for the collections that you want to be traversable with iterators. An iterator object must be linked with a single collection instance. Usually, this link is established via the iterator’s constructor.


Implement the collection interface in your collection classes. The main idea is to provide the client with a shortcut for creating iterators, tailored for a particular collection class. The collection object must pass itself to the iterator’s constructor to establish a link between them.


Go over the client code to replace all of the collection traversal code with the use of iterators. The client fetches a new iterator object each time it needs to iterate over the collection elements.




 Single Responsibility Principle. You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes.

 Open/Closed Principle. You can implement new types of collections and iterators and pass them to existing code without breaking anything.

 You can iterate over the same collection in parallel because each iterator object contains its own iteration state.

 For the same reason, you can delay an iteration and continue it when needed.




 Applying the pattern can be an overkill if your app only works with simple collections.

 Using an iterator may be less efficient than going through elements of some specialized collections directly.



You can use Iterators to traverse Composite trees.


You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.


You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.


You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.

"
225,0,observer,"




The Publisher issues events of interest to other objects. These events occur when the publisher changes its state or executes some behaviors. Publishers contain a subscription infrastructure that lets new subscribers join and current subscribers leave the list.


When a new event happens, the publisher goes over the subscription list and calls the notification method declared in the subscriber interface on each subscriber object.


The Subscriber interface declares the notification interface. In most cases, it consists of a single update method. The method may have several parameters that let the publisher pass some event details along with the update.


Concrete Subscribers perform some actions in response to notifications issued by the publisher. All of these classes must implement the same interface so the publisher isn’t coupled to concrete classes.


Usually, subscribers need some contextual information to handle the update correctly. For this reason, publishers often pass some context data as arguments of the notification method. The publisher can pass itself as an argument, letting subscriber fetch any required data directly.


The Client creates publisher and subscriber objects separately and then registers subscribers for publisher updates.




 Use the Observer pattern when changes to the state of one object may require changing other objects, and the actual set of objects is unknown beforehand or changes dynamically.

 You can often experience this problem when working with classes of the graphical user interface. For example, you created custom button classes, and you want to let the clients hook some custom code to your buttons so that it fires whenever a user presses a button.
The Observer pattern lets any object that implements the subscriber interface subscribe for event notifications in publisher objects. You can add the subscription mechanism to your buttons, letting the clients hook up their custom code via custom subscriber classes.


 Use the pattern when some objects in your app must observe others, but only for a limited time or in specific cases.

 The subscription list is dynamic, so subscribers can join or leave the list whenever they need to.



Look over your business logic and try to break it down into two parts: the core functionality, independent from other code, will act as the publisher; the rest will turn into a set of subscriber classes.


Declare the subscriber interface. At a bare minimum, it should declare a single update method.


Declare the publisher interface and describe a pair of methods for adding a subscriber object to and removing it from the list. Remember that publishers must work with subscribers only via the subscriber interface.


Decide where to put the actual subscription list and the implementation of subscription methods. Usually, this code looks the same for all types of publishers, so the obvious place to put it is in an abstract class derived directly from the publisher interface. Concrete publishers extend that class, inheriting the subscription behavior.
However, if you’re applying the pattern to an existing class hierarchy, consider an approach based on composition: put the subscription logic into a separate object, and make all real publishers use it.


Create concrete publisher classes. Each time something important happens inside a publisher, it must notify all its subscribers.


Implement the update notification methods in concrete subscriber classes. Most subscribers would need some context data about the event. It can be passed as an argument of the notification method.
But there’s another option. Upon receiving a notification, the subscriber can fetch any data directly from the notification. In this case, the publisher must pass itself via the update method. The less flexible option is to link a publisher to the subscriber permanently via the constructor.


The client must create all necessary subscribers and register them with proper publishers.




 Open/Closed Principle. You can introduce new subscriber classes without having to change the publisher’s code (and vice versa if there’s a publisher interface).

 You can establish relations between objects at runtime.




 Subscribers are notified in random order.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let’s see how we can do that.
The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.
There’s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator’s events. When Mediator is implemented this way, it may look very similar to Observer.
When you’re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won’t resemble Observer but will still be an instance of the Mediator pattern.
Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won’t be a centralized mediator object, only a distributed set of observers.

"
226,0,template_method,"

abstract steps must be implemented by every subclass

optional steps already have some default implementation, but still can be overridden if needed





The Abstract Class declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order. The steps may either be declared abstract or have some default implementation.


Concrete Classes can override all of the steps, but not the template method itself.




 Use the Template Method pattern when you want to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure.

 The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass.


 Use the pattern when you have several classes that contain almost identical algorithms with some minor differences. As a result, you might need to modify all classes when the algorithm changes.

 When you turn such an algorithm into a template method, you can also pull up the steps with similar implementations into a superclass, eliminating code duplication. Code that varies between subclasses can remain in subclasses.



Analyze the target algorithm to see whether you can break it into steps. Consider which steps are common to all subclasses and which ones will always be unique.


Create the abstract base class and declare the template method and a set of abstract methods representing the algorithm’s steps. Outline the algorithm’s structure in the template method by executing corresponding steps. Consider making the template method final to prevent subclasses from overriding it.


It’s okay if all the steps end up being abstract. However, some steps might benefit from having a default implementation. Subclasses don’t have to implement those methods.


Think of adding hooks between the crucial steps of the algorithm.


For each variation of the algorithm, create a new concrete subclass. It must implement all of the abstract steps, but may also override some of the optional ones.




 You can let clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm.

 You can pull the duplicate code into a superclass.




 Some clients may be limited by the provided skeleton of an algorithm.

 You might violate the Liskov Substitution Principle by suppressing a default step implementation via a subclass.

 Template methods tend to be harder to maintain the more steps they have.



Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.


Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object’s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it’s static. Strategy works on the object level, letting you switch behaviors at runtime.

"
227,0,command,"




The Sender class (aka invoker) is responsible for initiating requests. This class must have a field for storing a reference to a command object. The sender triggers that command instead of sending the request directly to the receiver. Note that the sender isn’t responsible for creating the command object. Usually, it gets a pre-created command from the client via the constructor.


The Command interface usually declares just a single method for executing the command.


Concrete Commands implement various kinds of requests. A concrete command isn’t supposed to perform the work on its own, but rather to pass the call to one of the business logic objects. However, for the sake of simplifying the code, these classes can be merged.
Parameters required to execute a method on a receiving object can be declared as fields in the concrete command. You can make command objects immutable by only allowing the initialization of these fields via the constructor.


The Receiver class contains some business logic. Almost any object may act as a receiver. Most commands only handle the details of how a request is passed to the receiver, while the receiver itself does the actual work.


The Client creates and configures concrete command objects. The client must pass all of the request parameters, including a receiver instance, into the command’s constructor. After that, the resulting command may be associated with one or multiple senders.




 Use the Command pattern when you want to parametrize objects with operations.

 The Command pattern can turn a specific method call into a stand-alone object. This change opens up a lot of interesting uses: you can pass commands as method arguments, store them inside other objects, switch linked commands at runtime, etc.
Here’s an example: you’re developing a GUI component such as a context menu, and you want your users to be able to configure menu items that trigger operations when an end user clicks an item.


 Use the Command pattern when you want to queue operations, schedule their execution, or execute them remotely.

 As with any other object, a command can be serialized, which means converting it to a string that can be easily written to a file or a database. Later, the string can be restored as the initial command object. Thus, you can delay and schedule command execution. But there’s even more! In the same way, you can queue, log or send commands over the network.


 Use the Command pattern when you want to implement reversible operations.

 Although there are many ways to implement undo/redo, the Command pattern is perhaps the most popular of all.
To be able to revert operations, you need to implement the history of performed operations. The command history is a stack that contains all executed command objects along with related backups of the application’s state.
This method has two drawbacks. First, it isn’t that easy to save an application’s state because some of it can be private. This problem can be mitigated with the Memento pattern.
Second, the state backups may consume quite a lot of RAM. Therefore, sometimes you can resort to an alternative implementation: instead of restoring the past state, the command performs the inverse operation. The reverse operation also has a price: it may turn out to be hard or even impossible to implement.



Declare the command interface with a single execution method.


Start extracting requests into concrete command classes that implement the command interface. Each class must have a set of fields for storing the request arguments along with a reference to the actual receiver object. All these values must be initialized via the command’s constructor.


Identify classes that will act as senders. Add the fields for storing commands into these classes. Senders should communicate with their commands only via the command interface. Senders usually don’t create command objects on their own, but rather get them from the client code.


Change the senders so they execute the command instead of sending a request to the receiver directly.


The client should initialize objects in the following order:

Create receivers.
Create commands, and associate them with receivers if needed.
Create senders, and associate them with specific commands.





 Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform these operations.

 Open/Closed Principle. You can introduce new commands into the app without breaking existing client code.

 You can implement undo/redo.

 You can implement deferred execution of operations.

 You can assemble a set of simple commands into a complex one.




 The code may become more complicated since you’re introducing a whole new layer between senders and receivers.



Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:


Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.

Command establishes unidirectional connections between senders and receivers.

Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.

Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.



Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.
However, there’s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.


You can use Command and Memento together when implementing “undo”. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.


Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.


You can use Command to convert any operation into an object. The operation’s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.


On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.




Prototype can help when you need to save copies of Commands into history.


You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.

"
228,0,state,"
In Draft, it moves the document to moderation.
In Moderation, it makes the document public, but only if the current user is an administrator.
In Published, it doesn’t do anything at all.

When the phone is unlocked, pressing buttons leads to executing various functions.
When the phone is locked, pressing any button leads to the unlock screen.
When the phone’s charge is low, pressing any button shows the charging screen.





Context stores a reference to one of the concrete state objects and delegates to it all state-specific work. The context communicates with the state object via the state interface. The context exposes a setter for passing it a new state object.


The State interface declares the state-specific methods. These methods should make sense for all concrete states because you don’t want some of your states to have useless methods that will never be called.


Concrete States provide their own implementations for the state-specific methods. To avoid duplication of similar code across multiple states, you may provide intermediate abstract classes that encapsulate some common behavior.
State objects may store a backreference to the context object. Through this reference, the state can fetch any required info from the context object, as well as initiate state transitions.


Both context and concrete states can set the next state of the context and perform the actual state transition by replacing the state object linked to the context.




 Use the State pattern when you have an object that behaves differently depending on its current state, the number of states is enormous, and the state-specific code changes frequently.

 The pattern suggests that you extract all state-specific code into a set of distinct classes. As a result, you can add new states or change existing ones independently of each other, reducing the maintenance cost.


 Use the pattern when you have a class polluted with massive conditionals that alter how the class behaves according to the current values of the class’s fields.

 The State pattern lets you extract branches of these conditionals into methods of corresponding state classes. While doing so, you can also clean temporary fields and helper methods involved in state-specific code out of your main class.


 Use State when you have a lot of duplicate code across similar states and transitions of a condition-based state machine.

 The State pattern lets you compose hierarchies of state classes and reduce duplication by extracting common code into abstract base classes.



Decide what class will act as the context. It could be an existing class which already has the state-dependent code; or a new class, if the state-specific code is distributed across multiple classes.


Declare the state interface. Although it may mirror all the methods declared in the context, aim only for those that may contain state-specific behavior.


For every actual state, create a class that derives from the state interface. Then go over the methods of the context and extract all code related to that state into your newly created class.
While moving the code to the state class, you might discover that it depends on private members of the context. There are several workarounds:

Make these fields or methods public.
Turn the behavior you’re extracting into a public method in the context and call it from the state class. This way is ugly but quick, and you can always fix it later.
Nest the state classes into the context class, but only if your programming language supports nesting classes.



In the context class, add a reference field of the state interface type and a public setter that allows overriding the value of that field.


Go over the method of the context again and replace empty state conditionals with calls to corresponding methods of the state object.


To switch the state of the context, create an instance of one of the state classes and pass it to the context. You can do this within the context itself, or in various states, or in the client. Wherever this is done, the class becomes dependent on the concrete state class that it instantiates.




 Single Responsibility Principle. Organize the code related to particular states into separate classes.

 Open/Closed Principle. Introduce new states without changing existing state classes or the context.

 Simplify the code of the context by eliminating bulky state machine conditionals.




 Applying the pattern can be overkill if a state machine has only a few states or rarely changes.



Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn’t restrict dependencies between concrete states, letting them alter the state of the context at will.

"
229,0,visitor,"
If it’s a residential building, he sells medical insurance.
If it’s a bank, he sells theft insurance.
If it’s a coffee shop, he sells fire and flood insurance.





The Visitor interface declares a set of visiting methods that can take concrete elements of an object structure as arguments. These methods may have the same names if the program is written in a language that supports overloading, but the type of their parameters must be different.


Each Concrete Visitor implements several versions of the same behaviors, tailored for different concrete element classes.


The Element interface declares a method for “accepting” visitors. This method should have one parameter declared with the type of the visitor interface.


Each Concrete Element must implement the acceptance method. The purpose of this method is to redirect the call to the proper visitor’s method corresponding to the current element class. Be aware that even if a base element class implements this method, all subclasses must still override this method in their own classes and call the appropriate method on the visitor object.


The Client usually represents a collection or some other complex object (for example, a Composite tree). Usually, clients aren’t aware of all the concrete element classes because they work with objects from that collection via some abstract interface.




 Use the Visitor when you need to perform an operation on all elements of a complex object structure (for example, an object tree).

 The Visitor pattern lets you execute an operation over a set of objects with different classes by having a visitor object implement several variants of the same operation, which correspond to all target classes.


 Use the Visitor to clean up the business logic of auxiliary behaviors.

 The pattern lets you make the primary classes of your app more focused on their main jobs by extracting all other behaviors into a set of visitor classes.


 Use the pattern when a behavior makes sense only in some classes of a class hierarchy, but not in others.

 You can extract this behavior into a separate visitor class and implement only those visiting methods that accept objects of relevant classes, leaving the rest empty.



Declare the visitor interface with a set of “visiting” methods, one per each concrete element class that exists in the program.


Declare the element interface. If you’re working with an existing element class hierarchy, add the abstract “acceptance” method to the base class of the hierarchy. This method should accept a visitor object as an argument.


Implement the acceptance methods in all concrete element classes. These methods must simply redirect the call to a visiting method on the incoming visitor object which matches the class of the current element.


The element classes should only work with visitors via the visitor interface. Visitors, however, must be aware of all concrete element classes, referenced as parameter types of the visiting methods.


For each behavior that can’t be implemented inside the element hierarchy, create a new concrete visitor class and implement all of the visiting methods.
You might encounter a situation where the visitor will need access to some private members of the element class. In this case, you can either make these fields or methods public, violating the element’s encapsulation, or nest the visitor class in the element class. The latter is only possible if you’re lucky to work with a programming language that supports nested classes.


The client must create visitor objects and pass them into elements via “acceptance” methods.




 Open/Closed Principle. You can introduce a new behavior that can work with objects of different classes without changing these classes.

 Single Responsibility Principle. You can move multiple versions of the same behavior into the same class.

 A visitor object can accumulate some useful information while working with various objects. This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure.




 You need to update all visitors each time a class gets added to or removed from the element hierarchy.

 Visitors might lack the necessary access to the private fields and methods of the elements that they’re supposed to work with.



You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.


You can use Visitor to execute an operation over an entire Composite tree.


You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.


Puzzled why we can’t simply replace the Visitor pattern with method overloading? Read my article Visitor and Double Dispatch to learn about the nasty details.
"
230,0,strategy,"




The Context maintains a reference to one of the concrete strategies and communicates with this object only via the strategy interface.


The Strategy interface is common to all concrete strategies. It declares a method the context uses to execute a strategy.


Concrete Strategies implement different variations of an algorithm the context uses.


The context calls the execution method on the linked strategy object each time it needs to run the algorithm. The context doesn’t know what type of strategy it works with or how the algorithm is executed.


The Client creates a specific strategy object and passes it to the context. The context exposes a setter which lets clients replace the strategy associated with the context at runtime.




 Use the Strategy pattern when you want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime.

 The Strategy pattern lets you indirectly alter the object’s behavior at runtime by associating it with different sub-objects which can perform specific sub-tasks in different ways.


 Use the Strategy when you have a lot of similar classes that only differ in the way they execute some behavior.

 The Strategy pattern lets you extract the varying behavior into a separate class hierarchy and combine the original classes into one, thereby reducing duplicate code.


 Use the pattern to isolate the business logic of a class from the implementation details of algorithms that may not be as important in the context of that logic.

 The Strategy pattern lets you isolate the code, internal data, and dependencies of various algorithms from the rest of the code. Various clients get a simple interface to execute the algorithms and switch them at runtime.


 Use the pattern when your class has a massive conditional statement that switches between different variants of the same algorithm.

 The Strategy pattern lets you do away with such a conditional by extracting all algorithms into separate classes, all of which implement the same interface. The original object delegates execution to one of these objects, instead of implementing all variants of the algorithm.



In the context class, identify an algorithm that’s prone to frequent changes. It may also be a massive conditional that selects and executes a variant of the same algorithm at runtime.


Declare the strategy interface common to all variants of the algorithm.


One by one, extract all algorithms into their own classes. They should all implement the strategy interface.


In the context class, add a field for storing a reference to a strategy object. Provide a setter for replacing values of that field. The context should work with the strategy object only via the strategy interface. The context may define an interface which lets the strategy access its data.


Clients of the context must associate it with a suitable strategy that matches the way they expect the context to perform its primary job.




 You can swap algorithms used inside an object at runtime.

 You can isolate the implementation details of an algorithm from the code that uses it.

 You can replace inheritance with composition.

 Open/Closed Principle. You can introduce new strategies without having to change the context.




 If you only have a couple of algorithms and they rarely change, there’s no real reason to overcomplicate the program with new classes and interfaces that come along with the pattern.

 Clients must be aware of the differences between strategies to be able to select a proper one.

 A lot of modern programming languages have functional type support that lets you implement different versions of an algorithm inside a set of anonymous functions. Then you could use these functions exactly as you’d have used the strategy objects, but without bloating your code with extra classes and interfaces.



Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.


Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.


You can use Command to convert any operation into an object. The operation’s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.


On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.




Decorator lets you change the skin of an object, while Strategy lets you change the guts.


Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object’s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it’s static. Strategy works on the object level, letting you switch behaviors at runtime.


State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn’t restrict dependencies between concrete states, letting them alter the state of the context at will.

"
231,0,proxy,"




The Service Interface declares the interface of the Service. The proxy must follow this interface to be able to disguise itself as a service object.


The Service is a class that provides some useful business logic.


The Proxy class has a reference field that points to a service object. After the proxy finishes its processing (e.g., lazy initialization, logging, access control, caching, etc.), it passes the request to the service object.
Usually, proxies manage the full lifecycle of their service objects.


The Client should work with both services and proxies via the same interface. This way you can pass a proxy into any code that expects a service object.



There are dozens of ways to utilize the Proxy pattern. Let’s go over the most popular uses.

 Lazy initialization (virtual proxy). This is when you have a heavyweight service object that wastes system resources by being always up, even though you only need it from time to time.

 Instead of creating the object when the app launches, you can delay the object’s initialization to a time when it’s really needed.


 Access control (protection proxy). This is when you want only specific clients to be able to use the service object; for instance, when your objects are crucial parts of an operating system and clients are various launched applications (including malicious ones).

 The proxy can pass the request to the service object only if the client’s credentials match some criteria.


 Local execution of a remote service (remote proxy). This is when the service object is located on a remote server.

 In this case, the proxy passes the client request over the network, handling all of the nasty details of working with the network.


 Logging requests (logging proxy). This is when you want to keep a history of requests to the service object.

 The proxy can log each request before passing it to the service.


 Caching request results (caching proxy). This is when you need to cache results of client requests and manage the life cycle of this cache, especially if results are quite large.

 The proxy can implement caching for recurring requests that always yield the same results. The proxy may use the parameters of requests as the cache keys.


 Smart reference. This is when you need to be able to dismiss a heavyweight object once there are no clients that use it.

 The proxy can keep track of clients that obtained a reference to the service object or its results. From time to time, the proxy may go over the clients and check whether they are still active. If the client list gets empty, the proxy might dismiss the service object and free the underlying system resources.
The proxy can also track whether the client had modified the service object. Then the unchanged objects may be reused by other clients.



If there’s no pre-existing service interface, create one to make proxy and service objects interchangeable. Extracting the interface from the service class isn’t always possible, because you’d need to change all of the service’s clients to use that interface. Plan B is to make the proxy a subclass of the service class, and this way it’ll inherit the interface of the service.


Create the proxy class. It should have a field for storing a reference to the service. Usually, proxies create and manage the whole life cycle of their services. On rare occasions, a service is passed to the proxy via a constructor by the client.


Implement the proxy methods according to their purposes. In most cases, after doing some work, the proxy should delegate the work to the service object.


Consider introducing a creation method that decides whether the client gets a proxy or a real service. This can be a simple static method in the proxy class or a full-blown factory method.


Consider implementing lazy initialization for the service object.




 You can control the service object without clients knowing about it.

 You can manage the lifecycle of the service object when clients don’t care about it.

 The proxy works even if the service object isn’t ready or is not available.

 Open/Closed Principle. You can introduce new proxies without changing the service or clients.




 The code may become more complicated since you need to introduce a lot of new classes.

 The response from the service might get delayed.



Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.


Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.


Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.

"
